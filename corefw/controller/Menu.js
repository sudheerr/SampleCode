// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.controller.Menu', {
  extend: 'Ext.app.Controller',
  init: function() {
    this.control({
      "[corefieldtype=objectgrid]": {
        cellcontextmenu: this.onCellCtxMenuGrid
      },
      "[corefieldtype=rcgrid]": {
        cellcontextmenu: this.onCellCtxMenuGrid
      },
      "coretreegrid treepanel[isLocked!=true]": {
        cellcontextmenu: this.onTreeCellCtxMenu
      },
      "coretreesimple treepanel": {
        cellcontextmenu: this.onTreeCellCtxMenu
      },
      "[coretype=navmenubutton]:not([activateEvent])": {
        click: this.onNavMenuClick
      },
      "[coretype=navmenubutton][activateEvent=ONRIGHTCLICK]": {
        contextmenu: this.onNavMenuClick,
        afterrender: this.onRCNavAfterRender
      },
      "menu[menutype=popup]": {
        hide: this.onMenuHide
      },
      "menu[menutype!=popup]": {
        beforeshow: this.onMenuBeforeShow
      }
    });
  },
  onRCNavAfterRender: function(comp) {
    comp.el.on('contextmenu', function(event) {
      comp.fireEvent('contextmenu', comp, event);
    });
  },
  onMenuBeforeShow: function(menu) {
    var activeHeader, grid, menuArray, menuArrayItem, su, _i, _len;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      menu.showSeparator = false;
    }
    activeHeader = menu.activeHeader;
    if (!activeHeader) {
      return;
    }
    grid = activeHeader.ownerLayout.grid;
    grid.reconfigMenuItems(menu);
    menuArray = menu.items.items;
    for (_i = 0, _len = menuArray.length; _i < _len; _i++) {
      menuArrayItem = menuArray[_i];
      if (menuArrayItem.menu) {
        menuArrayItem.cls = "hasSubMenu";
      }
    }
    grid.setHeaderActive(activeHeader);
  },
  onMenuHide: function(comp) {
    Ext.destroy(comp);
  },
  createCellMenuItems: function(component, insideObj, cache, e, eOpts, record, rowindex, columnindex, column) {
    var menuCache, options, _ref;
    menuCache = cache != null ? (_ref = cache._myProperties) != null ? _ref.menu : void 0 : void 0;
    if (menuCache) {
      options = {
        menutype: 'context',
        contextOwner: insideObj,
        component: component,
        record: record
      };
      this.createMenuItems(menuCache, e, options);
    } else {
      this.createContextMenu(component, insideObj, record, rowindex, columnindex, e, eOpts, column);
    }
  },
  onTreeCellCtxMenu: function(dataview, td, columnindex, record, tr, rowindex, e, eOpts) {
    var column, component;
    component = dataview.up('coretreegrid, coretreesimple');
    column = dataview.getHeaderByCell(td);
    this.createCellMenuItems(component, component.tree, column.cache, e, eOpts, record, rowindex, columnindex, column);
  },
  onCellCtxMenuGrid: function(dataview, td, columnindex, record, tr, rowindex, e, eOpts) {
    var column, component;
    component = dataview.up('corercgrid');
    if (!component) {
      component = dataview.up('coreobjectgrid');
    }
    column = dataview.getHeaderByCell(td);
    this.createCellMenuItems(component, component.grid, column.cache, e, eOpts, record, rowindex, columnindex, column);
  },
  createContextMenu: function(comp, insideObj, record, rowindex, columnindex, e, eOpts, column) {
    var cache, cm, col, dataview, info, menuCache, options, props, rightClickEvent, _ref, _ref1, _ref2, _ref3, _ref4;
    cm = Corefw.util.Common;
    if (cm.processProhibited(comp)) {
      return false;
    }
    cache = comp.cache;
    props = cache != null ? cache._myProperties : void 0;
    if (!props) {
      return;
    }
    rightClickEvent = (_ref = props.events) != null ? _ref.ONRIGHTCLICK : void 0;
    if (rightClickEvent) {
      if (comp.grid) {
        this.processGridRightClickEvent(comp, insideObj, record, rowindex, columnindex, e, column);
      } else if (comp.tree) {
        this.processTreeRightClickEvent(comp, insideObj, record, rowindex, columnindex, e, column);
      }
      return;
    }
    if (comp.grid) {
      dataview = comp.grid.getView();
      if (dataview.locked) {
        col = column;
      } else {
        col = dataview.getHeaderAtIndex(columnindex);
      }
      props.rowindex = rowindex;
      props.columnUipath = col != null ? (_ref1 = col.cache) != null ? (_ref2 = _ref1._myProperties) != null ? _ref2.uipath : void 0 : void 0 : void 0;
      props.columnPath = col != null ? (_ref3 = col.cache) != null ? (_ref4 = _ref3._myProperties) != null ? _ref4.pathString : void 0 : void 0 : void 0;
    }
    menuCache = props.menu;
    if (!menuCache) {
      return;
    }
    options = {
      menutype: 'context',
      contextOwner: insideObj,
      component: comp,
      record: record
    };
    info = {
      component: comp,
      contextOwner: insideObj,
      cache: cache,
      record: record,
      rowindex: rowindex,
      columnindex: columnindex,
      e: e
    };
    this.createMenuItems(menuCache, e, options);
    return false;
  },
  processTreeRightClickEvent: function(comp, insideObj, record, rowindex, columnindex, e, column) {
    var me, postData, processMenuResponse, props, rq, uipath, url;
    me = this;
    rq = Corefw.util.Request;
    uipath = comp.uipath;
    props = comp.cache._myProperties;
    url = rq.objsToUrl3(props.events.ONRIGHTCLICK);
    processMenuResponse = function(menuObj, ev, uipath) {
      var options;
      if (menuObj.messageType) {
        me.showSessionTimeoutMsgBox(menuObj);
        return;
      }
      options = {
        menutype: 'context',
        contextOwner: insideObj,
        component: comp,
        record: record
      };
      me.createMenuItems(menuObj, ev, options);
    };
    record.isEditing = true;
    postData = comp.generatePostData();
    rq.sendRequest5(url, processMenuResponse, uipath, postData, void 0, void 0, void 0, e);
    record.isEditing = false;
    e.stopEvent();
  },
  processGridRightClickEvent: function(comp, insideObj, record, rowindex, columnindex, e, column) {
    var col, columnPath, columnUipath, dataview, host, item, me, postData, processMenuResponse, props, rq, selection, uipath, url, valueItems, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    me = this;
    rq = Corefw.util.Request;
    uipath = comp.uipath;
    props = comp.cache._myProperties;
    url = rq.objsToUrl3(props.events.ONRIGHTCLICK);
    dataview = comp.grid.getView();
    if (dataview.locked) {
      col = column;
    } else {
      col = dataview.getHeaderAtIndex(columnindex);
    }
    columnUipath = col != null ? (_ref = col.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.uipath : void 0 : void 0 : void 0;
    columnPath = col != null ? (_ref2 = col.cache) != null ? (_ref3 = _ref2._myProperties) != null ? _ref3.pathString : void 0 : void 0 : void 0;
    if (!columnUipath) {
      return;
    }
    postData = {
      name: props.name,
      rowindex: rowindex,
      columnUipath: columnUipath,
      columnPath: columnPath
    };
    host = comp.grid;
    if (host) {
      selection = typeof host.getSelectionModel === "function" ? (_ref4 = host.getSelectionModel()) != null ? _ref4.getSelection() : void 0 : void 0;
      if (selection.length > 0) {
        valueItems = props.items;
        valueItems.forEach(function(i) {
          return i.selected = false;
        });
        for (_i = 0, _len = selection.length; _i < _len; _i++) {
          item = selection[_i];
          if (valueItems.length > 0) {
            if (host.store.isGrouped) {
              valueItems[item.data.__index].selected = true;
            } else {
              valueItems[item.index].selected = true;
            }
          }
          postData.items = valueItems;
        }
      }
    }
    processMenuResponse = function(menuObj, ev, uipath) {
      var options;
      if (menuObj.messageType) {
        me.showSessionTimeoutMsgBox(menuObj);
        return;
      }
      options = {
        menutype: 'context',
        contextOwner: insideObj,
        component: comp,
        record: record
      };
      me.createMenuItems(menuObj, ev, options);
    };
    rq.sendRequest5(url, processMenuResponse, uipath, postData, void 0, void 0, void 0, e);
    e.stopEvent();
  },
  showSessionTimeoutMsgBox: function(menuObj) {
    var ch, key, msgCache, oneCache;
    ch = Corefw.util.Cache;
    msgCache = ch.parseJsonToCache(menuObj);
    for (key in msgCache) {
      oneCache = msgCache[key];
      Ext.create('Corefw.view.MessageBox', {
        cache: oneCache
      });
    }
  },
  addOffset: function(args) {
    var location, me;
    me = args;
    location = [10, 10];
    if (me[0]) {
      location[0] = me[0] + 10;
    }
    if (me[1]) {
      location[1] = me[1] + 10;
    }
    return location;
  },
  createMenuItems: function(menuCache, domEvent, options) {
    var items, menuArray, menuitem, su, tempMenuConfig, tempmenu, _i, _j, _len, _len1, _ref, _ref1;
    su = Corefw.util.Startup;
    if (!menuCache.visible) {
      domEvent.stopEvent();
      return;
    }
    items = [];
    tempMenuConfig = {
      items: items,
      menutype: 'popup'
    };
    menuArray = menuCache._ar;
    if (!menuArray) {
      menuArray = [];
      if (menuCache.allContents) {
        _ref = menuCache.allContents;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          menuitem = _ref[_i];
          menuArray.push(menuitem);
        }
      }
      if (menuCache.allNavigations) {
        _ref1 = menuCache.allNavigations;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          menuitem = _ref1[_j];
          menuArray.push(menuitem);
        }
      }
    }
    if (menuArray && menuArray.length) {
      this.createMenuItemsWorker(menuArray, items, options);
    }
    if (su.getThemeVersion() === 2) {
      tempMenuConfig.showSeparator = false;
      tempMenuConfig.cls = 'menuNoIcon';
    }
    tempmenu = Ext.create('Ext.menu.Menu', tempMenuConfig);
    tempmenu.showAt(this.addOffset(domEvent.getXY()));
    domEvent.stopEvent();
  },
  createMenuItemsWorker: function(menuArray, menuParent, options) {
    var evt, index, lastIndex, menuItemCache, menuitem, newAr, nextMenuArray, nextmenuitem, props, sep, su, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2;
    su = Corefw.util.Startup;
    evt = Corefw.util.Event;
    for (_i = 0, _len = menuArray.length; _i < _len; _i++) {
      menuItemCache = menuArray[_i];
      if (!menuItemCache.group) {
        menuItemCache.group = {
          index: -1
        };
      }
    }
    menuArray.sort(function(item0, item1) {
      return item0.group.index - item1.group.index;
    });
    if (menuArray.length) {
      lastIndex = menuArray[menuArray.length - 1].group.index;
      for (index = _j = _ref = menuArray.length - 1; _j >= 0; index = _j += -1) {
        if (menuArray[index].group.index !== lastIndex) {
          lastIndex = menuArray[index].group.index;
          sep = {
            xtype: 'menuseparator'
          };
          if (su.getThemeVersion() === 2) {
            sep.margin = '0 6 0 6';
          }
          menuArray.splice(index + 1, 0, sep);
        }
      }
    }
    for (_k = 0, _len1 = menuArray.length; _k < _len1; _k++) {
      menuItemCache = menuArray[_k];
      menuitem = {};
      props = menuItemCache._myProperties;
      if (!props) {
        props = menuItemCache;
      }
      if (menuItemCache.xtype === 'menuseparator') {
        menuParent.push(menuItemCache);
        continue;
      }
      menuitem.text = props.title;
      menuitem.name = props.name;
      menuitem.tooltip = props.toolTip;
      menuitem.hidden = !props.visible;
      menuitem.disabled = !props.enabled;
      menuitem.cache = menuItemCache;
      menuitem.uipath = menuItemCache.uipath;
      evt.addEvents(props, 'menu', menuitem);
      if (options) {
        if (options.menutype === 'context') {
          menuitem.coretype = 'contextmenubutton';
          menuitem.contextOwner = options.contextOwner;
          menuitem.record = options.record;
          menuitem.component = options.component;
        } else if (options.menutype === 'nav') {
          menuitem.coretype = 'navmenuitembutton';
          menuitem.parentCache = options.parentCache;
        }
      }
      nextMenuArray = menuItemCache._ar;
      if (!nextMenuArray) {
        nextMenuArray = [];
        if (menuItemCache.allContents) {
          _ref1 = menuItemCache.allContents;
          for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
            nextmenuitem = _ref1[_l];
            nextMenuArray.push(nextmenuitem);
          }
        }
        if (menuItemCache.allNavigations) {
          _ref2 = menuItemCache.allNavigations;
          for (_m = 0, _len3 = _ref2.length; _m < _len3; _m++) {
            nextmenuitem = _ref2[_m];
            nextMenuArray.push(nextmenuitem);
          }
        }
      }
      if (nextMenuArray && nextMenuArray.length) {
        newAr = [];
        menuitem.menu = {
          items: newAr
        };
        menuitem.cls = 'hasSubMenu';
        if (su.getThemeVersion() === 2) {
          menuitem.menu.showSeparator = false;
          menuitem.menu.cls += ' menuNoIcon';
        }
        menuParent.push(menuitem);
        this.createMenuItemsWorker(nextMenuArray, newAr, options);
      } else {
        menuParent.push(menuitem);
      }
    }
  },
  onNavMenuClick: function(button, ev) {
    var options, toolbarUipath, uip, uipathParentCache, _ref, _ref1;
    uip = Corefw.util.Uipath;
    toolbarUipath = uip.uipathToParentUipath(button.uipath);
    uipathParentCache = uip.uipathToParentCacheItem(toolbarUipath);
    if (!uipathParentCache) {
      uipathParentCache = uip.uipathToParentCacheItem(button.uipath);
    }
    options = {
      menutype: 'nav',
      parentCache: uipathParentCache
    };
    this.createMenuItems(button != null ? (_ref = button.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.menu : void 0 : void 0 : void 0, ev, options);
  }
});
