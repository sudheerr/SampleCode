// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.controller.Grid', {
  extend: 'Ext.app.Controller',
  init: function() {
    this.control({
      'grid[coretype=field]': {
        afterlayout: this.afterGridLayout
      },
      'gridview': {
        viewready: this.onGridViewReady
      },
      'treeview': {
        viewready: this.onTreeViewReady,
        resize: this.onTreeViewResized,
        afteritemexpand: this.onTreeAfterItemExpand,
        afteritemcollapse: this.onTreeAfterItemCollapse,
        beforecellclick: this.onRadioBeforeCellClick
      },
      'menuitem[menuoperation=addsort]': {
        click: this.onColumnMenuAddSortClick
      },
      'coreobjectgrid>grid': {
        select: this.onGridItemSelect,
        deselect: this.onGridItemDeselect,
        cellclick: this.onGridCellClick,
        columnresize: this.onGridColumnResizeEvent,
        beforeselect: this.onGridRowBeforeSelectOrDeselect,
        beforedeselect: this.onGridRowBeforeSelectOrDeselect,
        selectall: this.processGridEvent,
        deselectall: this.processGridEvent
      },
      'coreobjectgrid gridview': {
        itemdblclick: this.onItemDoubleClick
      },
      'coregridintreenode': {
        cellclick: this.onTreeNodeCellClick
      },
      'coretreegrid treepanel': {
        beforeselect: this.onGridRowBeforeSelectOrDeselect,
        beforedeselect: this.onGridRowBeforeSelectOrDeselect,
        select: this.onGridItemSelect,
        deselect: this.onGridItemDeselect,
        cellclick: this.onTreeGridCellClick,
        itemdblclick: this.onItemDoubleClick,
        edit: this.onTreeGridEdit,
        afterlayout: this.onTreeGridAfterlayout,
        columnresize: this.onTreeGridColumnResizeEvent
      },
      'checkcolumn': {
        beforecheckchange: this.onEditableCheckbox,
        checkchange: this.onCheckColumnChange
      },
      'checkbox[columnONCHANGEevent]': {
        change: this.onEditorCheckboxChange
      },
      'checkbox[columnONCHECKCHANGEevent]': {
        change: this.onEditorCheckboxCheckChange
      },
      'textfield[columnONCHANGEevent]': {
        change: this.onTextfieldChange
      },
      'textfield[columnONBLURevent]': {
        blur: this.onTextfieldBlur
      },
      'combobox[columnONLOOKUPevent]': {
        focus: this.onComboBoxFocusLookup,
        change: this.onComboBoxChangeLookup,
        beforeselect: this.toogleComboBoxChangeEvent,
        select: this.toogleComboBoxChangeEvent
      },
      'combobox[columnONSELECTevent]': {
        select: this.onComboBoxSelect
      },
      'corehierarchygridnode': {
        itemclick: this.onHierarchyGridNodeRowClick
      },
      'roweditor combobox': {
        focus: this.initComboboxLookUpState
      },
      'gridcolumn': {
        hide: this.onGridColumnHideOrShow,
        show: this.onGridColumnHideOrShow
      }
    });
    this.initinalGridSelectedChangeTask();
  },
  onRadioBeforeCellClick: function(view, td, cellIndex, record) {
    var childLeaf, childNode, childNodes, data, disabled, parentNode, _i, _len;
    if (view.xtype === 'treeradioview') {
      childLeaf = record.childNodes;
      disabled = record.raw.disabled;
      if (childLeaf.length) {
        return;
      } else {
        parentNode = record.parentNode;
        childNodes = parentNode.childNodes;
        if (disabled) {
          return;
        }
        for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
          childNode = childNodes[_i];
          data = childNode.data;
          childNode.set('checked', false);
        }
      }
    }
  },
  onGridRowBeforeSelectOrDeselect: function(grid, record, index, eOpts) {
    var _ref, _ref1;
    if ((record != null ? (_ref = record.raw) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.selectable : void 0 : void 0 : void 0) === false) {
      return false;
    }
    return true;
  },
  onTreeAfterItemExpand: function(treeitem) {
    var treeview;
    treeview = treeitem.getOwnerTree().view;
    this.onTreeViewResized(treeview);
  },
  onTreeAfterItemCollapse: function(treeitem) {
    var treeview;
    treeview = treeitem.getOwnerTree().view;
    this.onTreeViewResized(treeview);
  },
  onTreeViewResized: function(view) {
    var column, columns, props, su, tempwidth, tree, treebase, _ref;
    treebase = view.up("coretreebase");
    tree = view.up();
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2 && tree) {
      props = (_ref = tree.cache) != null ? _ref._myProperties : void 0;
      columns = tree.columns;
      tempwidth = tree.getWidth();
      if (tempwidth > 0) {
        if (props && props.titleBackgroundIsWhite && columns) {
          if (columns.length === 1) {
            column = tree.columns[0];
            column.setWidth(tempwidth);
          }
        }
      }
    }
    if (!treebase) {
      return;
    }
  },
  onTreeViewReady: function(view) {
    var cm, isStackedLayout, _ref, _ref1;
    isStackedLayout = ((_ref = view.up('form')) != null ? (_ref1 = _ref.layoutManager) != null ? _ref1.type : void 0 : void 0) === 'vbox';
    cm = Corefw.util.Common;
    if (isStackedLayout) {
      cm.setMaxAndMinHeight(view.up('fieldcontainer'));
    }
  },
  restoreScrollBar: function(view) {
    var baseView, iv, leftOffset, normalLeftOffset, uipath, _ref;
    iv = Corefw.util.InternalVar;
    baseView = view.up("coregridbase").getView();
    uipath = (_ref = view.up('coreobjectgrid')) != null ? _ref.uipath : void 0;
    if (uipath === void 0) {
      return;
    }
    if (baseView.normalView) {
      normalLeftOffset = iv.getByUipathProperty(uipath, 'gridscroll_normal_left');
      baseView.normalView.el.scroll('l', normalLeftOffset, false);
      iv.deleteUipathProperty(uipath, 'gridscroll_normal_left');
    } else {
      leftOffset = iv.getByUipathProperty(uipath, 'gridscroll_left');
      baseView.el.scroll('l', leftOffset, false);
      iv.deleteUipathProperty(uipath, 'gridscroll_left');
    }
  },
  onGridViewReady: function(view) {
    var scrollLeft;
    if (view.getWidth() > 3000) {
      return;
    }
    this.applyGridStyle(view.up());
    if (!view.up("coregridbase")) {
      return;
    }
    if (view.up("grid[isLocked=true]")) {
      return;
    }
    view.isReady = true;
    if (view.el && view.el.dom) {
      scrollLeft = view.el.dom.scrollLeft;
      if (scrollLeft > 0) {
        if (scrollLeft > 10) {
          view.el.dom.scrollLeft = scrollLeft - 5;
        } else {
          view.el.dom.scrollLeft = scrollLeft + 1;
        }
        view.el.dom.scrollLeft = scrollLeft;
      }
      this.restoreScrollBar(view);
    }
  },
  toogleComboBoxChangeEvent: function(comp) {
    comp.disableChangeEvent = !comp.disableChangeEvent;
  },
  onGridColumnResizeEvent: function(comp, column, width, eOpts) {
    var _ref, _ref1;
    if (column.width) {
      if ((_ref = column.cache) != null) {
        if ((_ref1 = _ref._myProperties) != null) {
          _ref1.width = width;
        }
      }
    }
  },
  onTreeGridColumnResizeEvent: function(comp, column, width, eOpts) {
    var addlConfig, columns, createToolTip, createTooltipOncell, delayToolTips, grid, loopCells, nodes, su, view;
    grid = comp.up();
    view = grid.view;
    columns = grid.columns;
    su = Corefw.util.Startup;
    delayToolTips = su.getStartupObj().delayTooltips === true;
    nodes = view.getNodes();
    loopCells = this.loopCells;
    createTooltipOncell = this.createTooltipOncell;
    createToolTip = this.createToolTip;
    if (delayToolTips) {
      addlConfig = {
        hideDelay: 1200,
        listeners: {
          click: {
            element: 'el',
            fn: function(el, d) {
              Ext.getCmp(this.id).showAt(this.getXY());
            }
          }
        }
      };
    }
    Ext.each(nodes, function(row, rowIndex) {
      var node;
      node = Ext.get(row);
      loopCells(view, node, columns, function(col, cell) {
        cell.on({
          mouseenter: function() {
            createTooltipOncell(col, cell, "celltooltip", createToolTip, addlConfig);
          }
        });
      });
    });
  },
  loopCells: function(view, row, columns, processor) {
    var cell, column, _i, _len;
    for (_i = 0, _len = columns.length; _i < _len; _i++) {
      column = columns[_i];
      if (!view.getNode(row, true)) {
        continue;
      }
      cell = view.getCell(row, column);
      if (cell) {
        if (typeof processor === "function") {
          processor(column, cell);
        }
      }
    }
  },
  createTooltipOncell: function(column, cell, tooltipValueObj, createTooltipFn, addlConfig) {
    var cellValue, columnWidth, newMetrics, rawTip, tooltip;
    tooltip = cell.dom.innerHTML;
    rawTip = cell.dom.textContent;
    newMetrics = new Ext.util.TextMetrics();
    cellValue = ((newMetrics.getSize(rawTip).width) + 2) || 0;
    columnWidth = column.getEl().getWidth();
    cell.isTooltipCreated = cell.isTooltipCreated || false;
    if (cell && cell.isTooltipCreated === false && !Ext.isEmpty(tooltip)) {
      if (columnWidth < cellValue) {
        createTooltipFn(cell, rawTip, addlConfig);
        cell.isTooltipCreated = true;
      }
    }
  },
  createToolTip: function(target, html, addlConfig) {
    var config;
    config = {
      target: target,
      html: html
    };
    if (addlConfig) {
      Ext.apply(config, addlConfig);
    }
    Ext.create('Ext.tip.ToolTip', config);
  },
  gridSelectChangeTask: null,
  initinalGridSelectedChangeTask: function() {
    this.gridSelectChangeTask = new Ext.util.DelayedTask(this.processGridSelectedChangeEvent, this);
  },
  processGridSelectedChangeEvent: function(grid, eventType, record) {
    this.processGridEvent(grid, eventType, record);
  },
  onGridItemSelect: function(model, record) {
    var grid, gridview;
    gridview = model.view;
    grid = gridview.up("coretreegrid, coreobjectgrid");
    if (!grid || !grid.enableSelectEvent) {
      return;
    }
    this.gridSelectChangeTask.delay(300, null, null, [grid, 'ONSELECT', record]);
  },
  onGridItemDeselect: function(model, record) {
    var grid, gridview;
    gridview = model.view;
    grid = gridview.up("coretreegrid, coreobjectgrid");
    if (!grid || !grid.enableSelectEvent) {
      return;
    }
    this.gridSelectChangeTask.delay(300, null, null, [grid, 'ONDESELECT', record]);
  },
  onItemDoubleClick: function(gridview, record) {
    var editableGrid, grid, gridProps, _ref, _ref1;
    if (((_ref = record.raw) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.selectable : void 0 : void 0) === false) {
      return;
    }
    grid = gridview.up("coretreegrid, coreobjectgrid");
    if (!grid) {
      return;
    }
    gridProps = grid.cache._myProperties;
    editableGrid = gridProps.editableColumns;
    if (editableGrid) {
      return;
    }
    this.processGridEvent(grid, 'ONDOUBLECLICK', record);
  },
  processGridEvent: function(gridfield, eventType, record) {
    var editorHost, eventURL, gridEvent, postData, rq, uipath, _ref;
    editorHost = gridfield.grid || gridfield.tree;
    editorHost.ctrl = this;
    gridEvent = (_ref = gridfield.eventURLs) != null ? _ref[eventType] : void 0;
    if (!gridEvent || editorHost.isEditing || document.body.querySelector('.x-grid-dd-wrap')) {
      return;
    }
    if (editorHost.stopFireEvents) {
      editorHost.stopFireEvents = false;
      return;
    }
    uipath = gridfield.uipath;
    rq = Corefw.util.Request;
    eventURL = rq.objsToUrl3(gridEvent);
    uipath = gridfield.uipath;
    record.isEditing = true;
    gridfield.valueChanged = true;
    postData = gridfield.generatePostData();
    rq.sendRequest5(eventURL, rq.processResponseObject, uipath, postData);
    record.isEditing = false;
  },
  initComboboxLookUpState: function(combobox) {
    combobox.isNotFirstLookUp = false;
  },
  onHierarchyGridNodeRowClick: function(gridview, record, item, index, e, eOpts) {
    var event, eventURL, hierarchyGridNode, hierarchyGridView, postData, props, rq, uipath, url, _ref;
    rq = Corefw.util.Request;
    hierarchyGridNode = gridview.up('grid');
    hierarchyGridView = hierarchyGridNode.up('[coretype=field]');
    if (!hierarchyGridView) {
      return;
    }
    props = (_ref = hierarchyGridView.cache) != null ? _ref._myProperties : void 0;
    if (!props) {
      return;
    }
    event = props.events['ONROWCLICK'];
    eventURL = event.url;
    if (!eventURL) {
      return;
    }
    url = rq.objsToUrl3(eventURL);
    uipath = hierarchyGridView.uipath;
    postData = hierarchyGridView.generatePostData(hierarchyGridNode.expandedRowIndex, record);
    rq.sendRequest5(url, rq.processResponseObject, uipath, postData, void 0, void 0, void 0, e);
  },
  onGridCellClick: function(gridview, td, cellIndex, record, tr, rowIndex, e, eOpts) {
    var comp;
    comp = gridview.up('coreobjectgrid');
    this.processCellClick(gridview, cellIndex, record, e, comp);
  },
  onTreeNodeCellClick: function(gridview, td, cellIndex, record, tr, rowIndex, e, eOpts) {
    var comp;
    comp = gridview.up('grid');
    this.processCellClick(gridview, cellIndex, record, e, comp);
  },
  onTreeGridCellClick: function(gridview, td, cellIndex, record, tr, rowIndex, e, eOpts) {
    var comp, currentTime, milliDelay, _ref;
    console.log('onTreeGridCellClick----------------------------------------------');
    milliDelay = 300;
    currentTime = Date.now();
    comp = gridview.up('coretreegrid');
    if (this.lastCellClickProcessTime) {
      if (currentTime - this.lastCellClickProcessTime < milliDelay) {
        if ((_ref = comp.tree) != null) {
          _ref.stopOpeningEditor = false;
        }
        return;
      }
    }
    this.lastCellClickProcessTime = currentTime;
    this.processCellClick(gridview, cellIndex, record, e, comp);
  },
  isStopProcessing: function(gridview, columnProps, record) {
    var disabledHeaders, enabledHeaders, grid, gridProps, index, isStop, pathString, rowCache, _i, _j, _len, _len1;
    rowCache = null;
    index = record.raw.__index;
    if (gridview.xtype === 'gridview') {
      grid = gridview.up('coreobjectgrid');
      gridProps = grid.cache._myProperties;
      if (grid.xtype === 'corercgrid') {
        rowCache = gridProps.rows[index];
      } else {
        rowCache = gridProps.items[index];
      }
    } else {
      grid = gridview.up('coretreegrid');
      gridProps = grid.cache._myProperties;
      grid.tree.traverseNodes(gridProps.allTopLevelNodes, 'children', function(n) {
        if (n.index === index) {
          return rowCache = n;
        }
      });
    }
    if (!rowCache) {
      return;
    }
    disabledHeaders = (rowCache != null ? rowCache.disabledHeaders : void 0) || [];
    enabledHeaders = (rowCache != null ? rowCache.enabledHeaders : void 0) || [];
    isStop = false;
    if (columnProps.enabled) {
      for (_i = 0, _len = disabledHeaders.length; _i < _len; _i++) {
        pathString = disabledHeaders[_i];
        if (columnProps.pathString === pathString) {
          isStop = true;
          break;
        }
      }
    } else {
      isStop = true;
      for (_j = 0, _len1 = enabledHeaders.length; _j < _len1; _j++) {
        pathString = enabledHeaders[_j];
        if (columnProps.pathString === pathString) {
          isStop = false;
          break;
        }
      }
    }
    return isStop;
  },
  processCellClick: function(gridview, cellIndex, record, e, comp) {
    var columnType, eventURL, eventURLs, perspectiveWindowOfTriggerEvent, postData, props, rq, uc, uipath, url, _ref, _ref1, _ref2;
    rq = Corefw.util.Request;
    props = (_ref = gridview.getGridColumns()[cellIndex]) != null ? (_ref1 = _ref.cache) != null ? _ref1._myProperties : void 0 : void 0;
    if (!props) {
      return;
    }
    columnType = (_ref2 = props.columnType) != null ? _ref2.toLowerCase() : void 0;
    if ((columnType === 'link' && e.target.tagName.toLowerCase() === 'a') || (columnType === 'icon' && e.target.tagName.toLowerCase() === 'div')) {
      eventURLs = props.eventURLs;
      if (!eventURLs || this.isStopProcessing(gridview, props, record)) {
        return;
      }
      if (eventURLs.ONCLICK) {
        eventURL = eventURLs.ONCLICK;
        url = rq.objsToUrl3(eventURL);
        comp.forcedSelectedRecord = record;
        postData = comp.generatePostData();
        delete comp.forcedSelectedRecord;
        uipath = comp.uipath;
        perspectiveWindowOfTriggerEvent = comp.up('coreperspectivewindow');
        if (e.ctrlKey) {
          rq.sendRequest5(url, void 0, uipath, postData, void 0, void 0, void 0, e);
          return;
        }
        if (perspectiveWindowOfTriggerEvent) {
          rq.sendRequest5(url, perspectiveWindowOfTriggerEvent.processResponseObject, uipath, postData, void 0, void 0, perspectiveWindowOfTriggerEvent, e);
        } else {
          rq.sendRequest5(url, rq.processResponseObject, uipath, postData, void 0, void 0, void 0, e);
        }
      }
      if (eventURLs.ONDOWNLOAD) {
        uc = Corefw.util.Common;
        eventURL = eventURLs.ONDOWNLOAD;
        url = rq.objsToUrl3(eventURL);
        comp.forcedSelectedRecord = record;
        uc.download(comp, url);
        console.log('Returned After download');
        delete comp.forcedSelectedRecord;
      }
      if (eventURLs.ONREDIRECT) {
        uc = Corefw.util.Common;
        eventURL = eventURLs.ONREDIRECT;
        url = rq.objsToUrl3(eventURL);
        comp.forcedSelectedRecord = record;
        uc.redirect(comp, url);
        console.log('Returned After redirect');
        delete comp.forcedSelectedRecord;
      }
    }
  },
  onTreeGridEdit: function(evt, cell) {
    var _base;
    if (typeof (_base = cell.grid).styleDecorate === "function") {
      _base.styleDecorate();
    }
  },
  onTreeGridAfterlayout: function(tree) {
    var treeGrid;
    if (tree && tree.styleDecorate) {
      tree.styleDecorate();
    } else {
      treeGrid = tree.up('panel');
      if (treeGrid && treeGrid.styleDecorate) {
        treeGrid.styleDecorate();
      }
    }
  },
  afterGridLayout: function(grid) {
    var feature;
    if (grid.features && grid.features.length) {
      feature = grid.features[0];
      if (feature.ftype === 'coregroupingsummary') {
        this.applyGridStyle(grid);
      }
    }
  },
  applyGridStyle: function(grid) {
    var coregrid, myFunc, uipath;
    coregrid = grid.up('coretreegrid, coreobjectgrid');
    if (!coregrid) {
      return;
    }
    uipath = coregrid.uipath;
    if (uipath) {
      myFunc = Ext.Function.createBuffered(function() {
        coregrid = Ext.ComponentQuery.query('[uipath=' + uipath + ']')[0];
        if (coregrid) {
          grid = coregrid.down();
          if (typeof grid.styleDecorate === "function") {
            grid.styleDecorate();
          }
        }
      }, 400);
      myFunc();
    }
  },
  onColumnMenuAddSortClick: function(menuitem, event) {
    var grid, gridcolumn, newSorter, store;
    gridcolumn = menuitem.up('gridcolumn');
    grid = menuitem.up('grid');
    store = grid.store;
    newSorter = Ext.create('Ext.util.Sorter', {
      property: gridcolumn.dataIndex,
      direction: 'ASC',
      root: 'data'
    });
    store.sorters.add(newSorter);
    store.sort();
  },
  onTextfieldChange: function(comp, newValue, oldValue) {
    this.fireGridEvent(comp, 'ONCHANGE', true);
  },
  onTextfieldBlur: function(comp, evt) {
    this.fireGridEvent(comp, 'ONBLUR', true, null, null, evt);
  },
  onEditableCheckbox: function(column, rowIdx, checked, eOpts) {
    var cache, el, props, _ref, _ref1;
    cache = column.cache;
    if (cache) {
      props = cache._myProperties;
      if (props) {
        if (props.editable) {
          if (el = (_ref = column.ownerCt) != null ? (_ref1 = _ref.grid.view.getCell(rowIdx, column)) != null ? _ref1.el : void 0 : void 0) {
            if (el.hasCls('x-item-disabled')) {
              return false;
            }
          }
        } else {
          return false;
        }
      }
    }
    return true;
  },
  onCheckColumnChange: function(comp, index) {
    var gridStore, item, items, record, view, _base, _i, _len, _ref;
    view = typeof (_base = comp.up('panel')).getView === "function" ? _base.getView() : void 0;
    if (view) {
      gridStore = view != null ? view.getStore() : void 0;
      items = gridStore != null ? (_ref = gridStore.data) != null ? _ref.items : void 0 : void 0;
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        item.isEditing = false;
      }
      record = gridStore.getAt(index);
      record.isEditing = true;
      this.fireGridEvent(comp, 'ONCHANGE', false, null, true);
      this.fireGridEvent(comp, 'ONCHECKCHANGE', false, null, true);
      record.isEditing = false;
    }
  },
  onEditorCheckboxChange: function(comp) {
    this.fireGridEvent(comp, 'ONCHANGE', true);
  },
  onEditorCheckboxCheckChange: function(comp) {
    this.fireGridEvent(comp, 'ONCHECKCHANGE', true);
  },
  onComboBoxSelect: function(comp, records) {
    this.fireGridEvent(comp, 'ONSELECT', true);
  },
  onComboBoxChangeLookup: function(comp, newValue, oldValue) {
    if (comp.disableChangeEvent) {
      return;
    }
    this.onComboBoxLookup(comp, false, newValue, oldValue);
  },
  onComboBoxFocusLookup: function(comp) {
    this.onComboBoxLookup(comp, true);
  },
  onComboBoxLookup: function(comp, delay, newValue, oldValue) {
    var comboLookupService, delayLookup, me;
    me = this;
    if (comp && comp.xtype === 'roweditorgridpicker') {
      return;
    }
    comboLookupService = function() {
      var comboExpand, gridComboCallback;
      gridComboCallback = function(respObj, ev, uipath) {
        var name, st;
        if (respObj == null) {
          respObj = [];
        }
        name = uipath + '_' + comp.name;
        st = Corefw.util.Data.arrayToStore(name, 'gridComboCallback' + comp.id, respObj, comp);
        if (st) {
          comp.bindStore(st);
        }
        if (delay) {
          Ext.Function.createDelayed(comboExpand, 200)();
        } else {
          comboExpand();
        }
      };
      comboExpand = function() {
        var node, store, _ref;
        comp.expand();
        store = comp.getStore();
        node = store ? comp.findRecordByValue(comp.getValue()) : null;
        if (node) {
          if ((_ref = comp.picker) != null) {
            _ref.focusNode(node);
          }
        }
      };
      me.fireGridEvent(comp, 'ONLOOKUP', true, gridComboCallback);
    };
    if (delay) {
      delayLookup = Ext.Function.createDelayed(comboLookupService, 1);
      delayLookup();
    } else {
      comboLookupService();
    }
  },
  onGridColumnHideOrShow: function(column) {
    var eventURL, events, fieldContainer, grid, postData, _ref, _ref1;
    grid = column.up('coregridbase') || column.up('coretreebase');
    if (grid.suspendHidingEvent) {
      return;
    }
    fieldContainer = grid.ownerCt;
    if (column.isGroupHeader) {
      column.items.items.forEach(function(c) {
        return c.cache._myProperties.visible = c.isVisible();
      });
    } else {
      column.cache._myProperties.visible = column.isVisible();
    }
    fieldContainer.cache = grid.cache;
    events = ((_ref = fieldContainer.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.events : void 0 : void 0) || {};
    eventURL = events['ONCOLUMNSTATECHANGE'];
    if (eventURL) {
      postData = fieldContainer.generatePostData();
      if (typeof grid.remoteLoadStoreData === "function") {
        grid.remoteLoadStoreData(postData, {
          event: 'ONCOLUMNSTATECHANGE'
        });
      }
      if (grid.xtype === 'coretreebase') {
        Ext.ComponentQuery.query('menu[activeHeader]').forEach(function(m) {
          return m.destroy();
        });
      }
    }
  },
  fireGridEvent: function(comp, evtType, forcedUpdateRec, callback, isNotEditor, evt) {
    var callbackMethod, cm, colIndex, errMsg, eventURL, field, fieldId, iv, lookUpString, method, parent, parentField, postData, rq, source, sourceProps, tar, uipath, url, val, _ref, _ref1, _ref2;
    if (((typeof comp.up === "function" ? comp.up('roweditor') : void 0) != null) && (callback === null || typeof callback === 'undefined')) {
      return;
    }
    cm = Corefw.util.Common;
    rq = Corefw.util.Request;
    iv = Corefw.util.InternalVar;
    parent = comp.up('grid') || comp.up('treepanel');
    if (evt) {
      tar = evt.relatedTarget || evt.target || evt.currentTarget;
      if (tar && tar.id) {
        fieldId = (_ref = Ext.get(tar.id).up('.x-field')) != null ? _ref.id : void 0;
        if (fieldId) {
          field = Ext.getCmp(fieldId);
          colIndex = field != null ? field.column.getIndex() : void 0;
        }
      }
    }
    source = isNotEditor ? comp : comp.column;
    sourceProps = (_ref1 = source.cache) != null ? _ref1._myProperties : void 0;
    eventURL = sourceProps != null ? (_ref2 = sourceProps.eventURLs) != null ? _ref2[evtType] : void 0 : void 0;
    if (!eventURL) {
      return;
    }
    if (!isNotEditor) {
      uipath = parent.cache._myProperties.uipath + '/' + sourceProps.name;
      val = comp.getValue();
      if (comp.xtype === 'datefield' && val) {
        val = val.valueOf();
      }
      parent['editingCell'] = {
        uipath: uipath,
        val: val,
        disp: comp.getRawValue()
      };
    }
    parentField = parent.up('fieldcontainer');
    uipath = parentField.uipath;
    if (evtType === 'ONLOOKUP') {
      if (Corefw.util.InternalVar.getByNameProperty('roweditor', 'suspendChangeEvents')) {
        return;
      }
      postData = null;
      if (!comp.isNotFirstLookUp) {
        comp.isNotFirstLookUp = true;
        lookUpString = "";
      } else {
        lookUpString = comp.getRawValue();
      }
      url = rq.objsToUrl3(eventURL, null, lookUpString);
    } else {
      postData = parentField.generatePostData();
      url = rq.objsToUrl3(eventURL);
    }
    errMsg = 'Did not receive a valid response for the combobox';
    method = 'POST';
    callbackMethod = callback ? callback : rq.processResponseObject;
    rq.sendRequest5(url, callbackMethod, uipath, postData, errMsg, method);
  }
});
