// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.form.CompositeElement', {
  extend: 'CitiRiskLibrary.view.CitiRiskFormPanel',
  xtype: 'corecompositeelement',
  navAlign: 'left',
  suppressClosing: true,
  initComponent: function() {
    var cache, config, contentDefs, eachitem, eachitemcache, eachitemprops, elementCss, evt, headerCft, layout, me, props, su, titleEl, _i, _len, _ref, _ref1;
    me = this;
    evt = Corefw.util.Event;
    su = Corefw.util.Startup;
    layout = Corefw.view.layout.Layout;
    me.layoutManager = layout.create(me);
    cache = me.cache;
    props = cache._myProperties;
    contentDefs = me.genContentDefs();
    config = {
      coretype: 'element',
      uipath: props.uipath,
      disabled: !props.enabled,
      contentDefs: contentDefs,
      overflowY: 'auto',
      collapsible: props.collapsible,
      hidden: !props.visible,
      collapsed: !props.expanded,
      closable: false,
      title: props.title,
      secondTitle: props.secondTitle,
      titleCollapse: true,
      hideCollapseTool: true,
      style: {
        border: 'none'
      },
      bodyStyle: {
        border: 'none'
      }
    };
    if (su.getThemeVersion() === 2) {
      this.navAlign = 'right';
      if (this.isChildWithHeader(cache)) {
        me.addCls('element-child-with-header');
      }
      if (props.name === 'treeElement') {
        config.bodyStyle = 'background-color: #53565A; border: none';
        config.cls = 'treeselementcls';
        contentDefs = config.contentDefs;
        for (_i = 0, _len = contentDefs.length; _i < _len; _i++) {
          eachitem = contentDefs[_i];
          eachitemcache = eachitem.cache;
          if (eachitemcache.tree) {
            eachitemprops = eachitemcache.tree._myProperties;
            eachitemprops.treesinelement = 'treesinelement';
          }
        }
      }
    }
    if ((!config.title && Ext.isEmpty(props != null ? props.toolbar : void 0)) || (su.getThemeVersion() === 2 && (props != null ? (_ref = props.layout) != null ? _ref.type.toLowerCase() : void 0 : void 0) === 'tab')) {
      config.header = false;
      config.collapsed = false;
      me.addCls('element-without-header');
    } else if (su.getThemeVersion() === 2 && (props != null ? (_ref1 = props.layout) != null ? _ref1.type.toLowerCase() : void 0 : void 0) === 'tab') {
      me.addCls('compEl-tab-header');
    } else {
      config.title = config.title;
      config.header = config.header || {};
      me.addCls('element-with-header');
      titleEl = {
        autoEl: {
          'data-qtip': props.toolTip
        }
      };
      Ext.apply(config.header, titleEl);
    }
    if (props.toolbar && !su.getThemeVersion()) {
      config.header = config.header || {};
      headerCft = {
        padding: '0 7 0 5',
        minHeight: 30
      };
      Ext.apply(config.header, headerCft);
    }
    if (config.collapsible && config.title && !su.getThemeVersion()) {
      config.title = '&nbsp;&nbsp;&nbsp;' + config.title;
    }
    if (props.closable) {
      config.closable = true;
    }
    elementCss = props.cssclass;
    if (elementCss) {
      me.addCls(elementCss);
    }
    evt.addEvents(props, 'compositeElement', config);
    Ext.apply(me, config);
    this.addListeners();
    this.callParent(arguments);
  },
  addListeners: function() {
    var additionalListeners;
    this.listeners = this.listeners || {};
    additionalListeners = {
      beforeexpand: this.beforePanelExpand,
      expand: this.afterPanelExpand,
      beforecollapse: this.beforePanelCollapse,
      close: this.onElementClose,
      beforedestroy: this.beforeElementDestroy
    };
    return Ext.apply(this.listeners, additionalListeners);
  },
  afterPanelExpand: function(compositeElement) {
    var element, elements, index, _i, _len, _ref;
    elements = compositeElement.query('coreelementform');
    if (!compositeElement.elementsResized) {
      for (index = _i = 0, _len = elements.length; _i < _len; index = ++_i) {
        element = elements[index];
        if ((_ref = element.layoutManager) != null) {
          if (typeof _ref.resize === "function") {
            _ref.resize();
          }
        }
      }
      compositeElement.elementsResized = true;
    }
  },
  beforePanelExpand: function() {
    if (this.collapsible) {
      this.removeCls('panelcolltxtclr');
      this.addCls('panelexptxtclr');
    }
  },
  beforePanelCollapse: function() {
    if (this.collapsible) {
      this.removeCls('panelexptxtclr');
      this.addCls('panelcolltxtclr');
    }
  },
  onElementClose: function() {
    this.suppressClosing = false;
  },
  beforeElementDestroy: function() {
    var rdr;
    rdr = Corefw.util.Render;
    rdr.destroyThisComponent(this);
  },
  onRender: function() {
    var evt, su;
    evt = Corefw.util.Event;
    su = Corefw.util.Startup;
    this.callParent(arguments);
    if (this.compositeElementONLOADevent || this.compositeElementONREFRESHevent) {
      evt.fireRenderEvent(this);
    }
    if (su.getThemeVersion() === 2) {
      if (this.title && this.collapsible) {
        if (this.collapsed) {
          this.addCls('panelcolltxtclr');
        } else {
          this.addCls('panelexptxtclr');
        }
      }
    }
  },
  generatePostData: function() {
    var contents, elemComp, elementPostData, elementsArray, postData, selector, _i, _len;
    elementsArray = [];
    postData = {
      name: this.cache._myProperties.name,
      allContents: elementsArray,
      expanded: !this.collapsed
    };
    selector = '> coreelementform, > corecompositeelement';
    if (this.layoutManager.type === 'tab') {
      selector = '>> coreelementform, >> corecompositeelement';
    }
    contents = this.query(selector);
    for (_i = 0, _len = contents.length; _i < _len; _i++) {
      elemComp = contents[_i];
      elementPostData = elemComp.generatePostData();
      elementsArray.push(elementPostData);
    }
    return postData;
  },
  afterRender: function() {
    var layoutManager, su;
    su = Corefw.util.Startup;
    layoutManager = this.layoutManager;
    if (!layoutManager.validate()) {
      return;
    }
    layoutManager.initLayout();
    this.callParent(arguments);
    Corefw.util.Render.renderNavs(this.cache._myProperties, this, null, null, this.navAlign);
    Corefw.util.Render.addSecondTitle(this);
  },
  isOncloseEventDisabled: function() {
    return this.suppressClosing;
  },
  genContentDefs: function() {
    var cache, contentCache, contentDef, contentDefs, contentKey, contentProps;
    cache = this.cache;
    contentDefs = [];
    for (contentKey in cache) {
      contentCache = cache[contentKey];
      contentProps = contentCache != null ? contentCache._myProperties : void 0;
      if (contentKey !== '_myProperties' && !(contentProps != null ? contentProps.isRemovedFromUI : void 0) && (contentProps != null ? contentProps.visible : void 0)) {
        contentDef = this.genContentDef(contentCache);
        if (contentDef) {
          contentDefs.push(contentDef);
        }
      }
    }
    return contentDefs;
  },
  genContentDef: function(contentCache) {
    var compType, compTypeMap, contentDef, props, widgetType;
    contentDef = {};
    props = contentCache._myProperties;
    if (!props) {
      return;
    }
    compTypeMap = {
      FORM_BASED_ELEMENT: 'coreelementform',
      BAR_ELEMENT: 'coreelementbar',
      COMPOSITE_ELEMENT: 'corecompositeelement'
    };
    widgetType = props.widgetType;
    compType = compTypeMap[widgetType];
    if (!compType) {
      return;
    }
    if (!props.title) {
      props.collapsible = false;
      props.expanded = true;
    }
    contentDef = {
      xtype: compType,
      cache: contentCache,
      uipath: props.uipath
    };
    return contentDef;
  },
  replaceChild: function(elementCache, ev, isAncestorUpdating) {
    var elemComp, elementDef, name, props, uip, uipath;
    uip = Corefw.util.Uipath;
    props = elementCache._myProperties;
    name = props.name;
    uipath = props.uipath;
    elemComp = uip.uipathToComponent(uipath);
    if (!elemComp && !props.visible) {
      return;
    }
    if (!isAncestorUpdating) {
      Ext.suspendLayouts();
    }
    this.cache[name] = elementCache;
    if (elemComp) {
      if (this.layoutManager.type === 'tab' && !props.visible || props.isRemovedFromUI) {
        this.layoutManager.remove(elemComp);
        if (!isAncestorUpdating) {
          Ext.resumeLayouts(true);
        }
        return;
      }
      elemComp.updateUIData(elementCache);
    } else {
      elementDef = this.genContentDef(elementCache);
      this.layoutManager.add(elementDef, void 0, isAncestorUpdating);
    }
    if (!isAncestorUpdating) {
      Ext.resumeLayouts(true);
    }
  },
  updateChild: function(elementCache) {
    this.replaceChild(elementCache, '', true);
  },
  updateUIData: function(compositeElementCache) {
    var bottomContainerArr, childCache, cm, coretype, evt, key, layoutManager, me, newContentDefs, previousActiveTabPath, props, targetActiveTabPath, _ref;
    me = this;
    cm = Corefw.util.Common;
    props = compositeElementCache._myProperties;
    layoutManager = me.layoutManager;
    cm.updateCommon(me, props);
    me.cache = compositeElementCache;
    newContentDefs = me.genContentDefs();
    layoutManager.updateContentDefs(newContentDefs);
    bottomContainerArr = Ext.ComponentQuery.query('container[bottomContainer=true]', this);
    if (bottomContainerArr) {
      Ext.Array.each(bottomContainerArr, function(bottomContainer) {
        if (bottomContainer.ownerCt === me) {
          me.remove(bottomContainer);
        }
      });
    }
    Corefw.util.Render.renderNavs(props, this, null, null, this.navAlign);
    me.elementsResized = false;
    if (!me.rendered) {
      return;
    }
    evt = Corefw.util.Event;
    if (this.compositeElementONREFRESHevent) {
      evt.fireRenderEvent(this);
    }
    if (layoutManager.type === 'tab') {
      previousActiveTabPath = layoutManager.getActiveTabPath();
    }
    for (key in compositeElementCache) {
      childCache = compositeElementCache[key];
      if (key === '_myProperties') {
        continue;
      }
      props = childCache._myProperties;
      coretype = props != null ? (_ref = props.coretype) != null ? _ref.toLowerCase() : void 0 : void 0;
      switch (coretype) {
        case 'element':
        case 'compositeelement':
          if (props.active) {
            targetActiveTabPath = props.uipath;
          }
          me.updateChild(childCache);
      }
    }
    if (layoutManager.type === 'tab') {
      if (previousActiveTabPath !== targetActiveTabPath) {
        layoutManager.setActiveTab(targetActiveTabPath);
      }
    }
  },
  isChildWithHeader: function(cache) {
    var contentCache, contentKey, contentProps, hasTitleBar;
    for (contentKey in cache) {
      contentCache = cache[contentKey];
      if (contentKey !== '_myProperties') {
        contentProps = contentCache._myProperties;
        switch (contentProps != null ? contentProps.widgetType : void 0) {
          case 'COMPOSITE_ELEMENT':
          case 'FORM_BASED_ELEMENT':
            if (!Ext.isEmpty(contentProps.title)) {
              hasTitleBar = true;
            }
            break;
          case 'PIVOTGRID':
            if (contentProps.showTitleBar === true) {
              hasTitleBar = true;
            }
        }
      }
    }
    return hasTitleBar;
  }
});
