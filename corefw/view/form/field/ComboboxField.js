// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.form.field.ComboboxField', {
  extend: 'Ext.form.field.ComboBox',
  mixins: ['Corefw.mixin.CoreField', 'Corefw.mixin.Maskable'],
  xtype: 'comboboxfield',
  forceSelection: false,
  checkChangeBuffer: 500,
  loadingMaskDelay: 1000,
  loadingMaskHideDelay: 0,
  statics: {
    isLookupable: function(props) {
      var event, events, _i, _len, _ref, _ref1;
      if ((props != null ? (_ref = props.eventURLs) != null ? _ref.ONLOOKUP : void 0 : void 0) || (props != null ? (_ref1 = props.events) != null ? _ref1.ONLOOKUP : void 0 : void 0)) {
        return true;
      }
      events = props != null ? props.events : void 0;
      if (events) {
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          event = events[_i];
          if (event.type === 'ONLOOKUP') {
            return true;
          }
        }
      }
      return false;
    },
    isEditable: function(props) {
      return !!(props != null ? props.lookupable : void 0);
    }
  },
  getLoadMaskTarget: function() {
    return this.getPicker();
  },
  listConfig: {
    resizeHandles: 'w sw ne se nw',
    emptyText: '<div class="x-boundlist-item">No matching found.</div>',
    resizable: {
      listeners: {
        beforeresize: function() {
          this.resizeTracker.maxHeight = 10000;
          this.target.maxHeight = 10000;
        },
        resize: function() {
          this.resizeTracker.maxHeight = 300;
          this.target.maxHeight = 300;
        }
      }
    },
    style: {
      whiteSpace: 'nowrap'
    },
    listeners: {
      beforerender: function() {
        var combo, pageSize;
        combo = this.up('comboboxfield') || this.pickerField;
        pageSize = combo.cache ? combo.cache._myProperties.pageSize : combo.pageSize;
        if (pageSize) {
          this.pageSize = pageSize;
          this.pagingToolbar = this.createPagingToolbar();
        }
      },
      refresh: function() {
        var cntDiv, combo, div, getStartHisRecord, hisNode, hisRecord, historyInfo, historyTitle, lookupable, separator, store;
        combo = this.up('comboboxfield') || this.pickerField;
        lookupable = combo.isLookupable();
        if (lookupable) {
          combo.highLightKeywords();
          store = this.getStore();
          if (store.isDestroyed) {
            return;
          }
          getStartHisRecord = function() {
            var result;
            result = null;
            store.each(function(record) {
              if (record.raw.isHistory) {
                result = record;
                return false;
              }
            });
            return result;
          };
          hisRecord = getStartHisRecord();
          hisNode = this.getNode(hisRecord);
          if (hisNode) {
            historyInfo = combo.cache ? combo.cache._myProperties.historyInfo : combo.historyInfo;
            historyTitle = historyInfo != null ? historyInfo.historyTitle : void 0;
            div = document.createElement('div');
            div.className = 'historyValue-separator';
            cntDiv = document.createElement('div');
            cntDiv.className = 'content';
            cntDiv.innerHTML = historyTitle;
            div.appendChild(cntDiv);
            separator = new Ext.dom.Element(div);
            separator.insertBefore(hisNode);
          }
        }
      }
    }
  },
  validator: function(value) {
    var findedIndex, me, replcement, strValue;
    if (!this.editable || !value) {
      return true;
    }
    me = this;
    strValue = value.toString();
    replcement = {
      "&amp;": "&",
      "&gt;": ">",
      "&lt;": "<",
      "&nbsp;": " ",
      "&#39;": "'"
    };
    findedIndex = me.getStore().findBy(function(record) {
      var raw;
      raw = record.get(me.displayField).toString();
      raw = raw.replace(/&((amp)|(lt)|(gt)|(nbsp)|(#39));/g, function(match) {
        return replcement[match];
      });
      return raw === strValue;
    });
    if (findedIndex > -1) {
      return true;
    }
    return "The input value is invalid";
  },
  isLookupable: function() {
    var fn, _ref;
    fn = Corefw.view.form.field.ComboboxField.isLookupable;
    return (fn(this)) || (fn((_ref = this.cache) != null ? _ref._myProperties : void 0));
  },
  isEditable: function() {
    var fn, _ref;
    fn = Corefw.view.form.field.ComboboxField.isEditable;
    return this.editable || (fn(this)) || (fn((_ref = this.cache) != null ? _ref._myProperties : void 0));
  },
  initComponent: function() {
    var addListeners, me;
    me = this;
    if (me.isEditable() && !me.isLookupable()) {
      me.forceSelection = true;
      addListeners = {
        change: function(me, newValue, oldValue) {
          if (newValue === null) {
            me.setValue(null);
            me.setRawValue(null);
          }
        }
      };
      me.on(addListeners);
    }
    if (!me.isEditable()) {
      me.forceSelection = true;
    }
    this.callParent(arguments);
  },
  highLightKeywords: function() {
    var getReplacedContent, keywords, list, nodes, reg, store;
    if (this.picker) {
      keywords = this.getRawValue();
      list = this.picker;
      store = list.getStore();
      if (store.isDestroyed) {
        return;
      }
      if (keywords) {
        keywords = keywords.replace(/[\/\\]/g, function(match) {
          return "\\" + match;
        });
        keywords = keywords.replace(/\*/g, ".*");
        nodes = (function() {
          var result;
          result = [];
          store.each(function(record) {
            var node;
            if (!record.raw.isHistory) {
              node = list.getNode(record);
              if (node) {
                result.push(node);
              }
            }
          });
          return result;
        })();
        reg = new RegExp(keywords, "gi");
        getReplacedContent = function(highlight) {
          var highLightWrapper;
          highLightWrapper = ["<font color='red'>", highlight, "</font>"];
          return highLightWrapper.join("");
        };
        Ext.each(nodes, function(node) {
          node.innerHTML = node.innerHTML.replace(reg, function(match) {
            return getReplacedContent(match);
          });
        });
      }
    }
  },
  setValue: function(value) {
    var me, _ref;
    if (!Ext.isEmpty(value)) {
      me = this;
      if (!me.isRecord(value)) {
        if (((_ref = me.getStore()) != null ? _ref.data.length : void 0) === 0) {
          me.setComboValues(value);
        }
        if (!Ext.isArray(value)) {
          arguments[0] = me.parseValue(value);
        } else {
          arguments[0] = value.map(function(v) {
            if (me.isRecord(v)) {
              return v;
            } else {
              return me.parseValue(v);
            }
          });
        }
      }
    }
    this.callParent(arguments);
  },
  isRecord: function(v) {
    return v.hasOwnProperty('store');
  },
  parseValue: function(v) {
    if (Ext.isObject(v)) {
      return v[this.valueField] || v.value;
    } else if (/^\[[\s\S]*\]$/.test(v)) {
      return v.replace(/\[|\]/g, '').split(',').map(function(s) {
        return Ext.String.trim(s);
      });
    } else {
      return v;
    }
  },
  onTypeAhead: function() {
    if (this.store) {
      this.callParent(arguments);
    }
  },
  doQuery: function() {
    var combo;
    combo = this;
    if (combo.isLookupable()) {
      return;
    } else {
      this.callParent(arguments);
    }
  },
  bindStore: function(store) {
    var historyInfo, historyValues, me;
    me = this;
    this.callParent(arguments);
    if (store) {
      historyInfo = me.cache ? me.cache._myProperties.historyInfo : me.historyInfo;
      historyValues = historyInfo != null ? historyInfo.historyValues : void 0;
      me.addHistoryData(historyValues, true);
    }
  },
  setComboValues: function(value) {
    var getOneValueMap, me, store, values;
    me = this;
    me.validValues = value;
    values = [];
    getOneValueMap = function(item) {
      var obj;
      obj = {};
      if (Ext.isObject(item)) {
        obj[me.displayField] = item[me.displayField] || item.displayValue || item.displayField;
        obj[me.valueField] = item[me.valueField] || item.value || item.valueField;
      } else {
        obj[me.displayField] = item;
        obj[me.valueField] = item;
      }
      return obj;
    };
    if (Ext.isArray(value)) {
      Ext.each(value, function(item) {
        values.push(getOneValueMap(item));
      });
    } else {
      values.push(getOneValueMap(value));
    }
    store = this.getStore();
    store.clearFilter();
    store.loadData(values);
  },
  addHistoryData: function(datas, isRemoveRepeat) {
    var cm, data, getSingleData, me, result, store, _i, _len;
    if (!datas) {
      return;
    }
    cm = Corefw.util.Common;
    me = this;
    store = me.getStore();
    if (!Ext.isArray(datas)) {
      datas = [datas];
    }
    if (isRemoveRepeat) {
      store.each(function(record) {
        var data, index, storeVal, val, _i, _len;
        if (record.raw.isHistory) {
          storeVal = record.get(me.valueField);
          for (index = _i = 0, _len = datas.length; _i < _len; index = ++_i) {
            data = datas[index];
            val = cm.getValue(data);
            if (storeVal === val) {
              datas.splice(index);
            }
          }
        }
      });
    }
    if (!datas.length) {
      return;
    }
    getSingleData = function(item) {
      var obj;
      obj = {};
      obj[me.displayField] = cm.getDisplayValue(item);
      obj[me.valueField] = cm.getValue(item);
      obj.isHistory = true;
      return obj;
    };
    result = [];
    if (Ext.isArray(datas)) {
      for (_i = 0, _len = datas.length; _i < _len; _i++) {
        data = datas[_i];
        result.push(getSingleData(data));
      }
    }
    store.loadData(result, true);
  },
  getDisplayValue: function() {
    var displayValue;
    displayValue = this.callParent(arguments);
    return Ext.htmlDecode(displayValue);
  },
  generatePostData: function() {
    var displayValue, fieldObj, value;
    value = this.getValue();
    displayValue = this.getRawValue();
    fieldObj = {
      name: this.name,
      value: Ext.isEmpty(value) ? "" : value,
      displayValue: Ext.isEmpty(displayValue) ? "" : displayValue
    };
    return fieldObj;
  }
});
