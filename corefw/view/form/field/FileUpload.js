// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.form.field.FileUpload', {
  extend: 'Ext.form.FieldContainer',
  mixins: ['Corefw.mixin.CoreField'],
  xtype: 'corefileupload',
  frame: false,
  layout: 'hbox',
  cls: "" + Ext.baseCSSPrefix + "corefileupload",
  multipleUpload: false,
  uploadable: false,
  acceptFiles: [],
  items: [
    {
      xtype: 'filefield',
      buttonText: 'Select File...',
      name: 'file',
      flex: 1,
      listeners: {
        change: function(field, value) {
          var f, isValidFileType, opts, parent, postData, rq, uploadfield, url, validFileTypeReg, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
          value = [];
          parent = field.up();
          isValidFileType = parent.isValidFileType;
          validFileTypeReg = parent.validFileTypeReg;
          _ref = field.fileInputEl.dom.files;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            f = _ref[_i];
            if (!isValidFileType(f.name, validFileTypeReg)) {
              field.isInvalid = true;
              Ext.Msg.alert('Warning', "'" + f.name + "' is not valid file type!");
              field.setRawValue('');
              return;
            }
            value.push(f.name);
          }
          field.setRawValue(value.join(','));
          field.isInvalid = false;
          uploadfield = field.up();
          if (uploadfield.uploadable) {
            url = (_ref1 = uploadfield.cache) != null ? (_ref2 = _ref1._myProperties) != null ? (_ref3 = _ref2.events) != null ? (_ref4 = _ref3['ONCHANGE']) != null ? _ref4.url : void 0 : void 0 : void 0 : void 0;
            rq = Corefw.util.Request;
            if (url) {
              url = rq.objsToUrl3(url);
              parent = Corefw.util.Uipath.uipathToParentComponent(uploadfield.uipath);
              postData = parent != null ? typeof parent.generatePostData === "function" ? parent.generatePostData() : void 0 : void 0;
              opts = {
                needFormSubmit: true,
                filefields: [field]
              };
              rq.sendRequest5(url, rq.processResponseObject, uploadfield.uipath, postData || {}, void 0, void 0, void 0, void 0, opts);
            }
          }
        }
      }
    }
  ],
  initComponent: function() {
    var su;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      this.items[0].buttonMargin = 8;
      this.items[0].msgTarget = 'under';
    }
    this.callParent(arguments);
  },
  generatePostData: function() {
    var fieldObj, fileContents, fileInfo;
    fieldObj = {
      name: this.name,
      value: null
    };
    if (this.fileContents && this.isStopUpload === false) {
      fileContents = this.fileContents;
      fileInfo = fileContents.fileInfo;
      fieldObj = {
        name: this.name,
        value: {
          name: fileInfo.name,
          size: fileInfo.size,
          lastModifiedDate: fileInfo.lastModifiedDate.valueOf(),
          mimeType: fileInfo.type,
          data: fileContents.data
        }
      };
    }
    return fieldObj;
  },
  afterRender: function() {
    var acceptFiles, fileField, fileInputDom, mb, props, _ref;
    this.callParent(arguments);
    props = (_ref = this.cache) != null ? _ref._myProperties : void 0;
    acceptFiles = props.acceptFiles || [];
    if (props) {
      this.multipleUpload = props.multipleUpload;
      this.uploadable = props.uploadable || true;
    }
    fileField = this.down('filefield');
    fileInputDom = fileField.fileInputEl.dom;
    if (this.multipleUpload) {
      fileInputDom.setAttribute('multiple', 'multiple');
    }
    fileInputDom.title = "No file type limitation";
    this.setAcceptFile(acceptFiles, fileInputDom);
    fileInputDom.setAttribute('name', this.uipath);
    mb = 1024 * 1024;
    fileField.validator = function() {
      var file, fileHolder, maxUploadSize, maxUploadTotalSize, prop, totalSize, _i, _len, _ref1, _ref2;
      fileHolder = this.up();
      prop = (_ref1 = fileHolder.cache) != null ? _ref1._myProperties : void 0;
      maxUploadSize = prop.maxUploadSize || 0;
      maxUploadTotalSize = prop.maxUploadTotalSize || 0;
      if (maxUploadSize || maxUploadTotalSize) {
        totalSize = 0;
        _ref2 = this.fileInputEl.dom.files;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          file = _ref2[_i];
          totalSize += file.size;
          if (maxUploadSize && file.size >= maxUploadSize) {
            return 'The maximum file upload size is ' + Math.round((maxUploadSize / mb) * 1000) / 1000 + 'MB';
          } else if (maxUploadTotalSize && totalSize >= maxUploadTotalSize) {
            return 'The maximum file upload total size is ' + Math.round((maxUploadTotalSize / mb) * 1000) / 1000 + 'MB';
          }
        }
      }
      return true;
    };
  },
  setAcceptFile: function(acceptFiles, fileInputDom) {
    var types;
    if (acceptFiles.length >= 1) {
      this.acceptFiles = acceptFiles;
      types = acceptFiles.map(function(t) {
        return t.replace('.', '');
      });
      fileInputDom.title = 'Could only upload: ' + types.join('|');
      fileInputDom.setAttribute('accept', acceptFiles.join(','));
      this.validFileTypeReg = new RegExp('[^\\.]+[\\.](' + types.join('|') + ')$');
    }
  },
  isValidFileType: function(filename, regExp) {
    if (!regExp) {
      return true;
    }
    return regExp.test(filename);
  }
});
