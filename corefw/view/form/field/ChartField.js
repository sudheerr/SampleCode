// Generated by CoffeeScript 1.8.0
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Ext.define('Corefw.view.form.field.ChartField', {
  extend: 'Ext.form.FieldContainer',
  mixins: ['Corefw.mixin.CoreField'],
  xtype: 'corechartfield',
  frame: false,
  coretype: 'field',
  candidateColors: [],
  convertHEXRGB2Arr: function(hexRGB) {
    return [parseInt("0x" + hexRGB.substr(1, 2)), parseInt("0x" + hexRGB.substr(3, 2)), parseInt("0x" + hexRGB.substr(5, 2))];
  },
  getCandidateColors: function(seriesNum) {
    var arr, repeatTime, ret, rgbArr;
    if (seriesNum == null) {
      seriesNum = 1;
    }
    repeatTime = Math.ceil(seriesNum / this.candidateColors.length);
    ret = [];
    while (repeatTime !== 0) {
      arr = (function() {
        var _i, _len, _ref, _results;
        _ref = this.candidateColors;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          rgbArr = _ref[_i];
          _results.push("rgba(" + rgbArr.join(',') + "," + (1 - (repeatTime - 1) * 0.2) + ")");
        }
        return _results;
      }).call(this);
      ret = arr.concat(ret);
      repeatTime = repeatTime - 1;
    }
    return ret;
  },
  convertColors: function() {
    var color, colors;
    colors = ['#4caeed', '#ff944c', '#4ca977', '#e54343', '#a7a5a6', "#43E622", "#002d72", "#0ACED8", "#c6007e", "#a05eb5", "#ffcd00", "#ff2900", "#b4975a", "#53565a"];
    return this.candidateColors = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = colors.length; _i < _len; _i++) {
        color = colors[_i];
        _results.push(this.convertHEXRGB2Arr(color));
      }
      return _results;
    }).call(this);
  },
  initComponent: function() {
    var alignLegend, axesAr, axesConfig, axisPosition, cache, cacheSeries, chartType, cm, comp, config, dataIndexToTitle, evt, fieldProps, firstSeries, leftFieldAr, legendPosition, me, myFunc, nav, navAr, navObj, oneCol, oneSeries, pathString, props, rdr, rightFieldAr, seriesAr, sortedCacheSeries, st, storeName, su, supportedChartTypes, tbLayout, toolbar, toolbarAr, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
    this.convertColors();
    cm = Corefw.util.Common;
    rdr = Corefw.util.Render;
    evt = Corefw.util.Event;
    su = Corefw.util.Startup;
    this.layout = 'fit';
    cache = this.cache;
    props = cache._myProperties;
    this.uipath = props.uipath;
    cacheSeries = props.columnAr;
    if (cacheSeries.length) {
      for (_i = 0, _len = cacheSeries.length; _i < _len; _i++) {
        oneSeries = cacheSeries[_i];
        if (oneSeries != null ? (_ref = oneSeries._myProperties) != null ? _ref.visible : void 0 : void 0) {
          firstSeries = oneSeries._myProperties;
          break;
        }
      }
    } else {
      console.error('ERROR: no chart series defined, ignoring this chart');
      return;
    }
    if (!firstSeries) {
      firstSeries = {
        seriesType: 'line'
      };
    }
    chartType = (_ref1 = firstSeries.seriesType) != null ? _ref1.toLowerCase() : void 0;
    supportedChartTypes = ['column', 'line', 'area', 'bar', 'pie'];
    if (__indexOf.call(supportedChartTypes, chartType) < 0) {
      console.error("ERROR: chart type " + chartType + " not yet supported, ignoring this chart");
      return;
    }
    dataIndexToTitle = {};
    props.dataIndexToTitle = dataIndexToTitle;
    leftFieldAr = [];
    rightFieldAr = [];
    this.leftFieldAr = leftFieldAr;
    this.rightFieldAr = rightFieldAr;
    for (_j = 0, _len1 = cacheSeries.length; _j < _len1; _j++) {
      oneCol = cacheSeries[_j];
      fieldProps = oneCol._myProperties;
      if (fieldProps.visible) {
        pathString = fieldProps.pathString;
        axisPosition = fieldProps.axis;
        if (axisPosition.toLowerCase() === 'right') {
          rightFieldAr.push(pathString);
          if (fieldProps.format) {
            this.rightAxisFormat = fieldProps.format;
          }
        } else {
          leftFieldAr.push(pathString);
          if (fieldProps.format) {
            this.leftAxisFormat = fieldProps.format;
          }
        }
        if (fieldProps.format) {
          this.fieldFormat = fieldProps.format;
        }
        dataIndexToTitle[pathString] = fieldProps.title;
      }
    }
    if ('axesConfig' in props) {
      axesConfig = props.axesConfig;
      if (axesConfig.premaryYAxisConfig) {
        this.leftAxisFormat = axesConfig.premaryYAxisConfig;
      }
      if (axesConfig.secondaryYAxisConfig) {
        this.rightAxisFormat = axesConfig.secondaryYAxisConfig;
      }
    }
    this.isRenderRightAxis = rightFieldAr.length > 0;
    storeName = this.uipath + '/Store';
    st = this.createStore(storeName, props.series, props);
    sortedCacheSeries = this.sortSeries(cacheSeries);
    if (chartType === 'pie') {
      _ref2 = this.configPolarNew(), seriesAr = _ref2[0], axesAr = _ref2[1];
    } else {
      _ref3 = this.configCartesianNew(sortedCacheSeries), seriesAr = _ref3[0], axesAr = _ref3[1];
    }
    legendPosition = false;
    if (cache._myProperties.legend) {
      alignLegend = cache._myProperties.alignLegend.toLowerCase();
      if (alignLegend !== 'none') {
        legendPosition = alignLegend;
      }
    }
    config = {
      margin: 10,
      store: st,
      series: seriesAr,
      axes: axesAr,
      theme: 'CVCustom',
      legend: false,
      legendPosition: legendPosition,
      flex: 1
    };
    if (su.getThemeVersion() === 2) {
      config.style = 'backgroundColor: #EBEBEB;';
      config.margin = 0;
      config.insetPadding = 15;
    }
    comp = Ext.create('Ext.chart.Chart', config);
    this.chart = comp;
    if (chartType === 'column') {
      this.updateThemeAttrsColors(this.chart, sortedCacheSeries);
    }
    navAr = props != null ? (_ref4 = props.navs) != null ? _ref4._ar : void 0 : void 0;
    if (navAr) {
      toolbarAr = [];
      for (_k = 0, _len2 = navAr.length; _k < _len2; _k++) {
        nav = navAr[_k];
        navObj = {
          uipath: nav.uipath,
          hidden: !nav.visible,
          disabled: !nav.enabled,
          name: nav.name,
          margin: '0 0 0 3',
          xtype: 'button',
          ui: 'toolbutton',
          scale: 'small'
        };
        tbLayout = {
          type: 'hbox'
        };
        switch (nav.align) {
          case 'CENTER':
            tbLayout.pack = 'center';
            break;
          case 'RIGHT':
            tbLayout.pack = 'end';
            break;
          default:
            tbLayout.pack = 'start';
        }
        if (nav.toolTip) {
          navObj.tooltip = nav.toolTip;
        }
        if (nav.style) {
          navObj.iconCls = nav.style;
        }
        toolbarAr.push(navObj);
        evt.addEvents(nav, 'nav', navObj);
      }
      toolbar = Ext.create('Ext.Container', {
        layout: tbLayout,
        items: toolbarAr
      });
      this.layout = {
        type: 'vbox',
        align: 'stretch'
      };
      this.items = [toolbar, comp];
    } else {
      this.items = [comp];
    }
    delete this.fieldAr;
    this.callParent(arguments);
    me = this;
    myFunc = Ext.Function.createDelayed(function() {
      var elemComp;
      elemComp = me.up('[coretype=element]');
      me.element = elemComp;
    }, 1);
    myFunc();
  },
  sortSeries: function(cacheSeries) {
    var columnSeries, lineSeries, otherSeries, series, seriesObj, seriesProps, _i, _len;
    series = [];
    columnSeries = [];
    lineSeries = [];
    otherSeries = [];
    for (_i = 0, _len = cacheSeries.length; _i < _len; _i++) {
      seriesObj = cacheSeries[_i];
      seriesProps = seriesObj._myProperties;
      if (seriesProps.seriesType === 'COLUMN' && seriesProps.visible) {
        columnSeries.push(seriesObj);
      } else if (seriesProps.seriesType === 'LINE' && seriesProps.visible) {
        lineSeries.push(seriesObj);
      } else {
        otherSeries.push(seriesObj);
      }
    }
    series = columnSeries.concat(lineSeries);
    return series = series.concat(otherSeries);
  },
  updateThemeAttrsColors: function(chart, cacheSeries) {
    var index, oneSeries, themeAttrsColors, _i, _len;
    if (chart.theme === 'CVCustom') {
      chart.themeAttrs.colors = this.getCandidateColors(cacheSeries.length);
    }
    themeAttrsColors = chart.themeAttrs.colors;
    index = 0;
    for (_i = 0, _len = cacheSeries.length; _i < _len; _i++) {
      oneSeries = cacheSeries[_i];
      if (!Ext.isEmpty(oneSeries._myProperties.color)) {
        themeAttrsColors[index] = oneSeries._myProperties.color;
      }
      index = index + 1;
    }
  },
  configCartesianNew: function(series) {
    var axesAr, axis, axisTitle, axisType, cache, cacheSeries, chartType, chartTypeAxis, colprops, configSeriesStyle, dataIndexToTitle, found, label, labelAxis, leftNumAxis, me, oneCol, oneSeries, path, props, rendererFunction, rightNumAxis, seriesAr, seriesType, setCartesianSeries, styleObj, styleObjs, su, typeAr, yLeftAxisTitle, yRightAxisTitle, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    me = this;
    su = Corefw.util.Startup;
    props = this.cache._myProperties;
    dataIndexToTitle = props.dataIndexToTitle;
    seriesAr = [];
    axesAr = [];
    for (_i = 0, _len = series.length; _i < _len; _i++) {
      oneCol = series[_i];
      if (oneCol._myProperties.visible) {
        axis = (_ref = oneCol._myProperties) != null ? _ref.axis.toLowerCase() : void 0;
        axisTitle = (_ref1 = oneCol._myProperties) != null ? _ref1.yaxisTitle : void 0;
        if (axisTitle.length > 0) {
          if (axis === 'right') {
            yRightAxisTitle = axisTitle;
          } else {
            yLeftAxisTitle = axisTitle;
          }
        }
      }
    }
    leftNumAxis = {
      type: 'Numeric',
      grid: true,
      position: 'left',
      fields: this.leftFieldAr,
      title: yLeftAxisTitle
    };
    if (this.leftAxisFormat) {
      leftNumAxis.label = {
        renderer: Ext.util.Format.numberRenderer(this.leftAxisFormat)
      };
    }
    if (this.isRenderRightAxis) {
      rightNumAxis = {
        type: 'Numeric',
        grid: true,
        position: 'right',
        fields: this.rightFieldAr,
        title: yRightAxisTitle
      };
      if (this.rightAxisFormat) {
        rightNumAxis.label = {
          renderer: Ext.util.Format.numberRenderer(this.rightAxisFormat)
        };
      }
    }
    labelAxis = {
      type: 'Category',
      position: 'bottom',
      fields: [props.groupBy]
    };
    if (props.labelRotated) {
      label = {
        rotate: {
          degrees: 315
        }
      };
      labelAxis.label = label;
    }
    if (props.xLabelTransfer) {
      me.xLabelTransfer = props.xLabelTransfer;
      rendererFunction = function(value) {
        if (me.xLabelTransfer[value]) {
          return me.xLabelTransfer[value];
        } else {
          return '';
        }
      };
      if (Ext.isEmpty(label)) {
        label = {
          renderer: rendererFunction
        };
      } else {
        label.renderer = rendererFunction;
      }
    }
    if (su.getThemeVersion() === 2) {
      labelAxis.label = leftNumAxis.label = {
        fill: '#2B2B2B'
      };
      if (rightNumAxis) {
        rightNumAxis.label = {
          fill: '#2B2B2B'
        };
      }
    }
    chartType = (_ref2 = series[0]) != null ? (_ref3 = _ref2._myProperties) != null ? (_ref4 = _ref3.seriesType) != null ? _ref4.toLowerCase() : void 0 : void 0 : void 0;
    if (chartType === 'bar') {
      if (this.isRenderRightAxis) {
        leftNumAxis.position = 'top';
        rightNumAxis.position = 'bottom';
      } else {
        leftNumAxis.position = 'bottom';
      }
      labelAxis.position = 'left';
    }
    if (props.xAxisTitle) {
      labelAxis.title = props.xAxisTitle;
    }
    axesAr.push(leftNumAxis);
    if (this.isRenderRightAxis) {
      axesAr.push(rightNumAxis);
    }
    axesAr.push(labelAxis);
    seriesType = {};
    configSeriesStyle = function(currentColprops) {
      var styleObj;
      styleObj = {};
      if (currentColprops.color !== '') {
        styleObj.stroke = currentColprops.color;
      }
      if (currentColprops.lineWidth) {
        styleObj['stroke-width'] = currentColprops.lineWidth;
      }
      styleObj.radius = currentColprops.radius;
      return styleObj;
    };
    styleObjs = {};
    for (_j = 0, _len1 = series.length; _j < _len1; _j++) {
      oneCol = series[_j];
      colprops = oneCol != null ? oneCol._myProperties : void 0;
      if ((colprops != null ? colprops.isRemovedFromUI : void 0) || !(colprops != null ? colprops.visible : void 0)) {
        continue;
      }
      chartType = (_ref5 = colprops.seriesType) != null ? _ref5.toLowerCase() : void 0;
      axisType = colprops.axis;
      chartTypeAxis = chartType + '-' + axisType;
      styleObj = configSeriesStyle(colprops);
      typeAr = seriesType[chartTypeAxis];
      if (!typeAr) {
        typeAr = [];
        seriesType[chartTypeAxis] = typeAr;
      }
      path = colprops.pathString;
      styleObjs[path] = styleObj;
      typeAr.push(path);
    }
    me = this;
    setCartesianSeries = function(currentChartType, currentAxis, typeAr2, currentStyleObj) {
      var fieldPath, seriesObj, _k, _len2, _ref6;
      seriesObj = {
        type: currentChartType,
        xField: props.groupBy,
        yField: typeAr2,
        stacked: false,
        highlight: true,
        style: {
          lineWidth: 0
        }
      };
      if (currentChartType === 'line') {
        seriesObj.markerConfig = {
          type: 'circle',
          radius: currentStyleObj.radius
        };
        seriesObj.highlight = {
          radius: currentStyleObj.radius + 2
        };
        if (currentStyleObj && currentStyleObj.stroke !== '') {
          seriesObj.markerConfig.fill = currentStyleObj.stroke;
        }
        seriesObj.style = currentStyleObj;
      }
      if (typeAr2 && typeAr2.length) {
        seriesObj.tips = {
          trackMouse: true,
          shrinkWrapDock: true,
          renderer: function(storeItem, item) {
            var bodyTextField;
            if (typeAr2.length === 1) {
              bodyTextField = typeAr2[0];
            } else {
              bodyTextField = item.yField ? item.yField : item.storeField;
            }
            this.setTitle(storeItem.get(props.groupBy));
            this.update(Ext.util.Format.number(storeItem.get(bodyTextField), me.fieldFormat));
          }
        };
        seriesObj.title = [];
        for (_k = 0, _len2 = typeAr2.length; _k < _len2; _k++) {
          fieldPath = typeAr2[_k];
          seriesObj.title.push(dataIndexToTitle[fieldPath]);
        }
      }
      if ((_ref6 = me.eventURLs) != null ? _ref6.ONCLICK : void 0) {
        seriesObj.listeners = {
          itemclick: {
            fn: me.segmentItemClick,
            scope: me
          }
        };
      }
      if (currentChartType === 'bar') {
        seriesObj.axis = 'bottom';
      } else {
        seriesObj.axis = currentAxis.toLowerCase();
      }
      if (seriesObj.type === 'area' || props.stacked) {
        seriesObj.stacked = true;
      }
      seriesAr.push(seriesObj);
    };
    for (chartTypeAxis in seriesType) {
      typeAr = seriesType[chartTypeAxis];
      _ref6 = chartTypeAxis.split('-'), chartType = _ref6[0], axis = _ref6[1];
      if (chartType === 'line') {
        for (_k = 0, _len2 = typeAr.length; _k < _len2; _k++) {
          oneCol = typeAr[_k];
          found = false;
          styleObj = styleObjs[oneCol];
          cache = this.cache;
          props = cache._myProperties;
          cacheSeries = props.columnAr;
          if (cacheSeries.length) {
            for (_l = 0, _len3 = cacheSeries.length; _l < _len3; _l++) {
              oneSeries = cacheSeries[_l];
              if ((oneSeries != null ? (_ref7 = oneSeries._myProperties) != null ? _ref7.pathString : void 0 : void 0) === axis && !(oneSeries != null ? (_ref8 = oneSeries._myProperties) != null ? _ref8.visible : void 0 : void 0)) {
                found = true;
                break;
              }
            }
          }
          if (found) {
            setCartesianSeries(chartType, axis, null, styleObj);
          } else {
            setCartesianSeries(chartType, axis, [oneCol], styleObj);
          }
        }
      } else {
        setCartesianSeries(chartType, axis, typeAr);
      }
    }
    return [seriesAr, axesAr];
  },
  configPolarNew: function() {
    var chartColorSet, me, path, props, series, seriesAr, seriesObj, seriesProps, seriesType, su, textDisplay, _ref, _ref1;
    props = this.cache._myProperties;
    series = props.columnAr;
    seriesAr = [];
    su = Corefw.util.Startup;
    seriesProps = series[0]._myProperties;
    seriesType = (_ref = seriesProps.seriesType) != null ? _ref.toLowerCase() : void 0;
    path = seriesProps.pathString;
    seriesObj = {
      type: seriesType,
      angleField: path,
      showInLegend: true,
      highlight: {
        segment: {
          margin: 20
        }
      },
      label: {
        field: props.groupBy,
        display: 'rotate',
        contrast: true,
        renderer: function(value, label, storeItem) {
          var total, _ref1;
          if (su.getThemeVersion() === 2) {
            if (props.showAs) {
              if ((_ref1 = props.showAs) === 'PERCENTAGE' || _ref1 === 'DEFAULT') {
                total = 0;
                storeItem.store.each(function(rec) {
                  total += rec.get(path);
                });
                value = total !== 0 ? Math.round(storeItem.get(path) / total * 100) + '%' : '';
              } else if (props.showAs === 'NUMBER') {
                value = storeItem.get(path);
              } else if (props.showAs === 'NONE') {
                label.el.setVisible(false);
              } else {
                value = value;
              }
            }
          }
          return value;
        }
      },
      tips: {
        trackMouse: true,
        shrinkWrapDock: true,
        renderer: function(storeItem, item) {
          var total;
          total = 0;
          storeItem.store.each(function(rec) {
            total += rec.get(path);
          });
          this.setTitle(storeItem.get(props.groupBy) + (total !== 0 ? ': ' + Math.round(storeItem.get(path) / total * 100) + '%' : ''));
          this.update(storeItem.get(path));
        }
      }
    };
    if (su.getThemeVersion() === 2) {
      seriesObj.label.display = 'outside';
      if (props.textDisplayStyle) {
        textDisplay = props.textDisplayStyle.toLowerCase();
        if (props.textDisplayStyle === 'HORIZONTAL') {
          textDisplay = 'middle';
        }
        seriesObj.label.display = textDisplay;
      }
      if (props.chartColors && props.chartColors.length) {
        chartColorSet = Ext.Array.map(props.chartColors, function(colors) {
          return Corefw.util.Cache.chartColorsSet[colors];
        });
        seriesObj.colorSet = chartColorSet;
      }
      seriesObj.style = {
        stroke: '#EBEBEB',
        'stroke-width': 2
      };
      seriesObj.shadowAttributes = [];
      seriesObj.label.contrast = false;
      seriesObj.label.padding = 0;
      seriesObj.label.color = '#2B2B2B';
      seriesObj.highlight.segment.margin = 4;
    }
    me = this;
    if ((_ref1 = me.eventURLs) != null ? _ref1.ONCLICK : void 0) {
      seriesObj.listeners = {
        itemclick: {
          fn: me.segmentItemClick,
          scope: me
        }
      };
    }
    seriesAr.push(seriesObj);
    return [seriesAr, []];
  },
  createStore: function(name, inputAr, chartProps) {
    var cm, colValue, dt, fieldValue, fields, firstRowObj, index, key, path, st, storeConfig, storeDataAr, storeFieldObj, valueObj, _i, _len;
    cm = Corefw.util.Common;
    storeDataAr = [];
    fields = [];
    storeConfig = {
      autoDestroy: true,
      autoLoad: true,
      fields: fields,
      storeId: name,
      data: storeDataAr
    };
    if (inputAr && Ext.isArray(inputAr) && inputAr.length) {
      firstRowObj = inputAr[0];
      for (key in firstRowObj) {
        fieldValue = firstRowObj[key];
        storeFieldObj = {
          name: key,
          type: cm.valueToFieldType(fieldValue)
        };
        fields.push(storeFieldObj);
      }
      index = 0;
      for (_i = 0, _len = inputAr.length; _i < _len; _i++) {
        valueObj = inputAr[_i];
        for (path in valueObj) {
          colValue = valueObj[path];
          if (Ext.isDate(colValue)) {
            dt = new Date(colValue);
            valueObj[path] = dt;
            continue;
          }
        }
        storeDataAr.push(valueObj);
      }
    }
    Corefw.util.Data.removeStore(name);
    st = Ext.create('Ext.data.Store', storeConfig);
    return st;
  },
  segmentItemClick: function(obj, eOpts) {
    var chart, postData, rq, url;
    rq = Corefw.util.Request;
    chart = eOpts.scope;
    console.log('segement item click: item, chart, uipath: ', obj, chart, this.uipath);
    url = rq.objsToUrl3(chart.eventURLs.ONCLICK);
    postData = this.generatePostData(obj);
    console.log('%% postData ', postData);
    rq.sendRequest5(url, rq.processResponseObject, this.uipath, postData);
  },
  generatePostData: function(selectedObj) {
    var cache, labelField, model, postData, props, segmentValue, selectedSegment, seriesName, _ref, _ref1, _ref2, _ref3;
    cache = this.cache;
    props = cache._myProperties;
    postData = {
      name: props.name
    };
    if (!selectedObj) {
      return postData;
    }
    seriesName = (_ref = selectedObj.series) != null ? _ref.angleField : void 0;
    if (!seriesName) {
      seriesName = selectedObj.yField;
      if (!seriesName) {
        seriesName = selectedObj.storeField;
      }
    }
    labelField = (_ref1 = selectedObj.series) != null ? _ref1.xField : void 0;
    if (!labelField) {
      labelField = (_ref2 = selectedObj.series) != null ? (_ref3 = _ref2.label) != null ? _ref3.field : void 0 : void 0;
    }
    model = selectedObj.storeItem;
    if (labelField && model) {
      segmentValue = model.get(labelField);
    }
    console.log('generatePostData: selectedObj, seriesName, segmentValue, labelField, model: ', selectedObj, seriesName, segmentValue, labelField, model);
    if (seriesName && segmentValue) {
      selectedSegment = {
        seriesName: seriesName,
        segmentValue: segmentValue
      };
      postData.selectedSegment = selectedSegment;
    }
    return postData;
  }
});
