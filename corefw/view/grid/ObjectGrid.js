// Generated by CoffeeScript 1.8.0

/*
	This grid is always contained in a form field.
	As such, it extends fieldcontainer, and then creates a GridBase object
		inside that container
 */
Ext.define('Corefw.view.grid.ObjectGrid', {
  extend: 'Corefw.view.grid.GridFieldBase',
  xtype: 'coreobjectgrid',
  mixins: ['Corefw.mixin.Refreshable'],
  initComponent: function() {
    this.coretype = 'field';
    this.initalizeObjectGrid();
    this.addListeners();
    this.callParent(arguments);
  },
  addListeners: function() {
    var additionalListeners;
    this.listeners = this.listeners || {};
    additionalListeners = {
      gridclose: this.gridclose
    };
    return Ext.apply(this.listeners, additionalListeners);
  },
  gridclose: function(objGrid) {
    objGrid.onGridClose();
  },
  initalizeObjectGrid: function() {
    var InlineFilterIconCls, addlConfig, bottomBar, cache, cachePropertiesToCopy, cm, comp, config, dockedItems, evt, fieldItem, fieldItems, fieldItemstype, fieldProps, filterVisibility, functionButtonType, gridCache, gridConfig, gridProps, gridToolObj, gridcls, item, itemProps, me, nav, navAr, newItemObj, newItemProps, propertiesToCopy, props, showhidefilter, showhidefiltr, su, tbar, tools, topBar, view, _i, _j, _k, _len, _len1, _len2, _ref;
    me = this;
    cm = Corefw.util.Common;
    tools = [];
    evt = Corefw.util.Event;
    su = Corefw.util.Startup;
    cache = me.cache;
    fieldProps = cache._myProperties;
    this.uipath = fieldProps.uipath;
    fieldItemstype = fieldProps.columnAr;
    showhidefiltr = this.isFilterEnabledForAnyColumn(fieldItemstype);
    functionButtonType = 'tool';
    if (fieldItemstype) {
      for (_i = 0, _len = fieldItemstype.length; _i < _len; _i++) {
        fieldItem = fieldItemstype[_i];
        if (fieldItemstype[_i]._myProperties.filterType === 'NUMBER' && fieldItemstype[_i]._myProperties.filterValue === 0) {
          cache[fieldItemstype[_i]._myProperties.name]._myProperties.filterValue = '0';
        }
      }
    }
    gridConfig = {
      inlineFilterVisibility: !fieldProps.hideGridHeaderFilters,
      columns: {
        defaults: {
          lockable: false
        },
        items: []
      },
      hideHeaders: false,
      coretype: 'field',
      corefieldtype: 'objectgrid',
      functionButtonType: functionButtonType,
      style: {
        borderWidth: '0px'
      }
    };
    if (me.fieldLabel) {
      if (su.getThemeVersion() !== 2) {
        tools.push({
          xtype: 'text',
          name: 'fieldLabel',
          text: (me.fieldLabel === '&nbsp;' ? '' : me.fieldLabel),
          margin: '0 10 0 0 ',
          cls: 'custom-header'
        });
      } else {
        tools.push({
          xtype: 'text',
          name: 'fieldLabel',
          text: (me.fieldLabel === '&nbsp;' ? '' : me.fieldLabel),
          margin: '0 10 0 5 ',
          cls: 'custom-header'
        });
      }
    }
    switch (functionButtonType) {
      case 'toolbar':
        dockedItems = [];
        tbar = [];
        topBar = {
          xtype: 'toolbar',
          dock: 'top',
          items: tbar
        };
        dockedItems.push(topBar);
    }
    navAr = fieldProps != null ? (_ref = fieldProps.navs) != null ? _ref._ar : void 0 : void 0;
    if (navAr) {
      for (_j = 0, _len1 = navAr.length; _j < _len1; _j++) {
        nav = navAr[_j];
        gridToolObj = {
          uipath: nav.uipath,
          hidden: !nav.visible,
          disabled: !nav.enabled
        };
        switch (functionButtonType) {
          case 'tool':
            addlConfig = {
              xtype: 'button',
              ui: 'toolbutton',
              scale: 'small',
              tooltip: nav.toolTip,
              iconCls: nav.style
            };
            if (su.getThemeVersion() === 2) {
              if (nav.style === 'I_SPACER') {
                addlConfig = {
                  xtype: 'tbseparator',
                  cls: 'iconSeparator',
                  margin: '0 4 0 4'
                };
              } else {
                addlConfig.iconCls = 'icon icon-' + Corefw.util.Cache.cssclassToIcon[nav.style];
                addlConfig.padding = '0 4 0 4';
              }
            }
            Ext.apply(gridToolObj, addlConfig);
            tools.push(gridToolObj);
            break;
          case 'toolbar':
            config = {
              xtype: 'button',
              margin: '0 0 0 9'
            };
            if (nav.title) {
              config.text = nav.title;
            } else {
              config.text = ' ';
            }
            if (nav.style) {
              config.iconCls = nav.style;
            }
            Ext.apply(gridToolObj, config);
            tbar.push(gridToolObj);
        }
        evt.addEvents(nav, 'nav', gridToolObj);
      }
    }
    if (fieldProps.multiColumnSortingEnabled) {
      tools.push({
        xtype: 'button',
        ui: 'toolbutton',
        scale: 'small',
        iconCls: su.getThemeVersion() === 2 ? 'icon icon-sort-asc' : 'I_SORTER',
        onClick: function() {
          Ext.create('Corefw.view.grid.SortingWindow', {
            grid: this.up('grid')
          });
        }
      });
    }
    if (showhidefiltr) {
      me = this;
      if (su.getThemeVersion() === 2) {
        showhidefilter = me.cache._myProperties.hideGridHeaderFilters;
        filterVisibility = me.inlineFilterVisibility;
        InlineFilterIconCls = showhidefilter === true ? 'icon icon-filterswitch-1' : filterVisibility === false ? 'icon icon-filterswitch-1' : 'icon icon-filterswitch-2';
      } else {
        InlineFilterIconCls = me.inlineFilterVisibility === void 0 ? 'I_SHOWFILTER' : me.inlineFilterVisibility === false ? 'I_HIDEFILTER' : 'I_SHOWFILTER';
      }
      tools.push({
        xtype: 'button',
        ui: 'toolbutton',
        scale: 'small',
        tooltip: 'Hide/Show Filters',
        iconCls: InlineFilterIconCls,
        handler: function() {
          var thePlugin;
          thePlugin = me.grid.findPlugin('inlinefilter');
          if (thePlugin.visibility) {
            thePlugin.visibility = false;
            if (su.getThemeVersion() === 2) {
              this.setIconCls('icon icon-filterswitch-1');
            } else {
              this.setIconCls('I_HIDEFILTER');
            }
            thePlugin.resetup(me.grid);
          } else {
            thePlugin.visibility = true;
            if (su.getThemeVersion() === 2) {
              this.setIconCls('icon icon-filterswitch-2');
            } else {
              this.setIconCls('I_SHOWFILTER');
            }
            thePlugin.setup(me.grid);
          }
          me.grid.getView().refresh();
          me.inlineFilterVisibility = thePlugin.visibility;
        }
      }, {
        xtype: 'button',
        ui: 'toolbutton',
        scale: 'small',
        tooltip: 'Clear All Filters',
        iconCls: su.getThemeVersion() === 2 ? 'icon icon-filter-delete' : 'I_CLEARFILTER',
        handler: function() {
          var thePlugin;
          thePlugin = me.grid.findPlugin('inlinefilter');
          thePlugin.resetFilters(me.grid);
        }
      });
    }
    if (fieldProps.editable || (tbar != null ? tbar.length : void 0) > 0 || (tools != null ? tools.length : void 0) > 0) {
      tools.push({
        xtype: 'tbfill'
      });
      gridConfig.header = {};
      gridConfig.header.titlePosition = tools.length;
      switch (functionButtonType) {
        case 'tool':
          gridConfig.tools = tools;
          break;
        case 'toolbar':
          gridConfig.dockedItems = dockedItems;
      }
    }
    if (fieldProps && fieldProps.footerPagingToolbar) {
      this.margin = '0 0 0 0';
      bottomBar = {
        xtype: 'toolbar',
        dock: 'bottom',
        height: 25,
        cls: 'bottomBarBorder',
        style: {
          'background-color': su.getThemeVersion() === 2 ? '#D5D6D7' : '#FFFFFF',
          'border-bottom-color': '#FFFFFF'
        }
      };
      if (dockedItems) {
        dockedItems.push(bottomBar);
      } else {
        dockedItems = [];
        dockedItems.push(bottomBar);
      }
      gridConfig.dockedItems = dockedItems;
    }
    propertiesToCopy = ['fieldMask', 'editable', 'enabled', 'visible', 'events', 'isLookup', 'title', 'path', 'pathString', 'tooltip', 'toolTip', 'validations', 'validValues', 'group', 'rows', 'width', 'minWidth', 'maxWidth', 'supportMultiSelect', 'filterType', 'filterValue', 'filterOperator', 'filterOperators', 'supportSort', 'feValidations', 'uipath', 'name', 'iconMap', 'format', 'multiSelect', 'lookupable', 'sortState', 'spinnerSpec', 'linkMap', 'menu', 'dropdownMenu', 'supportWholeCheck', 'gridPicker', 'textAlign', 'multiColumnSortingEnabled', 'index', 'pageSize', 'flexWidth', 'hideable', 'lockable', 'draggable', 'showColumnsMenu', 'minDate', 'maxDate', 'multiFilterCriteria', 'filterOptions', 'onlyHaveOneFilterOperators'];
    props = cache._myProperties;
    gridCache = {};
    gridConfig.cache = gridCache;
    gridProps = {};
    gridCache._myProperties = gridProps;
    fieldItems = props.columnAr;
    if (!fieldItems) {
      fieldItems = props.items;
    }
    if (fieldItems) {
      for (_k = 0, _len2 = fieldItems.length; _k < _len2; _k++) {
        item = fieldItems[_k];
        itemProps = item._myProperties;
        if (!itemProps) {
          continue;
        }
        newItemObj = {
          _myProperties: {
            columnType: itemProps.type
          }
        };
        newItemProps = newItemObj._myProperties;
        cm.copyObjProperties(newItemProps, itemProps, propertiesToCopy);
        gridCache[itemProps.name] = newItemObj;
        if (itemProps.editable) {
          props.editableColumns = true;
          gridProps.editableColumns = true;
          gridProps.editable = true;
        }
      }
    }
    cachePropertiesToCopy = ['enableTextSelection', 'events', 'groupField', 'onlyRefreshGridData', 'enableAutoSelectAll', 'data', 'name', 'uipath', 'title', 'columnAr', 'headerEllipses', 'headerTitleRows', 'numberOfLockedHeaders', 'supportAutoNumber', 'showFullRow', 'selectType', 'checkOnly', 'collapsible', 'mandatory', 'sortHeaders', 'hideGridHeaderMenus', 'multiColumnSortingEnabled', 'draggable', 'recievablePaths', 'maxRow', 'minRow', 'closable', 'infinity', 'bufferedPages', 'infiniteFinish', 'footerText', 'pageSize', 'currentPage', 'showEditingMask', 'buffered', 'selectedAll', 'selectAllScope'];
    cm.copyObjProperties(gridProps, props, cachePropertiesToCopy);
    if (!fieldProps.pageSize && fieldProps.showTitleBar === false) {
      delete gridConfig.title;
      delete gridConfig.tools;
      delete gridConfig.header;
    }
    gridcls = 'Corefw.view.grid.GridBase';
    comp = Ext.create(gridcls, gridConfig);
    this.addGrid(comp);
    view = comp.getView();
    view.getCell = function(record, column) {
      var row;
      row = view.getNode(record, true);
      if (!row || !column) {
        return;
      }
      return Ext.fly(row).down(column.getCellSelector());
    };
  },
  afterRender: function() {
    var currency, props, unit;
    this.callParent(arguments);
    props = this.cache._myProperties;
    currency = props.currency;
    unit = props.numberScaleUnit;
    if (currency !== void 0) {
      this.createCurrencyCmp(props.selectableCurrencies, currency);
    }
    if (unit !== void 0) {
      this.createUnitCmp(props.selectableNumberScaleUnits, unit);
    }
    this.createPagingToolbar();
  },
  createComboboxInHeader: function(name, datas, selected) {
    var addIndex, comboCfg, header, me, toolBtns;
    me = this;
    header = this.down('header');
    if (!header) {
      return;
    }
    toolBtns = header.query('[docked=right]');
    if (toolBtns.length) {
      addIndex = header.items.indexOf(toolBtns[0]);
    } else {
      addIndex = header.items.length;
    }
    comboCfg = {
      xtype: "combo",
      editable: false,
      margin: "2 2 2 2",
      displayField: 'displayField',
      valueField: 'valueField',
      width: 50,
      align: 'right',
      value: selected,
      name: name,
      getDisplayValue: function() {
        var display;
        display = this.displayTpl.apply(this.displayTplData);
        if (display === "&nbsp;") {
          return "";
        } else {
          return display;
        }
      },
      store: Ext.create('Ext.data.Store', {
        fields: ["displayField", "valueField"],
        data: datas
      }),
      listeners: {
        change: function(combo, newValue, oldValue) {
          me.comboboxInHeaderChange();
        }
      }
    };
    header.insert(addIndex, comboCfg);
  },
  registHeaderPostCmp: function(name) {
    if (!this.headerPostCmpNames) {
      this.headerPostCmpNames = [];
    }
    this.headerPostCmpNames.push(name);
  },
  comboboxInHeaderChange: function() {
    var name, postData, _i, _len, _ref;
    postData = {};
    _ref = this.headerPostCmpNames;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      postData[name] = this.down("[name=" + name + "]").getValue();
    }
    this.sendONLOADRequest(postData);
  },
  createLabelInHeader: function(name, text) {
    var addIndex, header, labelCfg, toolBtns;
    header = this.down('header');
    if (!header) {
      return;
    }
    toolBtns = header.query('[docked=right]');
    if (toolBtns.length) {
      addIndex = header.items.indexOf(toolBtns[0]);
    } else {
      addIndex = header.items.length;
    }
    labelCfg = {
      xtype: "label",
      margin: "2 2 2 2",
      align: 'right',
      text: text,
      name: name,
      getValue: function() {
        return text;
      }
    };
    header.insert(addIndex, labelCfg);
  },
  createCurrencyCmp: function(datas, selected) {
    var cmpName, data, newDatas, _i, _len;
    cmpName = "currency";
    this.registHeaderPostCmp(cmpName);
    if (datas) {
      newDatas = [];
      for (_i = 0, _len = datas.length; _i < _len; _i++) {
        data = datas[_i];
        newDatas.push({
          displayField: data,
          valueField: data
        });
      }
      this.createComboboxInHeader(cmpName, newDatas, selected);
    } else {
      this.createLabelInHeader(cmpName, selected);
    }
  },
  createUnitCmp: function(datas, selected) {
    var cmpName, data, newDatas, _i, _len;
    cmpName = "numberScaleUnit";
    this.registHeaderPostCmp(cmpName);
    if (datas) {
      newDatas = [];
      for (_i = 0, _len = datas.length; _i < _len; _i++) {
        data = datas[_i];
        newDatas.push({
          displayField: data || "&nbsp;",
          valueField: data
        });
      }
      this.createComboboxInHeader(cmpName, newDatas, selected);
    } else {
      this.createLabelInHeader(cmpName, selected);
    }
  },
  applyPaginationStore: function(store, props) {
    var ceilPage, currentPage, floorPage, storeConfig;
    currentPage = props.currentPage;
    ceilPage = Math.ceil(props.totalRows / props.pageSize);
    floorPage = Math.floor(props.totalRows / props.pageSize);
    if (currentPage > floorPage) {
      if (ceilPage === floorPage) {
        currentPage = floorPage;
      } else {
        currentPage = ceilPage;
      }
    }
    storeConfig = {
      totalCount: props.totalRows,
      pageSize: props.pageSize,
      currentPage: currentPage,
      selectablePageSizes: props.selectablePageSizes
    };
    Ext.apply(store, storeConfig);
  },
  createPagingToolbar: function() {
    var addIndex, cache, fieldProps, header, loadConfig, me, pagingToolbarConfig, props, su, toolBtns;
    me = this;
    props = this.cache._myProperties;
    su = Corefw.util.Startup;
    cache = me.cache;
    fieldProps = cache._myProperties;
    if (props.pageSize && (!Ext.isEmpty(props.totalRows)) && !fieldProps.infinity) {
      header = this.down('header');
      if (header) {
        loadConfig = {
          loadPage: function(pageNum) {
            me.loadPage(pageNum);
          }
        };
        this.applyPaginationStore(me.grid.store, props);
        Ext.apply(me.grid.store, loadConfig);
        pagingToolbarConfig = {
          xtype: 'corepagingtoolbar',
          cache: props,
          store: this.grid.store,
          displayInfo: true,
          margin: '0 20 0 0'
        };
        if (su.getThemeVersion() === 2) {
          pagingToolbarConfig.displayInfo = false;
          pagingToolbarConfig.margin = '0 8 0 0';
        }
        toolBtns = header.query('[docked=right]');
        if (toolBtns.length) {
          addIndex = header.items.indexOf(toolBtns[0]);
        } else {
          addIndex = header.items.length;
        }
        header.insert(addIndex, pagingToolbarConfig);
      }
    }
  },
  generatePagingPostData: function(pageNum, pageSize, total) {
    var postData, prop;
    prop = this.cache._myProperties;
    pageNum = pageNum || 1;
    pageSize = pageSize || prop.pageSize || 1;
    total = total || prop.totalRows || 1;
    if (pageNum > Math.ceil(total / pageSize)) {
      pageNum = Math.ceil(total / pageSize);
    }
    postData = {
      name: this.cache._myProperties.name,
      total: total,
      currentPage: pageNum,
      pageSize: pageSize
    };
    Ext.apply(postData, this.grid.generatePagingPostData());
    return postData;
  },
  loadPage: function(pageNum) {
    var me, pageSize, postData;
    me = this;
    pageSize = me.grid.store.pageSize;
    postData = me.generatePagingPostData(pageNum, pageSize);
    me.grid.remoteLoadStoreData(postData);
  },
  switchSelectAllScope: function() {
    var me, postData;
    me = this;
    postData = me.generatePostData();
    me.grid.remoteLoadStoreData(postData);
  },
  sendRequest: function(pageNum) {
    var eventStr, events, postData, rq, url, _ref, _ref1;
    events = ((_ref = this.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.events : void 0 : void 0) || {};
    eventStr = events.ONRETRIEVE ? 'ONRETRIEVE' : 'ONLOAD';
    rq = Corefw.util.Request;
    url = rq.objsToUrl3(this.eventURLs[eventStr], this.localUrl);
    postData = this.generatePagingPostData(pageNum);
    Corefw.util.Request.sendRequest5(url, rq.processResponseObject, this.uipath, postData);
  },
  generatePostData: function() {
    var postData;
    if (this.forcedSelectedRecord) {
      this.grid.forcedSelectedRecord = this.forcedSelectedRecord;
    }
    postData = this.grid.generatePostData();
    delete this.grid.forcedSelectedRecord;
    return postData;
  },
  onGridClose: function() {
    var rdr;
    rdr = Corefw.util.Render;
    rdr.destroyThisComponent(this);
  },
  statics: {
    createDataCache: function(dataFieldItem, fieldCache) {
      var cm, copyProperties, fieldDataCache, fieldGridArray, gridItem, gridObjAlreadyCreated, item, newKey, newObj, objPropMap, oldKey, oldVal, props, propsData, _i, _len, _ref;
      cm = Corefw.util.Common;
      if (!dataFieldItem) {
        props = fieldCache != null ? fieldCache._myProperties : void 0;
        dataFieldItem = {};
        dataFieldItem.items = props.items;
        dataFieldItem.sortHeaders = props.sortHeaders;
      }
      fieldDataCache = [];
      gridObjAlreadyCreated = false;
      props = fieldCache._myProperties;
      props.data = {};
      propsData = props.data;
      propsData.items = fieldDataCache;
      if (dataFieldItem.sortHeaders) {
        propsData.sortHeaders = dataFieldItem.sortHeaders;
      }
      objPropMap = {
        index: '__index',
        tooltipValue: '__misc'
      };
      copyProperties = ['changed', 'removed', 'new', 'subGrid', 'selected', 'selectable', 'editable', 'validValues', 'cssClass', 'cssClassList', 'cellCssClass', 'messages'];
      if (dataFieldItem.items) {
        _ref = dataFieldItem.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          if (item.items) {
            if (gridObjAlreadyCreated) {
              fieldGridArray = propsData.grid;
            } else {
              gridObjAlreadyCreated = true;
              fieldGridArray = [];
              propsData.grid = fieldGridArray;
            }
            gridItem = cm.objectClone(item);
            fieldGridArray.push(gridItem);
          } else {
            newObj = cm.objectClone(item.value);
            newObj._myProperties = {};
            cm.copyObjProperties(newObj._myProperties, item, copyProperties);
            for (oldKey in objPropMap) {
              newKey = objPropMap[oldKey];
              oldVal = item[oldKey];
              if (typeof oldVal !== 'undefined') {
                if (Ext.isObject(oldVal)) {
                  newObj[newKey] = cm.objectClone(oldVal);
                } else {
                  newObj[newKey] = oldVal;
                }
              }
            }
            fieldDataCache.push(newObj);
          }
        }
      }
    }
  }
});
