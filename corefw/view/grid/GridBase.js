// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.GridBase', {
  extend: 'Ext.grid.Panel',
  mixins: ['Corefw.mixin.Grid'],
  xtype: 'coregridbase',
  defaultDef: {
    lockable: false
  },
  plugins: [
    {
      ptype: 'inlinefilter'
    }, {
      ptype: 'columnselectorplugin'
    }
  ],
  columnLines: true,
  viewConfig: {
    enableTextSelection: true
  },
  coregridbase: true,
  standardRowHeight: 21,
  initComponent: function() {
    var cm, colPlugins, me, _ref, _ref1, _ref2;
    this.columnGroups = {};
    this.enableColumnMove = false;
    colPlugins = ((_ref = this.columns) != null ? _ref.plugins : void 0) || [];
    colPlugins.push('gridheaderreorderer');
    this.columns = this.columns || {};
    cm = Corefw.util.Common;
    Ext.apply(this.columns, {
      defaults: cm.objectClone(this.defaultDef),
      items: [],
      plugins: colPlugins
    });
    me = this;
    this.initalizeGridBase();
    this.addGridListeners();
    this.callParent(arguments);
    this.headerCt.on({
      afterlayout: me.setMinAndMaxHeightToView
    });
    if ((_ref1 = this.lockedGrid) != null) {
      if ((_ref2 = _ref1.view) != null) {
        _ref2.on('viewready', function() {
          me.onViewReady();
        });
      }
    }
    this.syncRowHeight = true;
    delete this.columnGroups;
  },
  addGridListeners: function() {
    var additionalListeners;
    this.listeners = this.listeners || {};
    additionalListeners = {
      beforeedit: this.onGridBeforeEdit,
      edit: this.onGridEdit,
      beforeexpand: this.onGridPanelExpand,
      beforecollapse: this.onGridPanelCollapse,
      resize: this.onGridResize
    };
    Ext.merge(this.listeners, additionalListeners);
    return this.addListeners();
  },
  onGridBeforeEdit: function(evt, cell) {
    var keyValObj, radiogroup, radiogroups, _i, _len;
    radiogroups = Ext.ComponentQuery.query('radiogroup');
    keyValObj = {};
    for (_i = 0, _len = radiogroups.length; _i < _len; _i++) {
      radiogroup = radiogroups[_i];
      keyValObj[radiogroup.name] = cell.grid.getStore().getAt(cell.rowIdx).get(radiogroup.name);
      radiogroup.reset();
      radiogroup.setValue(keyValObj);
    }
  },
  onGridEdit: function(evt, cell) {
    var grid, radiogroup, radiogroups, _i, _len;
    radiogroups = Ext.ComponentQuery.query('radiogroup');
    grid = cell.grid;
    for (_i = 0, _len = radiogroups.length; _i < _len; _i++) {
      radiogroup = radiogroups[_i];
      if (radiogroup.getChecked()[0]) {
        grid.getStore().getAt(cell.rowIdx).set(radiogroup.name, radiogroup.getChecked()[0].inputValue);
      }
    }
    grid.styleDecorate();
  },
  onGridPanelCollapse: function() {
    var i, index, itemXtype, len, ref, su, _i, _len, _ref;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      if (!this.header) {
        return;
      }
      ref = this.header.items.items;
      i = 0;
      len = ref.length;
      while (i < len) {
        index = ref[i];
        itemXtype = index.xtype;
        if (itemXtype === 'tool' || itemXtype === 'text') {
          index.show();
        } else {
          index.el.setStyle('display', 'none');
        }
        i++;
      }
    }
    _ref = this.tools;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      index = _ref[_i];
      if (index.xtype === 'tool') {
        index.removeCls('gridexpandCls');
        index.addCls('gridcollapsedCls');
      }
    }
  },
  onGridPanelExpand: function() {
    var i, index, len, ref, su, _i, _len, _ref;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      if (!this.header) {
        return;
      }
      ref = this.header.items.items;
      i = 0;
      len = ref.length;
      while (i < len) {
        index = ref[i];
        index.el.setStyle('display', 'inline-block');
        i++;
      }
    }
    _ref = this.tools;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      index = _ref[_i];
      if (index.xtype === 'tool') {
        index.removeCls('gridcollapsedCls');
        index.addCls('gridexpandCls');
      }
    }
  },
  updateTitle: function(title) {
    var titleLabel;
    titleLabel = this.down('[name=fieldLabel]');
    return titleLabel != null ? titleLabel.setText(title) : void 0;
  },
  onGridResize: function(grid, width, height, oldWidth, oldHeight) {
    var barItems, ctnItems, fillWidth, i, item, items, menu, menuWidth, pageNavCtn, paginationBar, su, titleWidth, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      paginationBar = grid.down('corepagingtoolbar');
      if (width !== oldWidth && paginationBar) {
        items = [];
        menu = grid.queryById('pageMoreBtn').menu;
        barItems = paginationBar.items.items;
        pageNavCtn = menu.child('#pageNavCtn');
        ctnItems = pageNavCtn.items.items;
        fillWidth = (_ref = grid.header.child('tbfill')) != null ? _ref.getWidth() : void 0;
        titleWidth = (_ref1 = grid.header.titleCmp) != null ? _ref1.getWidth() : void 0;
        menuWidth = menu.rendered ? menu.getWidth() : menu.minWidth;
        if (fillWidth === 0 && ctnItems.length === 0) {
          for (_i = 0, _len = barItems.length; _i < _len; _i++) {
            item = barItems[_i];
            if (item.text !== paginationBar.beforePageText && item.itemId !== 'pageMoreBtn') {
              items.push(item);
            }
          }
          for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
            item = items[_j];
            pageNavCtn.add(item);
          }
          pageNavCtn.setVisible(true);
        } else if ((fillWidth + titleWidth) > menuWidth && ctnItems.length > 0) {
          items = ctnItems.slice(0);
          i = 0;
          for (_k = 0, _len2 = items.length; _k < _len2; _k++) {
            item = items[_k];
            if (i < 3) {
              paginationBar.insert(i, item);
            } else {
              paginationBar.insert(i + 1, item);
            }
            i++;
          }
          pageNavCtn.setVisible(false);
        }
        if (menu.isVisible()) {
          menu.showBy(grid.child('header'), 'tr-br', [0, 1]);
        }
      }
    }
  },
  initalizeGridBase: function() {
    var cache, grid, itemsArray, props, su, _ref;
    grid = this;
    su = Corefw.util.Startup;
    cache = this.cache;
    props = cache._myProperties;
    !su.useClassicTheme() && (grid.ui = 'citiriskdatagrid');
    if (su.getThemeVersion() === 2) {
      grid.bodyStyle = {
        borderBottom: '2px solid #656262'
      };
    }
    props.collapsible && (grid.collapsible = grid.titleCollapse = props.collapsible);
    itemsArray = ((_ref = grid.columns) != null ? _ref.items : void 0) || [];
    grid.createColumnsFromCache(itemsArray);
    props.numberOfLockedHeaders > 0 && (this.isLockedView = true);
    this.configurePlugins(props, true);
    if (props.groupField) {
      grid.features = [
        {
          ftype: 'coregroupingsummary',
          groupHeaderTpl: '{name}',
          hideGroupedHeader: true,
          enableGroupingMenu: false,
          showSummaryRow: false
        }
      ];
    }
    if (props.enableTextSelection === void 0) {
      grid.viewConfig.enableTextSelection = false;
    } else {
      grid.viewConfig.enableTextSelection = props.enableTextSelection;
    }
    grid.applyStore(true);
    grid.configSelType();
    grid.hideCollapseTool = true;
  },
  addCloseBtn: function() {
    var clsBtnCfg, me;
    me = this;
    clsBtnCfg = {
      xtype: 'tool',
      type: 'close',
      name: 'close-button',
      tooltip: 'close',
      docked: 'right',
      handler: function() {
        var field;
        field = me.up();
        field.fireEvent('gridclose', field);
      }
    };
    if (this.header) {
      this.header.add(clsBtnCfg);
    }
  },
  afterRender: function() {
    var header, props, su, _ref;
    this.callParent(arguments);
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      header = this.getHeader();
      if (header) {
        header.setHeight(32);
        this.addExpCollBtn();
      }
    }
    if (this.collapsible) {
      this.addSecondTitle();
    }
    props = this.cache._myProperties;
    if ((_ref = this.up()) != null) {
      _ref.enableSelectEvent = true;
    }
    if (props.closable) {
      this.addCloseBtn();
    }
  },
  addExpCollBtn: function() {
    var ExpCollBtn, elementForm, me;
    me = this.up().grid;
    if (!me.header) {
      return;
    }
    elementForm = this.up('coreelementform');
    if (elementForm.collapsible) {
      ExpCollBtn = {
        xtype: 'tool',
        type: 'collapse-' + me.collapseDirection,
        docked: 'right',
        scope: me,
        handler: me.toggleCollapse
      };
      if (me.collapsed) {
        ExpCollBtn.cls = 'gridcollapsedCls';
      } else {
        ExpCollBtn.cls = 'gridexpandCls';
      }
      me.header.add(ExpCollBtn);
    }
  },
  onViewReady: function() {
    var container, me;
    this.callParent(arguments);
    container = this.up('[listenGridViewReady=true]');
    if (container) {
      container.fireEvent('gridviewready');
    }
    me = this;
    Ext.Function.createDelayed(function() {
      return me.restoreHeaderSortState();
    }, 1)();
  },
  addSecondTitle: function() {
    var rdr;
    rdr = Corefw.util.Render;
    rdr.addSecondTitle(this);
  },
  addRowToGrid: function() {
    var field, fields, mod, modArray, newObj, store, _i, _len;
    store = this.store;
    fields = store.getProxy().getModel().getFields();
    newObj = {};
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      newObj[field.name] = '';
    }
    modArray = store.add(newObj);
    if (modArray && modArray.length) {
      mod = modArray[0];
      mod.set('__index', Corefw.util.Data.getMaxIndex1(store));
    }
    this.getView().scrollBy(0, 999, false);
  },
  deleteRowsFromGrid: function() {
    var selected, store;
    store = this.store;
    selected = this.selModel.selected;
    return selected.each(function(model) {
      store.remove(model);
    });
  },
  setSelection: function() {
    var i, len, props, record, selectArray, st, _i;
    selectArray = [];
    st = this.store;
    len = st.getCount();
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      record = st.getAt(i);
      props = record.get('_myProperties');
      if (props && props.selected) {
        selectArray.push(record);
      }
    }
    if (selectArray.length) {
      this.getSelectionModel().select(selectArray, false, true);
    }
  },
  isColumnInSortHeader: function(columnDataIndex) {
    var header, sortHeaders, _i, _len, _ref;
    sortHeaders = (_ref = this.cache._myProperties) != null ? _ref.sortHeaders : void 0;
    for (_i = 0, _len = sortHeaders.length; _i < _len; _i++) {
      header = sortHeaders[_i];
      if (header.index + '' === columnDataIndex) {
        return true;
      }
    }
    return false;
  },
  createStore: function() {
    var bufferZone, cache, column, columnAr, columnType, dataIndex, dataItems, fieldObj, fields, groupField, groupIndex, me, pageSize, props, proxy, reader, requestUrl, st, storeConfig, storeDataAr, storeFieldObj, storeId, type, uipath, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    cache = this.cache;
    props = cache._myProperties;
    pageSize = props.pageSize;
    bufferZone = 0;
    uipath = props.uipath;
    storeId = uipath + '/Store';
    dataItems = props != null ? (_ref = props.data) != null ? _ref.items : void 0 : void 0;
    if (!dataItems) {
      return;
    }
    this.prepareFieldObj();
    storeDataAr = [];
    fields = [];
    columnAr = props.columnAr;
    groupIndex;
    me = this;
    groupField = props.groupField;
    requestUrl = this.getRequestUrl();
    if (groupField) {
      proxy = {
        type: 'ajax'
      };
      for (_i = 0, _len = columnAr.length; _i < _len; _i++) {
        column = columnAr[_i];
        if (column._myProperties.pathString === groupField) {
          groupIndex = column._myProperties.index.toString();
          break;
        }
      }
    }
    storeConfig = {
      autoDestroy: false,
      fields: fields,
      storeId: storeId,
      data: storeDataAr,
      remoteSort: true,
      groupField: groupIndex,
      proxy: proxy,
      sort: function(sorters) {
        var dataIndex, grid, header, sortHeaders, sorts, _j, _len1, _ref1;
        sorts = [];
        if (me.isColumnInSortHeader(sorters.property)) {
          sortHeaders = (_ref1 = me.cache._myProperties) != null ? _ref1.sortHeaders : void 0;
          for (_j = 0, _len1 = sortHeaders.length; _j < _len1; _j++) {
            header = sortHeaders[_j];
            dataIndex = header.index + '';
            if (dataIndex !== sorters.property) {
              sorts.push({
                property: header.dataIndex,
                direction: header.sortBy
              });
            } else {
              sorts.push(sorters);
            }
          }
        } else {
          sorts.push(sorters);
        }
        grid = Ext.ComponentQuery.query('[uipath=' + uipath + ']')[0].grid;
        grid.sort(sorts);
      }
    };
    if (props.infinity) {
      reader = Ext.create('Corefw.data.reader.Json', {
        root: 'items',
        rootProperty: 'items',
        totalProperty: 'totalRows',
        jsonResolver: function(responseJson) {
          var items, result, totalRows;
          totalRows = responseJson.totalRows || 0;
          items = responseJson.items || [];
          items = items.map(function(item) {
            return item.value;
          });
          result = {
            totalRows: totalRows,
            items: items
          };
          return result;
        }
      });
      proxy = {
        type: 'coreajax',
        url: requestUrl,
        reader: reader,
        paramsAsJson: true,
        simpleSortMode: false,
        limitParam: 'pageSize',
        sortParam: 'sortHeaders',
        pageParam: 'currentPage',
        extraParams: {
          retriveItemSize: pageSize,
          scrollStr: 'INITIAL'
        },
        actionMethods: {
          create: 'POST',
          read: 'POST',
          update: 'POST',
          destroy: 'POST'
        }
      };
      storeConfig = {
        autoDestroy: false,
        pageSize: pageSize,
        fields: fields,
        storeId: storeId,
        buffered: true,
        autoLoad: true,
        remoteSort: true,
        groupField: groupIndex,
        proxy: proxy,
        model: 'ForumThread',
        remoteGroup: true,
        leadingBufferZone: bufferZone,
        trailingBufferZone: bufferZone,
        decodeSorters: function(sorters) {
          var Sorter, config, content, contents, field, grid, i, length, parent, parentProps, sorter, _j, _k, _len1, _len2;
          if (!Ext.isArray(sorters)) {
            if (sorters === undefined) {
              sorters = [];
            } else {
              sorters = [sorters];
            }
          }
          grid = Ext.ComponentQuery.query('[uipath=' + uipath + ']')[0].grid;
          parent = grid.up('fieldcontainer');
          parentProps = parent.cache._myProperties;
          contents = parentProps.allContents;
          for (_j = 0, _len1 = sorters.length; _j < _len1; _j++) {
            sorter = sorters[_j];
            for (_k = 0, _len2 = contents.length; _k < _len2; _k++) {
              content = contents[_k];
              if (content.index + '' === sorter.property) {
                sorter.name = content.name;
              }
            }
          }
          length = sorters.length;
          Sorter = Ext.util.Sorter;
          fields = (this.model ? this.model.prototype.fields : null);
          field = void 0;
          config = void 0;
          i = void 0;
          i = 0;
          while (i < length) {
            config = sorters[i];
            if (!(config instanceof Sorter)) {
              if (Ext.isString(config)) {
                config = {
                  property: config
                };
              }
              Ext.applyIf(config, {
                root: this.sortRoot,
                direction: 'ASC'
              });
              if (config.fn) {
                config.sorterFn = config.fn;
              }
              if (typeof config === 'function') {
                config = {
                  sorterFn: config
                };
              }
              if (fields && !config.transform) {
                field = fields.get(config.property);
                config.transform = (field && field.sortType !== Ext.identityFn ? field.sortType : undefined);
              }
              sorters[i] = new Ext.util.Sorter(config);
            }
            i++;
          }
          return sorters;
        },
        listeners: {
          groupchange: function(store, groupers) {
            var headers, i, len, sortable, _results;
            sortable = !store.isGrouped();
            headers = grid.headerCt.getVisibleGridColumns();
            i = void 0;
            len = headers.length;
            i = 0;
            _results = [];
            while (i < len) {
              headers[i].sortable = (headers[i].sortable !== undefined ? headers[i].sortable : sortable);
              _results.push(i++);
            }
            return _results;
          },
          beforeprefetch: function(store, operation) {
            if (operation.groupers && operation.groupers.length) {
              return delete operation.sorters;
            }
          }
        }
      };
    }
    if (dataItems && Ext.isArray(dataItems) && columnAr && columnAr.length) {
      fieldObj = this.fieldObj;
      for (_j = 0, _len1 = columnAr.length; _j < _len1; _j++) {
        column = columnAr[_j];
        props = column._myProperties;
        dataIndex = props.index + '';
        storeFieldObj = {
          name: dataIndex
        };
        type = (_ref1 = fieldObj[dataIndex]) != null ? (_ref2 = _ref1.type) != null ? _ref2.toLowerCase() : void 0 : void 0;
        columnType = (_ref3 = fieldObj[dataIndex]) != null ? (_ref4 = _ref3.columnType) != null ? _ref4.toLowerCase() : void 0 : void 0;
        storeFieldObj.columnType = columnType;
        if (type === 'date' || columnType === 'date' || columnType === 'datetime') {
          storeFieldObj.type = 'date';
        }
        fields.push(storeFieldObj);
      }
      if (!props.infinity) {
        this.parseData(dataItems, storeDataAr, fieldObj);
      }
    }
    fields.push({
      name: '_myProperties'
    }, {
      name: '__index'
    });
    st = Ext.create('Ext.data.Store', storeConfig);
    return st;
  },
  applyStore: function(shouldRecreate) {
    var myStore, uipath, _ref;
    this.skipCancelEditing = true;
    uipath = (_ref = this.cache) != null ? _ref._myProperties.uipath : void 0;
    myStore = Ext.StoreManager.lookup(uipath + '/Store');
    if (shouldRecreate && myStore) {
      Ext.StoreManager.remove(myStore);
      myStore = null;
      this.store = null;
    }
    if (!this.storeAlreadyAttached && !this.store && !myStore) {
      myStore = this.createStore();
    } else {
      this.updateStore(myStore);
    }
    this.store = myStore;
    delete this.skipCancelEditing;
  },
  updateFromCache: function(cache) {
    var isEditing;
    this.cache = this.updateCache(cache);
    if (typeof this.shouldReconfigure === "function" ? this.shouldReconfigure() : void 0) {
      if (typeof this.reconfigureGrid === "function") {
        this.reconfigureGrid();
      }
    } else {
      isEditing = this.isEditing;
      this.applyStore();
      if (isEditing) {
        this.isEditing = true;
        this.restoreGridEditor();
      }
    }
  },
  updateStoreFromCache: function(cache) {
    var paginationBar, res;
    this.cache = this.updateCache(cache);
    this.applyStore();
    res = this.validateColumnOrdersFromCache();
    if (!res.isValid) {
      this.reconfigure(this.store, res.columnsDef);
    }
    paginationBar = this.down('corepagingtoolbar');
    if (paginationBar != null) {
      paginationBar.onLoad();
    }
  },
  cacheScrollValue: function() {
    var el, me, result, scroll, scrollValues, scrolledDescendants, _ref, _ref1, _ref2, _ref3;
    me = this;
    scrolledDescendants = [];
    scrollValues = [];
    result = function() {
      var el, i, _i, _len;
      for (i = _i = 0, _len = scrolledDescendants.length; _i < _len; i = ++_i) {
        el = scrolledDescendants[i];
        el.setScrollLeft(scrollValues[i][0]);
        el.setScrollTop(scrollValues[i][1]);
      }
    };
    if (this.lockable) {
      el = (_ref = this.view) != null ? (_ref1 = _ref.lockedView) != null ? _ref1.el : void 0 : void 0;
      if (el) {
        scroll = el.getScroll();
        scrolledDescendants[0] = el;
        scrollValues[0] = [scroll.left, scroll.top];
      }
      el = (_ref2 = this.view) != null ? (_ref3 = _ref2.normalView) != null ? _ref3.el : void 0 : void 0;
      if (el) {
        scroll = el.getScroll();
        scrolledDescendants[1] = el;
        scrollValues[1] = [scroll.left, scroll.top];
      }
    } else {
      el = this.view.el;
      if (el) {
        scroll = el.getScroll();
        scrolledDescendants[0] = el;
        scrollValues[0] = [scroll.left, scroll.top];
      }
    }
    return result;
  },
  updateStore: function(store) {
    var cache, dataItems, fieldObj, props, storeDataAr, _ref;
    cache = this.cache;
    props = cache._myProperties;
    fieldObj = this.getFieldObj(props.uipath);
    dataItems = props != null ? (_ref = props.data) != null ? _ref.items : void 0 : void 0;
    if (!dataItems) {
      return;
    }
    storeDataAr = [];
    this.parseData(dataItems, storeDataAr, fieldObj);
    this.view.preserveScrollOnRefresh = true;
    store.loadRawData(storeDataAr);
    if (props.totalRows) {
      store.totalCount = props.totalRows;
    }
    if (props.currentPage) {
      store.currentPage = props.currentPage;
    }
  },
  restoreGridEditor: function() {
    if (this.rowEditor) {
      this.rowEditor.isSkipBeforeEdit = true;
      this.rowEditor.restoreEditor();
      return this.rowEditor.isSkipBeforeEdit = false;
    }
  },
  sort: function(sorters) {
    var content, contents, parent, parentProps, postData, sortHeaders, sorter, _i, _j, _len, _len1;
    if (!Ext.isArray(sorters)) {
      sorters = [sorters];
    }
    parent = this.up('fieldcontainer');
    parentProps = parent.cache._myProperties;
    sortHeaders = [];
    if (parentProps.events['ONRETRIEVE']) {
      postData = this.generatePostDataForRetrieve();
    } else {
      postData = this.generatePostData();
    }
    contents = parentProps.allContents;
    for (_i = 0, _len = sorters.length; _i < _len; _i++) {
      sorter = sorters[_i];
      for (_j = 0, _len1 = contents.length; _j < _len1; _j++) {
        content = contents[_j];
        if (content.index + '' === sorter.property) {
          sortHeaders.push({
            name: content.name,
            sortBy: sorter.direction
          });
        }
      }
    }
    postData.sortHeaders = sortHeaders;
    this.storeScrollbarPosition();
    this.remoteLoadStoreData(postData);
  },
  storeScrollbarPosition: function() {
    var iv, uipath, view;
    iv = Corefw.util.InternalVar;
    view = this.getView();
    if (view.normalView) {
      uipath = view.normalView.up('coreobjectgrid').uipath;
      iv.setByUipathProperty(uipath, 'gridscroll_normal_left', view.normalView.el.getScroll().left);
      return iv.setByUipathProperty(uipath, 'gridscroll_locked_left', view.lockedView.el.getScroll().left);
    } else {
      uipath = view.up('coreobjectgrid').uipath;
      return iv.setByUipathProperty(uipath, 'gridscroll_left', view.el.getScroll().left);
    }
  },
  reStoreScrollbarPosition: function() {},
  getColumnIndex: function(colComp) {
    var businessColumns, column, columns, _i, _len;
    if (colComp.isGroupHeader) {
      colComp = colComp.down(':not([isGroupHeader])');
    }
    columns = this.getView().getGridColumns();
    businessColumns = [];
    for (_i = 0, _len = columns.length; _i < _len; _i++) {
      column = columns[_i];
      if (column.uipath) {
        businessColumns.push(column);
      }
    }
    return Ext.Array.indexOf(businessColumns, colComp);
  },
  generatePagingPostData: function() {},
  generatePostData: function() {
    var ExtDate, cm, fetchValue, forcedSelectRec, i, items, len, lineBreakExists, me, mod, modelToRowObj, postData, props, removedRows, rowObj, selected, st, storeFields, storeModel, _i, _j, _ref, _ref1;
    props = this.cache._myProperties;
    selected = this.selModel.selected;
    postData = {
      name: props.name
    };
    me = this;
    items = [];
    postData.items = items;
    postData.allContents = me.generateHeadersPostData(me.cache);
    cm = Corefw.util.Common;
    ExtDate = Ext.Date;
    delete me.editingCell;
    forcedSelectRec = this.forcedSelectedRecord;
    fetchValue = function(item) {
      if (Ext.isObject(item)) {
        return item.value;
      }
      return item;
    };
    modelToRowObj = function(inputModel) {
      var brExists, field, retRowObj, val, vals, values, _i, _len, _ref;
      brExists = /<br>/g;
      cm = Corefw.util.Common;
      retRowObj = {};
      values = {};
      retRowObj.value = values;
      if (forcedSelectRec) {
        if (forcedSelectRec === inputModel) {
          retRowObj.selected = true;
        } else {
          retRowObj.selected = false;
        }
      } else {
        if (selected.contains(mod)) {
          retRowObj.selected = true;
        } else {
          retRowObj.selected = false;
        }
      }
      for (_i = 0, _len = storeFields.length; _i < _len; _i++) {
        field = storeFields[_i];
        if ((_ref = field.name) === 'id' || _ref === '_myProperties' || _ref === '__tooltipValue') {
          continue;
        }
        val = mod.get(field.name);
        if (typeof val === 'string' && lineBreakExists) {
          val = val.replace(brExists, '\n');
        }
        if (field.name === '__index') {
          retRowObj.index = val;
        } else if (val && /^(date|datetime|month_picker)$/.test(field.columnType)) {
          val = val.valueOf();
        } else if (field.columnType === 'datestring' && val) {
          val = ExtDate.format(val, 'Y-m-d H:i:s');
        }
        if (val === null || val === void 0) {
          values[field.name] = '';
          continue;
        }
        if (Ext.isArray(val)) {
          vals = [];
          Ext.each(val, function(item) {
            vals.push(fetchValue(item));
          });
          values[field.name] = vals;
        } else {
          values[field.name] = fetchValue(val);
        }
      }
      if (!retRowObj.index && retRowObj.index !== 0) {
        retRowObj.index = inputModel.index;
      }
      return retRowObj;
    };
    st = this.getStore();
    len = st.getCount();
    storeModel = st.getProxy().getModel();
    storeFields = storeModel.getFields();
    if (len) {
      for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
        mod = st.getAt(i);
        lineBreakExists = mod != null ? (_ref = mod.data) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.lineBreakExists : void 0 : void 0 : void 0;
        rowObj = modelToRowObj(mod);
        rowObj.editing = mod.isEditing ? true : false;
        rowObj["new"] = mod.phantom ? true : false;
        rowObj.changed = mod.dirty ? true : false;
        rowObj.removed = false;
        delete rowObj.value.__index;
        items.push(rowObj);
      }
    }
    removedRows = st.removed;
    len = removedRows.length;
    if (len) {
      for (i = _j = 0; 0 <= len ? _j < len : _j > len; i = 0 <= len ? ++_j : --_j) {
        mod = removedRows[i];
        rowObj = modelToRowObj(mod);
        rowObj["new"] = false;
        rowObj.changed = true;
        rowObj.removed = true;
        items.push(rowObj);
      }
    }
    return postData;
  },
  getCellInLockedView: function(record, column) {
    var row, _ref;
    row = typeof this !== "undefined" && this !== null ? (_ref = this.view) != null ? _ref.lockedView.getNode(record, true) : void 0 : void 0;
    if (!row || !column) {
      return;
    }
    return Ext.fly(row).down(column.getCellSelector());
  },
  updateItemDecorate: function(record) {
    var cell, cellCssClassObj, cellProp, cellProps, col, cssClass, dataIndex, errMsg, errorMsgs, node, nodeCmp, oneErrMsg, props, row, rowEl, toolAr, tooltip, tooltipData, view, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    view = this.getView();
    props = record.raw._myProperties;
    if (props) {
      errorMsgs = (_ref = props.messages) != null ? _ref.ERROR : void 0;
      tooltipData = props.tooltipValue;
      cssClass = ((_ref1 = props.cssClassList) != null ? _ref1.length : void 0) ? props.cssClassList : props.cssClass;
      cellCssClassObj = props.cellCssClass;
      row = view.getNode(record, true);
      rowEl = Ext.get(row);
      _ref2 = this.columns;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        col = _ref2[_i];
        cell = rowEl.down(col.getCellSelector());
        if (cell) {
          if (cell.hasCls('x-grid-cell-error')) {
            cell.removeCls('x-grid-cell-error');
          }
          if (cell.isTooltipCreated) {
            toolAr = Ext.ComponentQuery.query('tooltip[targetId=' + cell.id + ']');
            for (_j = 0, _len1 = toolAr.length; _j < _len1; _j++) {
              tooltip = toolAr[_j];
              tooltip.destroy();
            }
            cell.isTooltipCreated = false;
          }
          if (errorMsgs && errorMsgs[col.pathString]) {
            errMsg = errorMsgs[col.pathString];
            oneErrMsg = errMsg.join(';');
            cell.addCls('x-grid-cell-error');
            cell.isTooltipCreated = true;
            Ext.create('Ext.tip.ToolTip', {
              target: cell.id,
              targetId: cell.id,
              html: oneErrMsg + '\n<br>',
              ui: 'form-invalid'
            });
          } else if (tooltipData && tooltipData[col.pathString]) {
            cell.dom.tooltip = tooltipData[col.pathString].tooltip;
          }
        }
        if (cellCssClassObj && cellCssClassObj[col.pathString]) {
          if (!cell && view.lockedView) {
            cell = this.getCellInLockedView(record, col);
          }
          if (cell) {
            cell.addCls(cellCssClassObj[col.pathString]);
          }
        }
      }
      if (cssClass != null) {
        node = view.getNode(record, true);
        nodeCmp = Ext.get(node);
        if (nodeCmp != null) {
          nodeCmp.addCls(cssClass);
        }
      }
    } else {
      cellProps = record.raw.__misc._myProperties.cells;
      if (cellProps) {
        row = view.getNode(record, true);
        rowEl = Ext.get(row);
        for (dataIndex in cellProps) {
          cellProp = cellProps[dataIndex];
          if (dataIndex === '_myProperties') {
            continue;
          }
          col = this.down('[dataIndex=' + dataIndex + ']');
          cell = rowEl.down(col.getCellSelector());
          if (cellProp && cell) {
            cssClass = ((_ref3 = cellProp.cssClassList) != null ? _ref3.length : void 0) ? cellProp.cssClassList : cellProp.cssClass;
            if (cssClass) {
              cell.addCls(cellProp.cssClass);
            }
          }
        }
      }
    }
  },
  styleDecorate: function() {
    var cell, cellCssClass, cellCssClassObj, cellProp, cellProps, col, cssClass, dataIndex, errMsg, errorMsgs, item, items, node, nodeCmp, oneErrMsg, pathString, props, record, store, view, _i, _len, _ref, _ref1, _ref2;
    store = this.getStore();
    if (store.data) {
      items = store.data.items || [];
      view = this.getView();
      for (_i = 0, _len = items.length; _i < _len; _i++) {
        item = items[_i];
        props = item.raw._myProperties;
        if (props) {
          errorMsgs = (_ref = props.messages) != null ? _ref.ERROR : void 0;
          cssClass = ((_ref1 = props.cssClassList) != null ? _ref1.length : void 0) ? props.cssClassList : props.cssClass;
          for (pathString in errorMsgs) {
            errMsg = errorMsgs[pathString];
            oneErrMsg = errMsg.join(';');
            col = this.down('[pathString=' + pathString + ']');
            record = view.getRecord(item);
            if (!record) {
              continue;
            }
            cell = view.getCell(record, col);
            cell.addCls('x-grid-cell-error');
            cell.isTooltipCreated = true;
            Ext.create('Ext.tip.ToolTip', {
              target: cell.id,
              targetId: cell.id,
              html: oneErrMsg + '\n<br>',
              ui: 'form-invalid'
            });
          }
          if (cssClass != null) {
            node = view.getNode(item, true);
            nodeCmp = Ext.get(node);
            if (nodeCmp != null) {
              nodeCmp.addCls(cssClass);
            }
          }
          cellCssClassObj = props.cellCssClass;
          if (cellCssClassObj) {
            for (pathString in cellCssClassObj) {
              cellCssClass = cellCssClassObj[pathString];
              col = this.down('[pathString=' + pathString + ']');
              cell = view.getCell(item, col);
              if (!cell && view.lockedView) {
                cell = this.getCellInLockedView(item, col);
              }
              if (cell) {
                cell.addCls(cellCssClass);
              }
            }
          }
        } else {
          cellProps = item.raw.__misc._myProperties.cells;
          if (cellProps) {
            for (dataIndex in cellProps) {
              cellProp = cellProps[dataIndex];
              if (dataIndex === '_myProperties') {
                continue;
              }
              col = this.down('[dataIndex=' + dataIndex + ']');
              cell = view.getCell(item, col);
              if (cellProp) {
                cssClass = ((_ref2 = cellProp.cssClassList) != null ? _ref2.length : void 0) ? cellProp.cssClassList : cellProp.cssClass;
                if (cssClass && cell) {
                  cell.addCls(cellProp.cssClass);
                }
              }
            }
          }
        }
      }
    }
    if (!Ext.isEmpty(this.lockedGrid)) {
      if (typeof this.syncRowHeights === "function") {
        this.syncRowHeights();
      }
    }
  }
});
