// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.AllocGrid', {
  extend: 'Ext.form.FieldContainer',
  xtype: 'coreallocgrid',
  rowItemWidth: 100,
  AvailAmtWidth: 130,
  topHeaderItemWidth: 130,
  pathProp: null,
  layout: {
    type: 'vbox',
    align: 'stretch'
  },
  defaults: {
    xtype: 'container',
    layout: {
      type: 'hbox',
      align: 'stretch'
    },
    defaults: {
      xtype: 'container'
    }
  },
  items: [
    {
      items: [
        {
          itemId: 'topcorner'
        }, {
          flex: 1,
          itemId: 'topheader'
        }
      ]
    }, {
      flex: 1,
      items: [
        {
          itemId: 'leftheader'
        }, {
          flex: 1,
          itemId: 'cellarea',
          layout: 'auto',
          overflowX: 'auto',
          overflowY: 'auto'
        }
      ]
    }
  ],
  statics: {
    createDataCache: function(dataFieldItem, fieldCache) {
      fieldCache._myProperties.data = dataFieldItem;
    }
  },
  initComponent: function() {
    this.disableStoreEvents = true;
    this.callParent(arguments);
  },
  afterRender: function() {
    this.pathProp = 'pathString';
    this.callParent(arguments);
    this.topcorner = Ext.ComponentQuery.query('#topcorner')[0];
    this.leftheader = Ext.ComponentQuery.query('#leftheader')[0];
    this.topheader = Ext.ComponentQuery.query('#topheader')[0];
    this.cellarea = Ext.ComponentQuery.query('#cellarea')[0];
    this.configureTopCornerGrid();
    this.configureTopHeaderGrid();
  },
  configureTopCornerGrid: function() {
    var col, colName, colObj, columnItems, dataObj, fieldObj, grid, gridColumns, gridConfig, index, me, myFunc, props, row, rowItems, st, storeConfig, storeDataAr, storeFieldAr, _i, _j, _len, _len1;
    props = this.cache._myProperties;
    rowItems = props.rowGrid.allContents;
    columnItems = props.columnGrid.allContents;
    gridColumns = [];
    storeFieldAr = [];
    storeDataAr = [];
    index = 0;
    for (_i = 0, _len = rowItems.length; _i < _len; _i++) {
      row = rowItems[_i];
      colName = 'c' + index;
      colObj = {
        text: colName,
        dataIndex: colName,
        flex: 1
      };
      gridColumns.push(colObj);
      fieldObj = {
        name: colName
      };
      storeFieldAr.push(fieldObj);
      index++;
    }
    colObj = {
      text: 'colLast',
      dataIndex: 'colLast',
      align: 'right',
      width: this.AvailAmtWidth
    };
    gridColumns.push(colObj);
    fieldObj = {
      name: 'colLast'
    };
    storeFieldAr.push(fieldObj);
    this.topHeaderPathArray = [];
    index = 0;
    for (_j = 0, _len1 = columnItems.length; _j < _len1; _j++) {
      col = columnItems[_j];
      dataObj = {};
      dataObj.colLast = col.title;
      storeDataAr.push(dataObj);
      this.topHeaderPathArray.push(col[this.pathProp]);
      index++;
    }
    dataObj = {};
    dataObj.colLast = 'Uncovered Amount';
    storeDataAr.push(dataObj);
    storeConfig = {
      fields: storeFieldAr,
      data: storeDataAr
    };
    st = Ext.create('Ext.data.Store', storeConfig);
    gridConfig = {
      header: false,
      viewConfig: {
        stripeRows: false
      },
      enableColumnMove: false,
      enableColumnHide: false,
      sortableColumns: false,
      hideHeaders: true,
      columns: gridColumns,
      store: st
    };
    gridConfig.width = rowItems.length * this.rowItemWidth + this.AvailAmtWidth;
    grid = Ext.create('Ext.grid.Panel', gridConfig);
    this.topcornerGrid = grid;
    this.topcorner.add(grid);
    me = this;
    myFunc = Ext.Function.createDelayed(function() {
      me.leftWidth = grid.width;
      me.topcorner.setWidth(me.leftWidth);
      me.leftheader.setWidth(me.leftWidth);
      return me.configureLeftHeaderGrid();
    }, 1);
    myFunc();
  },
  cellRenderer: function(value, cell, row, rowIndex, colIndex) {
    cell.style = 'height: 27px;';
    return value;
  },
  configureLeftHeaderGrid: function() {
    var cm, colObj, dataObj, field, fieldObj, grid, gridColumns, gridConfig, index, lastColIndex, lastFieldName, me, myFunc, props, row, rowData, rowDataItems, rowItems, st, storeConfig, storeDataAr, storeFieldAr, xtraConfig, _i, _j, _len, _len1;
    cm = Corefw.util.Common;
    props = this.cache._myProperties;
    rowDataItems = props.rowGrid.items;
    rowItems = props.rowGrid.allContents;
    storeFieldAr = [];
    storeDataAr = [];
    gridColumns = [];
    index = 0;
    for (_i = 0, _len = rowItems.length; _i < _len; _i++) {
      row = rowItems[_i];
      colObj = {
        dataIndex: row[this.pathProp],
        text: row.title,
        padding: '0 5 0 0'
      };
      if (!index) {
        colObj.renderer = this.cellRenderer;
      }
      gridColumns.push(colObj);
      fieldObj = {
        name: row[this.pathProp]
      };
      storeFieldAr.push(fieldObj);
      index++;
    }
    lastColIndex = gridColumns.length - 1;
    colObj = gridColumns[lastColIndex];
    xtraConfig = {
      xtype: 'numbercolumn',
      format: '0,000.00',
      align: 'right'
    };
    Ext.apply(colObj, xtraConfig);
    this.leftheaderTotalColumn = colObj.dataIndex;
    colObj = {
      dataIndex: 'AvailAmt',
      text: 'Available Amount',
      padding: '0 5 0 0',
      width: this.AvailAmtWidth
    };
    Ext.apply(colObj, xtraConfig);
    gridColumns.push(colObj);
    field = storeFieldAr[lastColIndex];
    field.type = 'float';
    lastFieldName = field.name;
    fieldObj = {
      name: 'AvailAmt',
      type: 'float'
    };
    storeFieldAr.push(fieldObj);
    for (_j = 0, _len1 = rowDataItems.length; _j < _len1; _j++) {
      rowData = rowDataItems[_j];
      dataObj = cm.objectClone(rowData.value);
      dataObj.AvailAmt = dataObj[lastFieldName];
      storeDataAr.push(dataObj);
    }
    storeConfig = {
      fields: storeFieldAr,
      data: storeDataAr
    };
    st = Ext.create('Ext.data.Store', storeConfig);
    gridConfig = {
      header: false,
      enableColumnResize: false,
      enableColumnMove: false,
      enableColumnHide: false,
      sortableColumns: false,
      columnLines: true,
      columns: gridColumns,
      store: st
    };
    grid = Ext.create('Ext.grid.Panel', gridConfig);
    this.leftheaderGrid = grid;
    me = this;
    myFunc = Ext.Function.createDelayed(function() {
      me.leftheader.add(grid);
      return me.leftheader.setWidth(me.leftWidth);
    }, 1);
    myFunc();
  },
  configureTopHeaderGrid: function() {
    var col, colName, colObj, colPath, columnDataItems, columnItems, dataObj, fieldObj, grid, gridColumns, gridConfig, index, me, myFunc, pathIndex, pathLen, props, row, st, storeConfig, storeDataAr, storeFieldAr, topHeaderPathArray, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    props = this.cache._myProperties;
    columnDataItems = props.columnGrid.items;
    columnItems = props.columnGrid.allContents;
    topHeaderPathArray = this.topHeaderPathArray;
    pathLen = topHeaderPathArray.length;
    storeFieldAr = [];
    storeDataAr = [];
    gridColumns = [];
    for (_i = 0, _len = topHeaderPathArray.length; _i < _len; _i++) {
      row = topHeaderPathArray[_i];
      dataObj = {};
      storeDataAr.push(dataObj);
    }
    dataObj = {};
    storeDataAr.push(dataObj);
    for (_j = 0, _len1 = columnItems.length; _j < _len1; _j++) {
      col = columnItems[_j];
      if (col.valueType === "class java.lang.Double") {
        this.topheaderTotalColumn = col[this.pathProp];
        break;
      }
    }
    index = 0;
    for (_k = 0, _len2 = columnDataItems.length; _k < _len2; _k++) {
      col = columnDataItems[_k];
      colName = 'c' + index;
      colObj = {
        text: colName,
        dataIndex: colName,
        align: 'center',
        flex: 1
      };
      gridColumns.push(colObj);
      fieldObj = {
        name: colName
      };
      storeFieldAr.push(fieldObj);
      pathIndex = 0;
      for (_l = 0, _len3 = topHeaderPathArray.length; _l < _len3; _l++) {
        colPath = topHeaderPathArray[_l];
        dataObj = storeDataAr[pathIndex];
        dataObj[colName] = col.value[colPath];
        pathIndex++;
      }
      dataObj = storeDataAr[pathLen];
      dataObj[colName] = col.value[colPath];
      index++;
    }
    storeConfig = {
      fields: storeFieldAr,
      data: storeDataAr
    };
    st = Ext.create('Ext.data.Store', storeConfig);
    gridConfig = {
      header: false,
      enableColumnResize: false,
      enableColumnMove: false,
      enableColumnHide: false,
      sortableColumns: false,
      columnLines: true,
      hideHeaders: true,
      columns: gridColumns,
      store: st
    };
    gridConfig.width = columnDataItems.length * this.topHeaderItemWidth;
    grid = Ext.create('Ext.grid.Panel', gridConfig);
    this.topheaderGrid = grid;
    this.topheader.add(grid);
    me = this;
    myFunc = Ext.Function.createDelayed(function() {
      return me.configureCellGrid();
    }, 1);
    myFunc();
  },
  configureCellGrid: function() {
    var col, colName, colObj, columnDataItems, columnDataLen, dataObj, editorConfig, fieldObj, grid, gridColumns, gridConfig, i, index, me, props, row, rowDataItems, st, storeConfig, storeDataAr, storeFieldAr, _i, _j, _k, _len, _len1;
    me = this;
    props = this.cache._myProperties;
    rowDataItems = props.rowGrid.items;
    columnDataItems = props.columnGrid.items;
    columnDataLen = columnDataItems.length;
    storeFieldAr = [];
    storeDataAr = [];
    gridColumns = [];
    index = 0;
    for (_i = 0, _len = columnDataItems.length; _i < _len; _i++) {
      col = columnDataItems[_i];
      colName = 'c' + index;
      colObj = {
        xtype: 'corecheckcolumn',
        dataIndex: 'b' + index,
        width: 28
      };
      gridColumns.push(colObj);
      fieldObj = {
        name: 'b' + index
      };
      storeFieldAr.push(fieldObj);
      editorConfig = {
        xtype: 'numberfield',
        hideTrigger: true,
        keyNavEnabled: false,
        mouseWheelEnabled: false
      };
      colObj = {
        xtype: 'numbercolumn',
        dataIndex: 'p' + index,
        align: 'left',
        format: '0.00%',
        width: 60,
        text: '',
        editor: editorConfig
      };
      gridColumns.push(colObj);
      fieldObj = {
        name: 'p' + index
      };
      storeFieldAr.push(fieldObj);
      colObj = {
        xtype: 'numbercolumn',
        dataIndex: colName,
        align: 'right',
        format: '0,000.00',
        flex: 1,
        header: '',
        editor: editorConfig
      };
      gridColumns.push(colObj);
      fieldObj = {
        name: colName
      };
      storeFieldAr.push(fieldObj);
      if (!index) {
        colObj.renderer = this.cellRenderer;
      }
      index++;
    }
    for (_j = 0, _len1 = rowDataItems.length; _j < _len1; _j++) {
      row = rowDataItems[_j];
      dataObj = {};
      for (i = _k = 0; 0 <= columnDataLen ? _k < columnDataLen : _k > columnDataLen; i = 0 <= columnDataLen ? ++_k : --_k) {
        colName = 'b' + i;
        dataObj[colName] = true;
      }
      storeDataAr.push(dataObj);
    }
    storeConfig = {
      fields: storeFieldAr,
      data: storeDataAr,
      listeners: {
        update: function(st, record, operation, modifiedFields) {
          me.onCellStoreUpdate(st, record, operation, modifiedFields);
        }
      }
    };
    st = Ext.create('Ext.data.Store', storeConfig);
    gridConfig = {
      header: false,
      plugins: [
        Ext.create('Ext.grid.plugin.CellEditing', {
          clicksToEdit: 1
        })
      ],
      enableColumnResize: false,
      enableColumnMove: false,
      enableColumnHide: false,
      sortableColumns: false,
      columns: gridColumns,
      store: st
    };
    gridConfig.width = columnDataItems.length * this.topHeaderItemWidth;
    grid = Ext.create('Ext.grid.Panel', gridConfig);
    this.cellGrid = grid;
    this.cellarea.add(grid);
    this.fillCellGridStore();
    this.updateTopHeaderTotalAll();
  },
  fillCellGridStore: function() {
    var cell, cellDataItems, cellItems, cellPath, colDataItems, colLen, colNum, i, props, rowDataItems, rowLen, rowNum, st, _i, _j, _k, _l, _len, _len1, _m;
    props = this.cache._myProperties;
    rowDataItems = props.rowGrid.items;
    colDataItems = props.columnGrid.items;
    cellItems = props.centerGrid.allContents;
    cellDataItems = props.centerGrid.items;
    for (_i = 0, _len = cellItems.length; _i < _len; _i++) {
      cell = cellItems[_i];
      if (cell.valueType === 'class java.lang.Double' || cell.valueType === 'java.lang.Double') {
        cellPath = cell[this.pathProp];
        break;
      }
    }
    if (!cellPath) {
      return;
    }
    this.cellValuePath = cellPath;
    st = this.cellGrid.store;
    rowLen = rowDataItems.length;
    colLen = colDataItems.length;
    for (rowNum = _j = 0; 0 <= rowLen ? _j < rowLen : _j > rowLen; rowNum = 0 <= rowLen ? ++_j : --_j) {
      for (colNum = _k = 0; 0 <= colLen ? _k < colLen : _k > colLen; colNum = 0 <= colLen ? ++_k : --_k) {
        this.insertIntoCellGridStore(st, rowNum, colNum, 0);
      }
    }
    for (_l = 0, _len1 = cellDataItems.length; _l < _len1; _l++) {
      cell = cellDataItems[_l];
      this.insertIntoCellGridStore(st, cell.rowIndex, cell.columnIndex, cell.value[cellPath], cell);
    }
    for (i = _m = 0; 0 <= rowLen ? _m < rowLen : _m > rowLen; i = 0 <= rowLen ? ++_m : --_m) {
      this.setAvailAmt(i);
    }
    st.sync();
    this.leftheaderGrid.store.sync();
  },
  insertIntoCellGridStore: function(store, rowindex, colindex, value, origCell) {
    var colName, origObj, row;
    row = store.getAt(rowindex);
    colName = 'c' + colindex;
    row.set(colName, value);
    if (origCell) {
      origObj = row.get('origData');
      if (!origObj) {
        origObj = {};
        row.set('origData', origObj);
      }
      origObj[colName] = origCell;
    }
  },
  onCellStoreUpdate: function(st, record, operationNotUsed, modifiedFields) {
    var colindex, fieldType, modifiedField, rowindex, usePercentage;
    if (this.disableStoreEvents) {
      return;
    }
    if (!modifiedFields || !modifiedFields.length) {
      return;
    }
    modifiedField = modifiedFields[0];
    fieldType = modifiedField[0];
    if (fieldType === 'p' || fieldType === 'c' || fieldType === 'b') {
      colindex = modifiedField.slice(1);
      rowindex = st.indexOf(record);
      usePercentage = false;
      if (fieldType === 'p') {
        usePercentage = true;
      }
      this.recalculateTotals(rowindex, colindex, usePercentage);
    }
  },
  setAvailAmt: function(rowindex, usePercentage) {
    var avail, cellAmt, cellStore, cellTotal, cellrow, checkboxColumnName, checkboxState, colDataItems, colItemLength, colName, i, leftHeaderStore, leftamt, leftrow, numAmt, perc, percAmt, percColName, props, _i, _j;
    props = this.cache._myProperties;
    colDataItems = props.columnGrid.items;
    colItemLength = colDataItems.length;
    leftHeaderStore = this.leftheaderGrid.store;
    leftrow = leftHeaderStore.getAt(rowindex);
    leftamt = leftrow.get(this.leftheaderTotalColumn);
    cellStore = this.cellGrid.store;
    cellrow = cellStore.getAt(rowindex);
    if (usePercentage) {
      for (i = _i = 0; 0 <= colItemLength ? _i < colItemLength : _i > colItemLength; i = 0 <= colItemLength ? ++_i : --_i) {
        colName = 'c' + i;
        percColName = 'p' + i;
        percAmt = cellrow.get(percColName);
        numAmt = leftamt * percAmt / 100;
        cellrow.set(colName, numAmt);
      }
    }
    cellTotal = 0;
    for (i = _j = 0; 0 <= colItemLength ? _j < colItemLength : _j > colItemLength; i = 0 <= colItemLength ? ++_j : --_j) {
      colName = 'c' + i;
      cellAmt = cellrow.get(colName);
      checkboxColumnName = 'b' + i;
      checkboxState = cellrow.get(checkboxColumnName);
      if (checkboxState) {
        cellTotal += cellAmt;
      }
      percColName = 'p' + i;
      perc = cellAmt / leftamt * 100;
      cellrow.set(percColName, perc);
    }
    avail = leftamt - cellTotal;
    leftrow.set('AvailAmt', avail);
    leftHeaderStore.sync();
  },
  updateTopHeaderTotalAll: function() {
    var colDataItems, colDataItemsLen, i, props, _i;
    props = this.cache._myProperties;
    colDataItems = props.columnGrid.items;
    colDataItemsLen = colDataItems.length;
    for (i = _i = 0; 0 <= colDataItemsLen ? _i < colDataItemsLen : _i > colDataItemsLen; i = 0 <= colDataItemsLen ? ++_i : --_i) {
      this.updateTopHeaderTotal(i);
    }
    delete this.disableStoreEvents;
  },
  updateTopHeaderTotal: function(colindex) {
    var cellRowCount, cellStore, cellTotal, cellrow, checkboxColumnName, checkboxState, colName, headerRowCount, i, topheaderStore, totalAmt, unapprovedAmt, unapprovedRow, _i;
    topheaderStore = this.topheaderGrid.store;
    cellStore = this.cellGrid.store;
    headerRowCount = topheaderStore.getCount();
    cellRowCount = cellStore.getCount();
    colName = 'c' + colindex;
    totalAmt = topheaderStore.getAt(headerRowCount - 2).get(colName);
    unapprovedRow = topheaderStore.getAt(headerRowCount - 1);
    cellTotal = 0;
    for (i = _i = 0; 0 <= cellRowCount ? _i < cellRowCount : _i > cellRowCount; i = 0 <= cellRowCount ? ++_i : --_i) {
      cellrow = cellStore.getAt(i);
      checkboxColumnName = 'b' + colindex;
      checkboxState = cellrow.get(checkboxColumnName);
      if (checkboxState) {
        cellTotal += cellrow.get(colName);
      }
    }
    unapprovedAmt = totalAmt - cellTotal;
    unapprovedRow.set(colName, unapprovedAmt);
    topheaderStore.sync();
  },
  recalculateTotals: function(rowindex, colindex, usePercentage) {
    this.setAvailAmt(rowindex, usePercentage);
    this.updateTopHeaderTotal(colindex);
  },
  generatePostData: function() {
    var cache, cell, cellItems, cellStore, cellValuePath, cm, colLen, colName, colNum, columnDataItems, columnItems, newval, oldval, origCell, origData, postData, props, row, rowDataItems, rowItems, rowLen, rowNum, rowSelected, selected, _i, _j, _ref;
    cm = Corefw.util.Common;
    cache = this.cache;
    props = cache._myProperties;
    if (!this.cellGrid) {
      return;
    }
    rowDataItems = props.rowGrid.items;
    columnDataItems = props.columnGrid.items;
    postData = {
      name: props.name,
      rowGrid: {},
      columnGrid: {},
      centerGrid: {}
    };
    selected = ((_ref = this.cellGrid.selModel) != null ? _ref.selected : void 0) || [];
    rowItems = cm.objectClone(rowDataItems);
    postData.rowGrid.items = rowItems;
    columnItems = cm.objectClone(columnDataItems);
    postData.columnGrid.items = columnItems;
    if (this.cellValuePath) {
      cellValuePath = this.cellValuePath;
      cellStore = this.cellGrid.store;
      cellItems = [];
      rowLen = rowItems.length;
      colLen = columnItems.length;
      for (rowNum = _i = 0; 0 <= rowLen ? _i < rowLen : _i > rowLen; rowNum = 0 <= rowLen ? ++_i : --_i) {
        row = cellStore.getAt(rowNum);
        rowSelected = selected.contains(row);
        origData = row.get('origData');
        for (colNum = _j = 0; 0 <= colLen ? _j < colLen : _j > colLen; colNum = 0 <= colLen ? ++_j : --_j) {
          colName = 'c' + colNum;
          newval = row.get(colName);
          origCell = origData != null ? origData[colName] : void 0;
          if (origCell) {
            cell = cm.objectClone(origCell);
            cell["new"] = false;
            cell.selected = rowSelected;
            oldval = cell.value[cellValuePath];
            if (newval !== oldval) {
              cell.value[cellValuePath] = newval;
              cell.changed = true;
            } else {
              cell.changed = false;
            }
          } else {
            cell = {
              "new": true,
              selected: rowSelected,
              changed: true,
              columnIndex: colNum,
              rowIndex: rowNum,
              value: {}
            };
            cell.value[cellValuePath] = newval;
          }
          cellItems.push(cell);
        }
      }
      postData.centerGrid.items = cellItems;
      cellStore.sync();
    }
    return postData;
  }
});
