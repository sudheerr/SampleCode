// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.InlineFilter', {
  extend: 'Ext.AbstractPlugin',
  alias: 'plugin.inlinefilter',
  uses: ['Ext.window.MessageBox', 'CitiRiskLibrary.view.ClearButton', 'Ext.container.Container', 'Ext.util.DelayedTask', 'Ext.layout.container.HBox', 'Ext.data.ArrayStore', 'Ext.form.field.Text', 'Ext.form.field.Date'],
  mixins: {
    observable: 'Ext.util.Observable'
  },
  updateBuffer: 1000,
  columnFilteredCls: Ext.baseCSSPrefix + 'column-filtered',
  showClearButton: true,
  autoStoresRemoteProperty: 'autoStores',
  autoStoresNullValue: '',
  autoStoresNullText: '-',
  autoUpdateAutoStores: false,
  enableOperators: true,
  visibility: true,
  stringTpl: {
    xtype: 'textfield',
    type: 'string'
  },
  dateTpl: {
    xtype: 'datefield',
    editable: true,
    submitFormat: 'Y-m-d'
  },
  dateStringTpl: {
    xtype: 'coredatestringfield',
    editable: true,
    submitFormat: 'Y-m-d H:i:s'
  },
  numTpl: {
    xtype: 'numberfield',
    allowDecimals: true,
    hideTrigger: true,
    keyNavEnabled: false,
    mouseWheelEnabled: false,
    decimalPrecision: 10
  },
  comboTpl: {
    xtype: 'combo',
    queryMode: 'local',
    typeAhead: true,
    triggerAction: 'all',
    onSubmitFilterValueFilter: function() {
      var me;
      me = this;
      me.collapse();
      me.fireEvent('submitfiltervalue', me);
    },
    createPicker: function() {
      var me, picker, pickerCfg;
      me = this;
      picker = void 0;
      pickerCfg = Ext.apply({
        xtype: 'boundlist',
        pickerField: me,
        selModel: {
          mode: me.multiSelect ? 'SIMPLE' : 'SINGLE'
        },
        floating: true,
        hidden: true,
        store: me.store,
        displayField: me.displayField,
        focusOnToFront: false,
        pageSize: me.multiSelect ? 10000000 : 0,
        tpl: me.tpl
      }, me.listConfig, me.defaultListConfig);
      picker = me.picker = Ext.widget(pickerCfg);
      if (me.multiSelect) {
        picker.pagingToolbar.on('submitfiltervalue', me.onSubmitFilterValueFilter, me);
      }
      me.mon(picker, {
        itemclick: me.onItemClick,
        refresh: me.onListRefresh,
        scope: me
      });
      me.mon(picker.getSelectionModel(), {
        beforeselect: me.onBeforeSelect,
        beforedeselect: me.onBeforeDeselect,
        selectionchange: me.onListSelectionChange,
        scope: me
      });
      return picker;
    },
    listConfig: {
      getInnerTpl: function(displayField) {
        if (Corefw.util.Startup.themeVersion === 2) {
          return '<div class="x-boundlist-item-inner"><div class="x-grid-row-checker x-grid-checkselect role="presentation"><span class="x-list-checkbox">&nbsp&nbsp&nbsp&nbsp&nbsp</span> {' + displayField + '} &nbsp;</div></div>';
        } else {
          return '<div class="x-boundlist-item-innerV1"><div class="x-grid-row-checker x-grid-checkselect role="presentation"><span class="x-list-checkboxV1">&nbsp&nbsp&nbsp&nbsp</span> {' + displayField + '} &nbsp;</div></div>';
        }
      },
      resizeHandles: 'se s sw',
      resizable: {
        listeners: {
          beforeresize: function() {
            this.resizeTracker.maxHeight = 10000;
            this.target.maxHeight = 10000;
          },
          resize: function() {
            this.resizeTracker.maxHeight = 300;
            this.target.maxHeight = 300;
          }
        }
      },
      style: {
        whiteSpace: 'nowrap'
      },
      createPagingToolbar: function() {
        return Ext.widget('inlinefilterComboToolbar', {
          border: false,
          ownerCt: this,
          ownerLayout: this.getComponentLayout()
        });
      }
    },
    clearValue: function() {
      this.setValue(null);
    }
  },
  constructor: function() {
    var me;
    me = this;
    me.mixins.observable.constructor.call(me);
    me.callParent(arguments);
  },
  init: function(grid) {
    var me;
    me = this;
    if (grid.inlineFilterVisibility === false) {
      me.visibility = false;
    }
    grid.on({
      columnresize: me.resizeContainer,
      columnhide: me.resizeContainer,
      columnshow: me.resizeContainer,
      beforedestroy: me.unsetup,
      reconfigure: me.resetup,
      scope: me
    });
    grid.addEvents('filterupdated');
    Ext.apply(grid, {
      filterBar: me,
      getFilterBar: function() {
        return this.filterBar;
      }
    });
    me.setup(grid);
    if (me.visibility === false) {
      me.unsetup(grid);
    }
    me.doRemoteFilter = Ext.Function.createBuffered(function() {
      var field;
      field = arguments[0];
      if (field.multiSelect && field.isExpanded) {
        return;
      }
      return me.sendRequest();
    }, 100);
  },
  sendRequest: function() {
    var grid, gridField, postData, _ref;
    grid = this.grid;
    gridField = grid.ownerCt;
    if (gridField) {
      if (((_ref = gridField.eventURLs) != null ? _ref['ONRETRIEVE'] : void 0)) {
        postData = grid.generatePostDataForRetrieve();
      } else {
        postData = gridField.generatePostData();
      }
    }
    grid.remoteLoadStoreData(postData);
  },
  setup: function(grid) {
    var me;
    me = this;
    me.grid = grid;
    me.autoStores = Ext.create('Ext.util.MixedCollection');
    me.autoStoresLoaded = false;
    me.columns = Ext.create('Ext.util.MixedCollection');
    me.containers = Ext.create('Ext.util.MixedCollection');
    me.fields = Ext.create('Ext.util.MixedCollection');
    me.task = Ext.create('Ext.util.DelayedTask');
    me.parseFiltersConfig();
    if (grid.rendered) {
      me.renderFilterBar(grid);
    } else {
      grid.on('afterrender', me.renderFilterBar, me, {
        single: true
      });
    }
  },
  cleanProp: function(prop) {
    prop.each(function(item) {
      Ext.destroy(item);
    });
    prop.clear();
    prop = null;
  },
  unsetup: function(grid) {
    var me;
    me = this;
    if (me.autoStores !== null && me.autoStores !== void 0) {
      if (me.autoStores.getCount()) {
        me.grid.store.un('load', me.fillComboStores, me);
      }
      me.autoStores.clear();
      me.autoStores = null;
      me.columns.each(function(column) {
        if (column.rendered) {
          if (column.getEl().hasCls(me.columnFilteredCls)) {
            column.getEl().removeCls(me.columnFilteredCls);
          }
        }
      }, me);
      me.columns.clear();
      me.columns = null;
      me.cleanProp(me.fields);
      me.cleanProp(me.containers);
      me.task = null;
    }
  },
  resetup: function(grid) {
    this.unsetup(grid);
    this.setup(grid);
  },
  resetFilters: function(grid) {
    var me;
    me = this;
    me.fields.each(function(item) {
      var button, column, ct, operator;
      column = me.columns.get(item.dataIndex);
      ct = this.ownerCt;
      ct.fieldMouseover = true;
      button = ct.down('button');
      if (button) {
        if (column) {
          column.cache._myProperties.filterOperator = 'EQ';
        }
        if (column.filter.type === 'combo') {
          if (me.onlyHaveOneFilterOperators(column.cache._myProperties)) {
            column.cache._myProperties.filterOperator = _myProperties.filterOperators[0];
            item.multiSelect = true;
          } else {
            item.multiSelect = false;
          }
        }
        operator = me.getOperatorOnButtonIconCls(column.cache._myProperties.filterOperator);
        button.setIconCls(operator.iconCls);
      }
      item.setValue(null);
      column.removeCls('filteredcolumn');
      me.applyFilters(item);
    });
  },
  parseFiltersConfig: function() {
    var columns, filterColumns, me, su;
    me = this;
    su = Corefw.util.Startup;
    columns = me.grid.headerCt.getGridColumns();
    me.columns.clear();
    me.autoStores.clear();
    filterColumns = [];
    Ext.each(columns, function(column) {
      var cache, filterType, props;
      cache = column.cache;
      if (!cache) {
        return;
      }
      props = cache._myProperties;
      filterType = props.filterType;
      if (filterType && filterType !== 'NONE') {
        filterColumns.push(column);
      }
    });
    if (!filterColumns.length) {
      return;
    }
    Ext.each(columns, function(column) {
      var cache, filterType, props;
      cache = column.cache;
      if (!cache) {
        return;
      }
      props = cache._myProperties;
      filterType = props.filterType;
      column.filter = {
        disabled: filterType && filterType !== 'NONE' ? false : true,
        column: column,
        isInlineFilter: true
      };
      switch (filterType) {
        case 'NUMBER':
          column.filter.type = 'num';
          break;
        case 'COMBO':
          column.filter.type = 'combo';
          if ((this.onlyHaveOneFilterOperators(props)) && !props.filterOperator) {
            cache._myProperties.filterOperator = cache._myProperties.filterOperators[0];
          }
          break;
        case 'DATE':
          column.filter.type = 'date';
          break;
        case 'DATESTRING':
          column.filter.type = 'dateString';
          column.filter.format = 'Y-m-d H:i:s';
          break;
        default:
          column.filter.type = 'string';
      }
      if (su.getThemeVersion() === 2) {
        if (filterType === 'COMBO') {
          column.filter.triggerBaseCls = 'formtriggericon';
          column.filter.triggerCls = 'gridcombotrig';
        }
        if (filterType === 'DATESTRING') {
          column.filter.cls = 'dateFilterCls';
        }
      }
      if (column.filter.type) {
        column.filter = Ext.applyIf(column.filter, me[column.filter.type + 'Tpl']);
      }
      if (column.filter.type === 'combo' && !column.filter.store) {
        column.autoStore = true;
        column.filter.store = Ext.create('Ext.data.ArrayStore', {
          fields: [
            {
              name: 'displayValue'
            }, {
              name: 'value'
            }
          ]
        });
        me.autoStores.add(column.dataIndex, column);
        column.filter = Ext.apply(column.filter, {
          displayField: 'displayValue',
          valueField: 'value'
        });
      }
      me.columns.add(column.dataIndex, column);
    }, me);
  },
  fillComboStores: function() {
    var me, _ref;
    me = this;
    if (me != null) {
      if ((_ref = me.autoStores) != null) {
        _ref.eachKey(function(key, item) {
          var errMsg, fieldComboCallback, filter, filterWidget, method, records, result, rq, url;
          records = item.cache._myProperties.filterOptions ? item.cache._myProperties.filterOptions : [];
          if (!records.length) {
            rq = Corefw.util.Request;
            result = [];
            fieldComboCallback = function(respArray, uipath) {
              var _ref1;
              if (Ext.isArray(respArray)) {
                respArray.forEach(function(respObj, index, array) {
                  result.push({
                    displayValue: respObj['displayField'],
                    value: respObj['valueField']
                  });
                });
                item.filter.store.loadData(result);
                me.showInitialFilters();
              }
              if ((_ref1 = me.grid) != null) {
                if (typeof _ref1.updateLayout === "function") {
                  _ref1.updateLayout();
                }
              }
            };
            url = rq.objsToUrl3(item.cache._myProperties.eventURLs['ONLOOKUP'], null, '');
            errMsg = 'Did not receive a valid response for the combobox';
            method = 'POST';
            rq.sendRequest5(url, fieldComboCallback, item.cache._myProperties.uipath, null, errMsg, method);
          } else {
            filter = item.filter;
            filterWidget = filter.filterWidget;
            filterWidget && filterWidget.suspendEvents();
            filter.store.loadData(records);
            filterWidget && filterWidget.resumeEvents();
          }
        }, me);
      }
    }
  },
  addEmptySelection: function(records, item) {
    if (item.inlineFilterReady) {
      return;
    }
    records.unshift({
      displayValue: this.autoStoresNullText,
      value: this.autoStoresNullValue
    });
    item.inlineFilterReady = true;
  },
  applyFiltersOnGrid: function() {
    var i, me, store, _i, _len, _ref;
    me = this;
    store = me.grid.getStore();
    store.clearFilter();
    _ref = me.fields.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      me.applyFilterOnGrid(me.fields.items[_i]);
    }
  },
  applyFilterOnGrid: function(field) {
    var anyMatchStatus, filter, me, newVal, store, time;
    me = this;
    anyMatchStatus = true;
    store = me.grid.getStore();
    newVal = store.remoteFilter ? field.getSubmitValue() : field.getValue();
    if (field.type === 'string') {
      anyMatchStatus = true;
    }
    if (field.type === 'date') {
      time = new Date(newVal).getTime();
      newVal = time ? time : '';
    }
    if (!newVal) {
      newVal = '';
    }
    if (newVal !== '') {
      if (field.type === 'date') {
        filter = new Ext.util.Filter({
          property: field.dataIndex,
          id: field.dataIndex,
          value: newVal,
          anyMatch: anyMatchStatus,
          caseSensitive: false,
          root: 'data',
          filterFn: function(item) {
            if (Ext.Date.format(new Date(item.data[this.property]), 'Y-m-d') === Ext.Date.format(new Date(this.value), 'Y-m-d')) {
              return true;
            } else if (Ext.Date.format(new Date(item.data[this.property]), 'Y-m-d H:i:s') === Ext.Date.format(new Date(this.value), 'Y-m-d H:i:s')) {
              return true;
            } else if (this.value === null || this.value === '') {
              return true;
            } else {
              return false;
            }
          }
        });
      } else {
        filter = new Ext.util.Filter({
          property: field.dataIndex,
          value: newVal,
          anyMatch: anyMatchStatus,
          caseSensitive: false,
          root: 'data'
        });
      }
    }
    store.addFilter(filter, true);
  },
  manageShowHideoperatorOnButton: function(operatorOnButton, operatorValueField) {
    if (operatorOnButton && operatorValueField && operatorOnButton.up() && operatorValueField.up()) {
      if (operatorOnButton && !operatorOnButton.up().buttonMouseover && !operatorValueField.up().fieldMouseover) {
        operatorOnButton.hide();
      }
    }
  },
  showOperatorMenu: function(column, operatorOnButton, operatorValueField, operators) {
    var filterType, me, opMenu, su;
    me = this;
    su = Corefw.util.Startup;
    filterType = operatorValueField.type;
    opMenu = Ext.create('Ext.menu.Menu', {
      width: 100,
      margin: '0 0 10 0',
      column: column,
      operatorOnButton: operatorOnButton,
      operatorValueField: operatorValueField,
      floating: true,
      items: operators,
      listeners: {
        afterrender: function(thisMenu) {
          if (su.getThemeVersion() !== 2) {
            return;
          }
          return thisMenu.tip = Ext.create('Ext.tip.ToolTip', {
            target: thisMenu.getEl().getAttribute('id'),
            delegate: '.x-menu-item',
            trackMouse: true,
            renderTo: Ext.getBody(),
            listeners: {
              beforeshow: function(tip) {
                var menuItem;
                menuItem = thisMenu.queryById(tip.triggerElement.id);
                if (!menuItem.initialConfig.text) {
                  return false;
                }
                return tip.update(menuItem.initialConfig.text);
              }
            }
          });
        },
        click: function(menu, item, e, eOpts) {
          menu.operatorOnButton.setIconCls(item.iconCls);
          menu.column.cache._myProperties.filterOperator = item.value;
          menu.operatorValueField.up().buttonMouseover = false;
          operatorValueField = menu.operatorValueField;
          if (item.value === 'IN' || item.value === 'NI') {
            if (filterType === 'combo') {
              me.converMultiSelectValue(operatorValueField, true);
            }
            if (filterType === 'num') {
              operatorValueField.multiSelect = true;
              operatorValueField.baseChars = '0123456789,';
            }
          } else {
            if (filterType === 'combo') {
              me.converMultiSelectValue(operatorValueField, false);
            }
            if (filterType === 'num') {
              operatorValueField.multiSelect = false;
              operatorValueField.baseChars = '0123456789';
            }
          }
          if (Ext.isEmpty(operatorValueField.value)) {
            return;
          }
          me.applyDelayedFilters(operatorValueField);
        },
        hide: function(menu) {
          menu.operatorValueField.up().buttonMouseover = false;
          menu.operatorOnButton.hide();
          return menu.operatorOnButton.isMenuWindowOpened = false;
        }
      }
    });
    if (su.getThemeVersion() === 2) {
      opMenu.width = 26;
      opMenu.minWidth = 26;
      opMenu.addCls('menuIconColor');
      opMenu.showAt(operatorOnButton.getX(), operatorOnButton.getY() + 25);
    } else {
      opMenu.showAt(operatorOnButton.getX() + 10, operatorOnButton.getY() + 10);
    }
  },
  converMultiSelectValue: function(operatorValueField, multiSelect) {
    var _ref;
    if (operatorValueField.multiSelect !== multiSelect) {
      operatorValueField.multiSelect = multiSelect;
      if (multiSelect) {
        operatorValueField.setValue([operatorValueField.value]);
      } else {
        if (Ext.isArray(operatorValueField.value)) {
          operatorValueField.setValue(operatorValueField.value[0]);
        }
      }
      if ((_ref = operatorValueField.picker) != null) {
        _ref.destroy();
      }
      operatorValueField.picker = null;
    }
  },
  getOperatorOnButtonIconCls: function(operatorVal) {
    var iconCls, operator, su, text, value;
    su = Corefw.util.Startup;
    switch (operatorVal) {
      case 'EQ':
        iconCls = 'I_EQUAL';
        text = 'EQUAL';
        value = 'EQ';
        break;
      case 'NE':
        iconCls = 'I_NOTEQUAL';
        text = 'NOTEQUAL';
        value = 'NE';
        break;
      case 'LT':
        iconCls = 'I_LESSTHAN';
        text = 'LESSTHAN';
        value = 'LT';
        break;
      case 'LE':
        iconCls = 'I_LESSTHANEQUAL';
        text = 'LESSEQUAL';
        value = 'LE';
        break;
      case 'GT':
        iconCls = 'I_GREATERTHAN';
        text = 'GREATERTHAN';
        value = 'GT';
        break;
      case 'GE':
        iconCls = 'I_GREATERTHANEQUAL';
        text = 'GREATEREQUAL';
        value = 'GE';
        break;
      case 'IN':
        iconCls = 'I_IN';
        text = 'IN';
        value = 'IN';
        break;
      case 'NI':
        iconCls = 'I_NOTIN';
        text = 'NOTIN';
        value = 'NI';
        break;
      case 'LIKE':
        iconCls = 'I_LIKE';
        text = 'LIKE';
        value = 'LIKE';
        break;
      case 'EQ':
        iconCls = 'I_EQUAL';
        text = 'EQUAL';
        value = 'EQ';
    }
    if (su.getThemeVersion() === 2) {
      operator = {
        iconCls: 'icon icon-3x icon-' + Corefw.util.Cache.cssclassToIcon[iconCls],
        text: text,
        value: value
      };
    } else {
      operator = {
        iconCls: iconCls,
        text: text,
        value: value
      };
    }
    return operator;
  },
  setUpColumnOperators: function(filterOperators) {
    var me, operators;
    me = this;
    operators = [];
    Ext.each(filterOperators, function(operatorVal) {
      var operator;
      operator = me.getOperatorOnButtonIconCls(operatorVal);
      return operators.push(operator);
    });
    return operators;
  },
  renderFilterBar: function(grid) {
    var me, su;
    me = this;
    su = Corefw.util.Startup;
    if (me.visibility) {
      me.containers.clear();
      me.fields.clear();
      me.columns.eachKey(function(key, column) {
        var colProps, container, ctConf, field, filterConf, filterOperator, filterOperators, filterType, iconCls, listConfig, multiSelect, numOfOperators, operator, operatorOnButton, operators, plugins;
        listConfig = column.filter.listConfig || {};
        plugins = [];
        if (me.showClearButton) {
          plugins.push({
            ptype: 'clearbutton'
          });
        }
        colProps = column.cache._myProperties;
        filterType = colProps.filterType;
        filterOperator = colProps.filterOperator;
        multiSelect = filterOperator === 'IN' || filterOperator === 'NI';
        filterConf = Ext.apply(column.filter, {
          inlineFilter: me,
          dataIndex: key,
          flex: 1,
          margin: 0,
          fieldStyle: 'border:none 0px black;',
          fieldCls: 'operatorValueFieldCls',
          region: 'center',
          listConfig: listConfig,
          preventMark: true,
          msgTarget: 'none',
          checkChangeBuffer: 50,
          enableKeyEvents: true,
          plugins: plugins,
          listeners: {
            change: me.applyDelayedFilters,
            submitfiltervalue: me.applyFieldFilter,
            keypress: function(txt, e) {
              if (e.getCharCode() === 13) {
                e.stopEvent();
                if (txt.isExpanded) {
                  txt.collapse();
                }
                me.onKeyPressApplyFilters(txt);
              }
              return false;
            },
            focus: function() {
              var btn, ct;
              ct = this.ownerCt;
              ct.fieldMouseover = true;
              btn = ct.down('button');
              return btn != null ? btn.show() : void 0;
            },
            mouseenter: {
              element: 'el',
              fn: function() {
                var btn, ct, field;
                field = Ext.getCmp(this.id);
                ct = field.ownerCt;
                ct.fieldMouseover = true;
                btn = ct.down('button');
                return btn != null ? btn.show() : void 0;
              }
            },
            mouseleave: {
              element: 'el',
              fn: function() {
                var btn, ct, field, _ref;
                field = Ext.getCmp(this.id);
                ct = field.ownerCt;
                ct.fieldMouseover = false;
                btn = ct.down('button');
                return (_ref = field.column.showHideOperatorTask) != null ? _ref.delay(20, null, me, [btn, field]) : void 0;
              }
            }
          }
        });
        if (filterType === 'COMBO') {
          filterConf = Ext.apply(column.filter, {
            typeAhead: !multiSelect,
            multiSelect: multiSelect
          });
        }
        if (filterType === 'NUMBER') {
          filterConf = Ext.apply(column.filter, {
            baseChars: multiSelect ? '0123456789,' : '0123456789'
          });
        }
        field = Ext.widget(column.filter.xtype || column.filter.type, filterConf);
        me.fields.add(column.dataIndex, field);
        column.filter.filterWidget = field;
        ctConf = {
          items: [field],
          dataIndex: key,
          cls: 'filterCt',
          layout: 'border',
          height: 23,
          buttonMouseover: false,
          fieldMouseover: false,
          bodyStyle: 'background-color: "transparent";',
          width: column.getWidth(),
          listeners: {
            scope: me,
            element: 'el',
            mousedown: function(e) {
              e.stopPropagation();
            },
            click: function(e) {
              e.stopPropagation();
            },
            dblclick: function(e) {
              e.stopPropagation();
            },
            keydown: function(e) {
              e.stopPropagation();
            },
            keypress: function(e) {
              e.stopPropagation();
            },
            keyup: function(e) {
              e.stopPropagation();
            }
          }
        };
        if ((filterType === 'NUMBER' || filterType === 'DATA' || filterType === 'DATESTRING' || filterType === 'STRING' || filterType === 'COMBO') && !this.onlyHaveOneFilterOperators(colProps)) {
          filterOperators = column.cache._myProperties.filterOperators || {};
          numOfOperators = filterOperators.length;
          if (numOfOperators) {
            operators = me.setUpColumnOperators(filterOperators);
            column.showHideOperatorTask = new Ext.util.DelayedTask(me.manageShowHideoperatorOnButton, me);
            filterOperator = column.cache._myProperties.filterOperator;
            if (filterOperator) {
              operator = me.getOperatorOnButtonIconCls(filterOperator);
              iconCls = operator.iconCls;
            } else {
              iconCls = su.getThemeVersion() === 2 ? 'icon icon-3x icon-equal-to' : 'I_EQUAL';
            }
            operatorOnButton = new Ext.button.Button({
              style: 'float:left;',
              itemId: 'operatorOnButton',
              hidden: true,
              iconCls: iconCls,
              region: 'west',
              isMenuWindowOpened: false,
              cls: 'operatorOnButtonCls',
              listeners: {
                click: function(button) {
                  button.up().buttonMouseover = true;
                  button.isMenuWindowOpened = true;
                  me.showOperatorMenu(column, button, field, operators);
                },
                mouseover: function(button) {
                  button.up().buttonMouseover = true;
                  button.show();
                },
                mouseout: function(button) {
                  if (!button.isMenuWindowOpened) {
                    button.up().buttonMouseover = false;
                  }
                  column.showHideOperatorTask.delay(20, null, me, [operatorOnButton, field]);
                }
              }
            });
            ctConf.items.unshift(operatorOnButton);
          }
        }
        if (su.getThemeVersion() === 2) {
          ctConf.height = '22px';
        }
        container = Ext.create('Ext.container.Container', ctConf);
        me.containers.add(column.dataIndex, container);
        container.render(Ext.get(column.id));
      }, me);
      if (me.autoStores.getCount()) {
        me.fillComboStores();
        me.grid.store.on('refresh', me.fillComboStores, me);
      }
      me.showInitialFilters();
    }
  },
  onlyHaveOneFilterOperators: function(colProps) {
    var hide, _ref;
    hide = false;
    if (((_ref = colProps.filterOperators) != null ? _ref.length : void 0) === 1) {
      hide = true;
    }
    return hide;
  },
  showInitialFilters: function() {
    var cache, colProperties, filterValObj, filterValue, grid, item, items, oneCache, props, _i, _len;
    filterValObj = {};
    colProperties = {};
    grid = this.grid;
    cache = grid.cache;
    for (item in cache) {
      oneCache = cache[item];
      if (item !== '_myProperties') {
        props = oneCache._myProperties;
        filterValue = props.filterValue;
        filterValObj[props.index] = filterValue;
        colProperties[props.index] = props;
      }
    }
    items = this.grid.filterBar.fields.items;
    for (_i = 0, _len = items.length; _i < _len; _i++) {
      item = items[_i];
      item.suspendEvents();
      filterValue = filterValObj[item.dataIndex];
      if (!Ext.isEmpty(filterValue)) {
        item.column.addCls('filteredcolumn');
      } else {
        item.column.removeCls('filteredcolumn');
      }
      if (item.type.toLowerCase() === 'date') {
        filterValue = new Date(filterValue);
        filterValue = Ext.Date.format(filterValue, 'Y-m-d');
      }
      if (item.type.toLowerCase() === 'datestring' && filterValue) {
        filterValue = new Date(filterValue);
      }
      item.setValue(filterValue || filterValue === false ? filterValue : '');
      item.resumeEvents();
    }
    this.restoreFieldFocus(grid);
  },
  resizeContainer: function(headerCt, col) {
    var colWidth, column, dataIndex, item, itemWidth;
    dataIndex = col.dataIndex;
    if (!dataIndex) {
      return;
    }
    item = this.containers.get(dataIndex);
    if (item && item.rendered) {
      itemWidth = item.getWidth();
      column = this.columns.get(dataIndex);
      if (!column.el) {
        return;
      }
      colWidth = column.getWidth();
      if (itemWidth !== colWidth) {
        item.setWidth(this.columns.get(dataIndex).getWidth());
        item.doLayout();
      }
    }
  },
  restoreFieldFocus: function(grid) {
    var column, columns, fieldDataIndex, filterColumn, filterField, iv, uipath, _i, _len, _ref, _ref1;
    iv = Corefw.util.InternalVar;
    columns = grid.columns;
    uipath = (_ref = grid.up('coreobjectgrid')) != null ? _ref.uipath : void 0;
    if (uipath === void 0) {
      return;
    }
    fieldDataIndex = iv.getByUipathProperty(uipath, 'fieldDataIndex');
    for (_i = 0, _len = columns.length; _i < _len; _i++) {
      column = columns[_i];
      if (column.dataIndex === fieldDataIndex) {
        filterColumn = column;
        break;
      }
    }
    filterField = filterColumn != null ? (_ref1 = filterColumn.filter) != null ? _ref1.filterWidget : void 0 : void 0;
    if (filterField) {
      filterField.focus(false);
      iv.deleteUipathProperty(uipath, 'fieldDataIndex');
    }
  },
  storeScrollbarPosition: function(iv, uipath) {
    var view;
    view = this.grid.getView();
    if (view.normalView) {
      iv.setByUipathProperty(uipath, 'gridscroll_normal_left', view.normalView.el.getScroll().left);
      iv.setByUipathProperty(uipath, 'gridscroll_locked_left', view.lockedView.el.getScroll().left);
    } else {
      iv.setByUipathProperty(uipath, 'gridscroll_left', view.el.getScroll().left);
    }
  },
  storeCurrentFilterField: function(iv, field, uipath) {
    iv.setByUipathProperty(uipath, 'fieldDataIndex', field.dataIndex);
  },
  applyFilters: function(field, isKeyPress) {
    var colCache, colProps, column, grid, iv, me, newVal, time, uipath;
    if (!field.isValid()) {
      return;
    }
    me = this;
    iv = Corefw.util.InternalVar;
    grid = me.grid;
    if (!me.columns) {
      return;
    }
    column = me.columns.get(field.dataIndex);
    newVal = grid.store.remoteFilter ? field.getSubmitValue() : field.getValue();
    colCache = column.cache;
    colProps = colCache._myProperties;
    switch (colProps.filterType) {
      case 'DATE':
        time = new Date(newVal).getTime();
        newVal = time ? time : null;
        break;
      case 'DATESTRING':
        time = newVal ? Ext.Date.format(newVal, 'Y-m-d H:i:s') : newVal;
        newVal = time ? time : null;
        break;
      case 'COMBO':
        if ((this.onlyHaveOneFilterOperators(colProps)) && !colProps.filterOperator) {
          colProps.filterOperator = colProps.filterOperators[0];
        }
    }
    if (newVal === null) {
      delete colProps.filterValue;
    } else {
      colProps.filterValue = newVal;
    }
    if (!colProps.filterOperator) {
      colProps.filterOperator = 'EQ';
    }
    uipath = grid.up().uipath;
    this.storeScrollbarPosition(iv, uipath);
    this.storeCurrentFilterField(iv, field, uipath);
    me.doRemoteFilter(field);
  },
  applyDelayedFilters: function(field) {
    var inlineFilter;
    if (!field.isValid()) {
      return;
    }
    inlineFilter = field.inlineFilter;
    inlineFilter.task.delay(inlineFilter.updateBuffer, inlineFilter.applyFilters, inlineFilter, [field]);
  },
  applyFieldFilter: function(field) {
    var inlineFilter;
    inlineFilter = field.inlineFilter;
    inlineFilter.applyFilters(field);
  },
  onKeyPressApplyFilters: function(field) {
    var me;
    if (!field.isValid()) {
      return;
    }
    me = this;
    me.task.delay(0, me.applyFilters, me, [field]);
  }
});
