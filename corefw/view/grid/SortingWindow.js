// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.SortingWindow', {
  extend: 'Ext.window.Window',
  alias: 'widget.coresortingwindow',
  xtype: 'coresortingwindow',
  cls: 'sortingwindow',
  autoShow: true,
  modal: true,
  title: 'COLUMN MULTI SORTING',
  width: 520,
  sortingItemHeight: 56,
  sortingItemSpacing: 15,
  remainedColumns: [],
  layout: {
    type: 'vbox'
  },
  sortEvent: 'ONRETRIEVE',
  items: [
    {
      xtype: 'fieldcontainer',
      height: this.sortingItemHeight,
      id: 'selectionArea',
      cls: 'sortingwindowbody',
      overflowY: 'auto',
      overflowX: 'hidden',
      margin: '0 0 0 0',
      items: []
    }, {
      xtype: 'fieldcontainer',
      id: 'buttonArea',
      cls: 'sortingwindowfooter',
      width: '100%',
      height: 40,
      layout: {
        type: 'hbox',
        pack: 'end'
      },
      items: [
        {
          xtype: 'primarybutton',
          text: 'Apply',
          margin: '4 10 0 4',
          id: 'applyBtn'
        }, {
          xtype: 'secondarybutton',
          text: 'Clear',
          margin: '4 10 0 0',
          id: 'clearBtn'
        }, {
          xtype: 'secondarybutton',
          text: 'Cancel',
          margin: '4 0 0 0',
          id: 'cancelBtn'
        }
      ]
    }
  ],
  indexTextMap: {
    1: '1st',
    2: '2nd',
    3: '3rd'
  },
  initComponent: function() {
    var fieldCt, grid, me, props, su;
    this.callParent(arguments);
    su = Corefw.util.Startup;
    if (su.getThemeVersion() !== 2) {
      this.bodyPadding = 10;
    }
    this.bindEventToButtons();
    me = this;
    grid = me.grid;
    fieldCt = grid != null ? grid.up('fieldcontainer') : void 0;
    if (!fieldCt) {
      return;
    }
    props = fieldCt.cache._myProperties;
    me.sortableCols = grid != null ? Ext.clone(grid.query('gridcolumn[sortable=true]')) : [];
    me.remainedColumns = grid != null ? Ext.clone(grid.query('gridcolumn[sortable=true]')) : [];
    me.sortHeaders = props.sortHeaders;
    me.dataProps = props;
    this.initSortingItems();
  },
  bindEventToButtons: function() {
    var applyBtn, cancelBtn, clearBtn, me;
    me = this;
    clearBtn = me.child('#buttonArea>#clearBtn');
    clearBtn.onClick = this.clearSoringSelections;
    cancelBtn = me.child('#buttonArea>#cancelBtn');
    cancelBtn.onClick = this.cancelWindow;
    applyBtn = me.child('#buttonArea>#applyBtn');
    applyBtn.onClick = this.applyMultiSoring;
  },
  initSortingItems: function() {
    var header, index, me, scStore, selectionArea, sortBy, sortHeaders, value, _i, _len;
    me = this;
    sortHeaders = Ext.clone(me.sortHeaders || []);
    if (me.sortableCols.length > sortHeaders.length || sortHeaders.length === 0) {
      sortHeaders.push({
        sortBy: 'ASC'
      });
    }
    selectionArea = me.child('#selectionArea');
    for (index = _i = 0, _len = sortHeaders.length; _i < _len; index = ++_i) {
      header = sortHeaders[index];
      sortBy = header.sortBy;
      value = header.title;
      me.scStore = me.createSortingItemStore();
      selectionArea.add(me.createSortingItem(index + 1, sortBy, value, me.scStore));
    }
    scStore = me.createSortingItemStore();
    me.handleComboboxStore(scStore);
  },
  createSortingItemStore: function(newVal, oldVal, newItemNeeded) {
    var comboxes, sortableCols;
    sortableCols = this.remainedColumns;
    comboxes = this.query('[name=columnCombobox]');
    if (newVal && oldVal && newItemNeeded) {
      this.sortableCols.forEach(function(col) {
        var changeIndex, textValue;
        textValue = col.text;
        changeIndex = sortableCols.findIndex(function(column) {
          if (column.text === newVal) {
            return column;
          }
        });
        if (textValue === newVal) {
          return sortableCols.splice(changeIndex, 1);
        } else if (textValue === oldVal) {
          return sortableCols.splice(changeIndex, 0, col);
        }
      });
    } else {
      sortableCols.forEach(function(columnItem, index) {
        if (comboxes) {
          return comboxes.forEach(function(comboItem) {
            if (comboItem.getDisplayValue() === columnItem.text) {
              return sortableCols.splice(index, 1);
            }
          });
        }
      });
    }
    Ext.Array.forEach(sortableCols, function(col) {
      var textDom, textValue, textValueDom;
      textDom = col.textEl.el.dom;
      textValueDom = Ext.DomQuery.select('div[name=titleValue]', textDom)[0];
      textValue = textValueDom != null ? textValueDom.innerText : void 0;
      if (textValue) {
        col.text = textValue;
      }
    });
    return Ext.create('Ext.data.Store', {
      fields: ['text', 'dataIndex'],
      data: sortableCols
    });
  },
  createSortingItem: function(index, sortBy, value, scStore) {
    var me, sortItem, su;
    me = this;
    sortItem = {
      xtype: 'fieldcontainer',
      cls: 'sortingitem',
      layout: 'hbox',
      columns: [],
      margin: '0 0 15 0',
      width: 500,
      listeners: {
        afterrender: function() {
          var sortpanel;
          sortpanel = me.down('fieldcontainer');
          if (sortpanel.items.length === 1) {
            return sortpanel.setHeight(me.sortingItemHeight + me.sortingItemSpacing);
          } else {
            if (sortpanel.items.length > 5) {
              return sortpanel.setHeight(sortpanel.getHeight());
            } else {
              return sortpanel.setHeight(sortpanel.items.length * me.sortingItemHeight + sortpanel.items.length * me.sortingItemSpacing);
            }
          }
        }
      },
      items: [
        {
          fieldLabel: 'Sort' + me.buildIndexText(index),
          labelStyle: 'font-weight: normal;padding-bottom: 4px;',
          labelAlign: 'top',
          labelSeparator: '',
          xtype: 'combobox',
          name: 'columnCombobox',
          store: scStore,
          queryMode: 'local',
          displayField: 'text',
          valueField: 'dataIndex',
          value: value,
          emptyText: 'Select column',
          width: 260,
          index: index,
          oldValue: null,
          overCls: 'fieldOverCls',
          listeners: {
            beforeselect: function(combobox) {
              return this.oldValue = combobox.getDisplayValue();
            },
            change: function(combobox) {
              return me.handleSortingtItemSelecting(combobox, combobox.getDisplayValue(), combobox.oldValue);
            }
          }
        }, {
          xtype: 'radiogroup',
          margin: '30 0 0 25',
          name: 'sortValue-' + index,
          index: index,
          width: 200,
          items: [me.buildBoxItem(sortBy, 'ASC', index), me.buildBoxItem(sortBy, 'DESC', index)]
        }
      ]
    };
    su = Corefw.util.Startup;
    if (su.getThemeVersion === 2) {
      sortItem.setWidth(485);
      sortItem.items[1].setWidth(185);
    }
    return sortItem;
  },
  buildBoxItem: function(sortBy, iconType, index) {
    var boxLabelTpl, labelstyle, me, name, radioGroupName, sortype, su, _ref;
    me = this;
    su = Corefw.util.Startup;
    radioGroupName = "sv-" + index;
    _ref = iconType === 'ASC' ? ['ASC', 'Ascending'] : ['DESC', 'Descending'], sortype = _ref[0], name = _ref[1];
    labelstyle = 'position: relative;left:-2px;font-weight: normal';
    boxLabelTpl = "<span  style='" + labelstyle + "'>" + name + "</span>";
    return {
      boxLabel: boxLabelTpl,
      name: radioGroupName,
      inputValue: sortype,
      checked: sortBy === sortype
    };
  },
  applyMultiSoring: function(e) {
    var callbackFunc, eventUrlObj, me, postData, props, rq, sWindow, triggerUipath, url, _ref;
    me = this;
    sWindow = me.up('window');
    rq = Corefw.util.Request;
    props = sWindow.dataProps;
    eventUrlObj = props != null ? (_ref = props.events) != null ? _ref[sWindow.sortEvent] : void 0 : void 0;
    if (!eventUrlObj) {
      return;
    }
    url = rq.objsToUrl3(eventUrlObj.url);
    callbackFunc = rq.processResponseObject;
    postData = sWindow.generatePostData(props);
    triggerUipath = props.uipath;
    rq.sendRequest5(url, callbackFunc, triggerUipath, postData, '', 'POST', null, null, null);
    sWindow.close();
  },
  cancelWindow: function(e) {
    var me, sWindow;
    me = this;
    sWindow = me.up('window');
    sWindow.close();
  },
  clearSoringSelections: function(e) {
    var me, sWindow, scStore, selectionArea;
    me = this;
    sWindow = me.up('window');
    selectionArea = sWindow.child('#selectionArea');
    selectionArea.removeAll(true);
    sWindow.remainedColumns = Ext.clone(sWindow.sortableCols);
    scStore = sWindow.createSortingItemStore();
    selectionArea.add(sWindow.createSortingItem(1, 'ASC', null, scStore));
  },
  generatePostData: function(props) {
    var dataIndex, header, index, me, newSortHeaders, originalSortHeaders, postData, record, sortHeaders, sortValue, _i, _len, _ref;
    me = this;
    postData = {};
    postData.name = props.name;
    postData.sortHeaders = sortHeaders = [];
    props = me.grid.up('fieldcontainer').cache._myProperties;
    originalSortHeaders = props.allContents;
    newSortHeaders = me.query('[name=columnCombobox]');
    for (_i = 0, _len = newSortHeaders.length; _i < _len; _i++) {
      header = newSortHeaders[_i];
      me.scStore = me.initAllStore();
      record = me.scStore.getAt(me.getSelectedIndex(header));
      index = header.index + '';
      if (record) {
        dataIndex = record.data.dataIndex;
        sortValue = (_ref = me.query("[name=sortValue-" + header.index + "]")[0]) != null ? _ref.getValue() : void 0;
        header.sortBy = sortValue['sv-' + index];
        header = me.findSortHeaderByAttrValue(originalSortHeaders, 'index', +dataIndex);
        if (header != null) {
          header.sortBy = sortValue['sv-' + index];
          sortHeaders.push(header);
        }
      }
    }
    return postData;
  },
  findSortHeaderByAttrValue: function(sortHeaderumns, attr, value) {
    var header, _i, _len;
    for (_i = 0, _len = sortHeaderumns.length; _i < _len; _i++) {
      header = sortHeaderumns[_i];
      if (header[attr] === value) {
        return header;
      }
    }
  },
  handleSortingtItemSelecting: function(combobox, newVal, oldVal) {
    var isCreateNewItem, newItemIndex, sWindow, scStore, selectionArea;
    sWindow = this;
    selectionArea = sWindow.child('#selectionArea');
    newItemIndex = selectionArea.items.length + 1;
    isCreateNewItem = sWindow.sortableCols.length > selectionArea.items.length;
    scStore = sWindow.createSortingItemStore(newVal, oldVal, sWindow.hasEmptyValueCombo());
    if (isCreateNewItem && !sWindow.hasEmptyValueCombo()) {
      selectionArea.add(sWindow.createSortingItem(newItemIndex, 'ASC', null, scStore));
    }
    sWindow.handleComboboxStore(scStore);
  },
  hasEmptyValueCombo: function() {
    var comboxes;
    comboxes = this.query('[name=columnCombobox]');
    return comboxes.some(function(comboItem) {
      var flag;
      flag = !comboItem.getValue() || comboItem.getValue() === null;
      return flag;
    });
  },
  buildIndexText: function(index) {
    return this.indexTextMap[index] || index + 'th';
  },
  getSelectedIndex: function(combobox) {
    var store, value;
    value = combobox.getDisplayValue();
    store = this.initAllStore();
    return store.find('text', value);
  },
  handleComboboxStore: function(store) {
    var comboxes;
    comboxes = this.query('[name=columnCombobox]');
    comboxes.forEach(function(comboItem) {
      var comboboxStore;
      comboboxStore = comboItem.getStore();
      if (comboboxStore) {
        comboboxStore.destroy();
      }
      return comboItem.bindStore(store);
    });
    return store;
  },
  initAllStore: function() {
    var me;
    me = this;
    Ext.Array.forEach(me.sortableCols, function(col) {
      var textDom, textValue, textValueDom;
      textDom = col.textEl.el.dom;
      textValueDom = Ext.DomQuery.select('div[name=titleValue]', textDom)[0];
      textValue = textValueDom != null ? textValueDom.innerText : void 0;
      if (textValue) {
        col.text = textValue;
      }
    });
    return Ext.create('Ext.data.Store', {
      fields: ['text', 'dataIndex'],
      data: me.sortableCols
    });
  }
});
