// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.pivot.AxisColumn', {
  extend: 'Ext.grid.column.Column',
  alias: 'widget.pivotaxiscolumn',
  tdCls: 'left-axis',
  emptyCellCls: 'empty-cell',
  mergeCellStartCls: 'mergecell-start',
  mergeCellEndCls: 'mergecell-end',
  mergeCell: true,
  draggable: false,
  menuDisabled: true,
  maxWidth: 1000,
  initComponent: function() {
    this.autoEl = {
      'data-qtip': this.text
    };
    return this.callParent(arguments);
  },
  hasValueOnTheLeft: function(record, rowIndex) {
    var column, me, _i, _j, _len, _len1, _ref, _ref1;
    me = this;
    if (me.myLeftColumns === void 0) {
      me.myLeftColumns = [];
      _ref = me.up('grid').columnManager.columns;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        column = _ref[_i];
        if (column === me) {
          break;
        }
        me.myLeftColumns.push(column);
      }
    }
    _ref1 = me.myLeftColumns;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      column = _ref1[_j];
      if (record.get(column.dataIndex)) {
        return true;
      }
    }
    return false;
  },
  compareWithCell: function(value, store, rowIndex, dataIndex) {
    var record, targetValue;
    record = store.getAt(rowIndex);
    if (record) {
      targetValue = record.get(dataIndex);
      if (targetValue === value) {
        return true;
      }
    }
    return false;
  },
  renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
    var column, e, equalToAboveCell, equalToBelowCell;
    try {
      column = metaData.column;
      if (column.cls) {
        metaData.tdCls += ' ' + column.cls;
      }
      if (value === record.raw._subTotalFor) {
        return "" + value + " Total";
      }
      if (column.mergeCell) {
        if (!value && column.hasValueOnTheLeft(record, rowIndex)) {
          return '';
        }
        equalToAboveCell = column.compareWithCell(value, store, rowIndex - 1, column.dataIndex);
        equalToBelowCell = column.compareWithCell(value, store, rowIndex + 1, column.dataIndex);
        if (equalToAboveCell && equalToBelowCell) {
          metaData.tdCls = metaData.tdCls + ' ' + column.emptyCellCls;
          return '';
        }
        if (!equalToAboveCell && equalToBelowCell) {
          metaData.tdCls = metaData.tdCls + ' ' + column.mergeCellStartCls;
        }
        if (equalToAboveCell && !equalToBelowCell) {
          metaData.tdCls = metaData.tdCls + ' ' + column.mergeCellEndCls;
          return '';
        }
      }
    } catch (_error) {
      e = _error;
      console.error(e);
    }
    return value;
  },
  listeners: {
    beforerender: function(me) {
      var firstCell, gridview, unusedWidth;
      gridview = me.up('grid').view;
      firstCell = Ext.DomQuery.select("td" + (me.getCellSelector()) + ":first")[0];
      if (firstCell) {
        me.width = firstCell.getBoundingClientRect().width;
      }
      unusedWidth = gridview.el.dom.scrollWidth - gridview.body.getWidth();
      if (unusedWidth > 0) {
        return me.width += Math.floor(unusedWidth / gridview.getGridColumns().length);
      }
    }
  }
});
