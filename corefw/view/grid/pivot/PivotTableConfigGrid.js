// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.pivot.PivotTableConfigGrid', {
  alias: 'widget.pivottablecfggrid',
  extend: 'Ext.grid.Panel',
  requires: ['Corefw.model.FilterCriteria', 'Corefw.model.PivotConfigItem'],
  model: 'Corefw.model.PivotConfigItem',
  height: '100%',
  minHeight: 105,
  selType: 'cellmodel',
  sharedUniqueness: {},
  plugins: {
    ptype: 'cellediting',
    clicksToEdit: 1
  },
  viewConfig: {
    plugins: {
      ptype: 'gridviewdragdrop',
      dragText: 'Drag and drop to reorganize',
      ddGroup: 'treeDrop'
    },
    listeners: {
      beforedrop: function(node, data, overModel, dropPosition, dropHandlers) {
        var leafRecords, procRecord, record, sameType, store, validDrop, _i, _len, _ref;
        store = this.getStore();
        sameType = data.view.xtype === this.xtype;
        if (sameType) {
          validDrop = true;
          procRecord = function(record, sameView) {
            var index, reason, valid, _ref;
            if (!sameView) {
              _ref = this.up('grid').recordValidate(null, record, sameType), valid = _ref[0], reason = _ref[1];
              if (!valid) {
                validDrop = false;
                if (reason) {
                  Corefw.Msg.alert('Invalid Config', reason);
                }
                return;
              }
            }
            if (record === store.last()) {
              index = store.indexOf(overModel);
              if (dropPosition === 'after') {
                index++;
              }
              return record.set('aggregate', store.getAt(index).get('aggregate'));
            }
          };
          _ref = data.records;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            record = _ref[_i];
            procRecord.call(this, record, data.view === this.view);
          }
          if (validDrop) {
            return dropHandlers.processDrop();
          } else {
            return dropHandlers.cancelDrop();
          }
        } else {
          leafRecords = [];
          data.records.forEach(function(record) {
            if (record.isLeaf()) {
              return leafRecords.push(record);
            } else if (Ext.isArray(record.childNodes)) {
              return leafRecords = leafRecords.concat(record.childNodes.filter(function(node) {
                return node.isLeaf();
              }));
            }
          });
          leafRecords.forEach(function(record) {
            var gridRecord, index, reason, valid, _ref1;
            gridRecord = Ext.create(this.up('grid').model);
            gridRecord.copyFrom(record, {
              name: 'text'
            });
            _ref1 = this.up('grid').recordValidate(gridRecord, record), valid = _ref1[0], reason = _ref1[1];
            if (!valid) {
              if (reason) {
                Corefw.Msg.alert('Invalid Config', reason);
              }
              return;
            }
            index = store.indexOf(overModel);
            if (index !== -1) {
              if (dropPosition === 'after') {
                index++;
              }
              return store.insert(index, gridRecord);
            } else {
              return store.add(gridRecord);
            }
          }, this);
          return dropHandlers.cancelDrop();
        }
      },
      drop: function(node, data, overModel, dropPosition) {
        this.getSelectionModel().select(this.getStore().getCount() - 1, false, false);
      }
    }
  },
  constructor: function(config) {
    var cfgName, col, colDef, storeMeta, _i, _len, _ref;
    this.columns = [];
    cfgName = config.cfgName || this.cfgName;
    _ref = config.displaying || this.displaying;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      col = _ref[_i];
      colDef = this.getColumnsMapping()[col];
      if (colDef.comboEditor) {
        storeMeta = colDef.comboEditor;
        if (Ext.isFunction(storeMeta)) {
          storeMeta = storeMeta();
        }
        colDef.editor = Ext.create('Ext.form.field.ComboBox', {
          typeAhead: true,
          triggerAction: 'all',
          selectOnTab: true,
          store: storeMeta,
          lazyRender: true
        });
      }
      if (col === 'name') {
        colDef.text = cfgName[1];
      }
      this.columns.push(colDef);
    }
    this.columns.push(this.getColumnsMapping().action);
    return this.callParent(arguments);
  },
  getGridName: function() {
    return this.cfgName[0];
  },
  bindStore: function(store) {
    this.callParent(arguments);
    return this.mon(store, {
      add: this.onStoreChange,
      remove: this.onStoreChange,
      scope: this
    });
  },
  onStoreChange: function() {
    var lastRecord, penultimateRecord, records;
    records = this.getStore().getRange();
    if (records.length) {
      lastRecord = records[records.length - 1];
      penultimateRecord = records[records.length - 2];
      lastRecord.set('aggregate', false);
      this.view.refreshNode(this.getStore().indexOf(lastRecord));
      if (penultimateRecord) {
        return this.view.refreshNode(this.getStore().indexOf(penultimateRecord));
      }
    }
  },
  recordValidate: function(newRecord, draggedRecord, sameType) {
    var exists, scopeName, store, _ref;
    if (sameType) {
      return [true];
    }
    _ref = this.sharedUniqueness;
    for (scopeName in _ref) {
      store = _ref[scopeName];
      exists = store.indexOfId(newRecord.get('path')) > -1;
      if (exists) {
        return [false, "This item is already in " + scopeName];
      }
    }
    return [this.getStore().indexOfId(newRecord.get('path')) === -1];
  },
  getColumnsMapping: function() {
    return this.columnsMapping;
  },
  columnsMapping: {
    name: {
      menuDisabled: true,
      text: '',
      dataIndex: 'name',
      flex: 1
    },
    aggregate: {
      menuDisabled: true,
      xtype: 'pivotcfgcheckcolumn',
      text: 'Subtotal',
      dataIndex: 'aggregate'
    },
    sortby: {
      menuDisabled: true,
      xtype: 'gridcolumn',
      text: 'Sort By',
      dataIndex: 'sortby',
      comboEditor: ['ASC', 'DESC']
    },
    aggregation: {
      menuDisabled: true,
      text: 'Aggregation',
      dataIndex: 'aggregation',
      comboEditor: ['Sum', 'Average', 'Count', 'Max', 'Min']
    },
    action: {
      menuDisabled: true,
      xtype: 'actioncolumn',
      width: 50,
      items: [
        {
          iconCls: 'icon-delete',
          tooltip: 'Delete',
          handler: function(grid, rowIndex) {
            return grid.getStore().removeAt(rowIndex);
          }
        }
      ]
    }
  }
});
