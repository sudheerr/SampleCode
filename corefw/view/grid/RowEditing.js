// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.grid.RowEditing', {
  extend: 'Ext.grid.plugin.RowEditing',
  xtype: 'corerowediting',
  rowHeight: 29,
  recordsAdded: [],
  comboboxOriginalValues: {},
  helper: Corefw.util.RowEditorHelper,
  serverData: {},
  listeners: {
    edit: function(editor, context) {
      var grid, iv;
      grid = context.grid;
      grid.isEditing = false;
      grid.stopFireEvents = false;
      this.hideMask();
      this.helper.sendData(editor.context, 'update');
      iv = Corefw.util.InternalVar;
      iv.setByNameProperty('roweditor', 'restoreinfo', null);
      return iv.setByNameProperty('roweditor', 'needPostEditedData', false);
    },
    beforeedit: function(editor, context) {
      var grid, iv;
      grid = context.grid;
      iv = Corefw.util.InternalVar;
      iv.setByNameProperty('roweditor', 'cancelEdit', false);
      iv.setByNameProperty('roweditor', 'suspendChangeEvents', true);
      grid.setLoading('Data Processing...');
      context.record.isEditing = true;
      if (editor) {
        context.serverData = {};
      }
      if (!this.isSkipBeforeEdit) {
        this.helper.beforeEdit(context, editor.editor);
      }
      if (this.isNotEditable(grid)) {
        grid.isEditing = false;
        return false;
      }
      this.initGridLayout();
    }
  },
  startEdit: function(record, columnHeader) {
    var editor, ft, grid, isReadOnly, iv, _ref, _ref1, _ref2, _ref3;
    grid = this.grid;
    iv = Corefw.util.InternalVar;
    if (grid.rowEditor.editing) {
      return;
    }
    if (grid.xtype !== 'coretreebase') {
      this.recordIndex = grid.store.indexOf(record);
    } else {
      this.recordIndex = grid.getNodeIndex(record);
    }
    this.columnIndex = grid.columnManager.getHeaderIndex(columnHeader);
    if ((_ref = columnHeader.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.events['ONBLUR'] : void 0 : void 0) {
      ++this.columnIndex;
    }
    isReadOnly = (grid != null ? (_ref2 = grid.cache) != null ? (_ref3 = _ref2._myProperties) != null ? _ref3.readOnly : void 0 : void 0 : void 0) || false;
    grid.isEditing = true;
    if (grid.stopOpeningEditor) {
      grid.stopOpeningEditor = false;
      return;
    }
    if (isReadOnly || this.helper.processProhibited(grid, record)) {
      grid.isEditing = false;
      return;
    }
    if (!this.view.body) {
      this.view.body = this.view;
    }
    this.origRowData = Ext.clone(record.getData());
    this.callParent(arguments);
    if (this.isNotEditable(grid)) {
      grid.isEditing = false;
      return false;
    }
    editor = this.editor;
    if (!editor || !editor.el) {
      return;
    }
    ft = grid != null ? grid.up('fieldcontainer') : void 0;
    if (ft != null) {
      ft.valueChanged = true;
    }
    record.isEditing = true;
    if (this.elementLayoutType === 'VBOX') {
      this.configureEditorVboxLayout();
    } else {
      this.configureEditorAbsoluteLayout();
    }
    editor.syncFieldsHorizontalScroll();
    this.helper.startEdit(editor, columnHeader);
    iv.setByNameProperty('roweditor', 'suspendChangeEvents', false);
    grid.setLoading(false);
    this.preventBackspaceEventOnRowEditing();
    this.showMask(this.grid);
  },
  completeEdit: function() {
    if (this.isProcessingEvent) {
      this.shouldResumeUpdating = true;
      return;
    } else {
      this.shouldResumeUpdating = false;
      this.callParent(arguments);
    }
  },
  restoreEditor: function(host, recordIndex, columnIndex) {
    var column, record, _ref, _ref1;
    if (host == null) {
      host = this.grid;
    }
    if (recordIndex == null) {
      recordIndex = this.recordIndex;
    }
    if (columnIndex == null) {
      columnIndex = this.columnIndex;
    }
    host.stopFireEvents = true;
    record = (_ref = host.store) != null ? typeof _ref.getAt === "function" ? _ref.getAt(recordIndex) : void 0 : void 0;
    column = (_ref1 = host.columnManager) != null ? typeof _ref1.getHeaderAtIndex === "function" ? _ref1.getHeaderAtIndex(columnIndex) : void 0 : void 0;
    if (record && column && host.isEditing) {
      this.startEdit(record, column);
      Corefw.util.InternalVar.setByNameProperty('roweditor', 'cancelEdit', true);
    }
    host.stopFireEvents = false;
  },
  isNotEditable: function(grid) {
    var cancelEdit, currRowMetaData, editable, iv, props, readOnly, rowsData, _ref, _ref1, _ref2;
    iv = Corefw.util.InternalVar;
    props = ((_ref = grid.cache) != null ? _ref._myProperties : void 0) || {};
    rowsData = ((_ref1 = props.data) != null ? _ref1.items : void 0) || [];
    currRowMetaData = (_ref2 = rowsData[this.recordIndex]) != null ? _ref2._myProperties : void 0;
    readOnly = (currRowMetaData != null ? currRowMetaData.readOnly : void 0) || false;
    editable = currRowMetaData && currRowMetaData.hasOwnProperty('editable') ? currRowMetaData.editable : true;
    cancelEdit = iv.getByNameProperty('roweditor', 'cancelEdit');
    if (cancelEdit || (currRowMetaData && (readOnly || !editable))) {
      grid.setLoading(false);
      return true;
    } else {
      return false;
    }
  },
  adjustButtonPlacement: function(rowIndex) {
    var btns, editor, editorHeight, editorY, grid, gridHeight, rowHeight;
    grid = this.grid;
    gridHeight = grid.getHeight();
    rowHeight = this.rowHeight;
    editor = this.editor;
    editorHeight = editor.getHeight();
    editorHeight += rowHeight;
    editorY = editor.getLocalY();
    btns = editor.floatingButtons;
    if ((editorY + editorHeight + btns.getHeight()) > gridHeight) {
      btns = editor.floatingButtons;
      btns.setLocalY(-rowHeight);
    }
  },
  configureEditorVboxLayout: function() {
    var adjustment, adjustmentGridHeight, btns, buttonHeight, cm, editor, editorHeight, gridField, gridHeight, maxHeight, minHeight, newLocalY, record, rowHeight, rowIndex, store;
    rowHeight = this.rowHeight;
    buttonHeight = this.rowHeight;
    editor = this.editor;
    if (!editor.el) {
      return;
    }
    editorHeight = editor.getHeight();
    gridField = this.grid.up();
    gridHeight = this.origGridHeight;
    record = this.context.record;
    store = this.context.record.store;
    cm = Corefw.util.Common;
    rowIndex = cm.findRecordIndex(store, record);
    btns = editor.floatingButtons;
    btns.setLocalY(editorHeight);
    btns.setHeight(buttonHeight);
    if (editorHeight < 35 && rowIndex > 2) {
      gridField.setHeight(gridHeight);
      this.adjustButtonPlacement(rowIndex);
      return;
    }
    adjustment = (editorHeight / 2) - (rowHeight / 2);
    newLocalY = editor.getLocalY() - adjustment;
    editorHeight += rowHeight;
    editor.setLocalY(newLocalY);
    maxHeight = gridField.maxHeight;
    minHeight = gridField.minHeight;
    delete gridField.maxHeight;
    delete gridField.minHeight;
    if (newLocalY + editorHeight < gridHeight) {
      gridField.setHeight(gridHeight);
    } else {
      adjustmentGridHeight = editor.getLocalY() + editorHeight + rowHeight / 2;
      gridField.setHeight(adjustmentGridHeight);
    }
    if (maxHeight) {
      gridField.maxHeight = maxHeight;
    }
    if (minHeight) {
      gridField.minHeight = minHeight;
    }
  },
  configureEditorAbsoluteLayout: function(record) {
    var btnPosition, btns, cm, currRowFromEnd, editor, editorHeight, grid, gridHeight, i, mod, numRows, placeEditor, rowHeight, rowIndex, rowsAdded, rowsFromEndNeedSpace, rowsToAdd, store, _i;
    rowHeight = this.rowHeight;
    editor = this.editor;
    if (!editor.el) {
      return;
    }
    editorHeight = editor.getHeight();
    if (editorHeight < 35) {
      return;
    }
    grid = this.grid;
    gridHeight = grid.getHeight();
    rowsFromEndNeedSpace = Math.floor((editorHeight / 2) / rowHeight) + 1;
    this.rowsFromEndNeedSpace = rowsFromEndNeedSpace;
    store = grid.store;
    numRows = store.getCount();
    cm = Corefw.util.Common;
    rowIndex = cm.findRecordIndex(store, record);
    currRowFromEnd = numRows - (rowIndex + 1);
    btns = editor.floatingButtons;
    btnPosition = btns.position;
    if (currRowFromEnd < rowsFromEndNeedSpace) {
      rowsAdded = true;
      rowsToAdd = Math.floor(((editorHeight / 2) - (currRowFromEnd * rowHeight)) / rowHeight) + 1;
      this.recordsAdded = [];
      for (i = _i = 0; 0 <= rowsToAdd ? _i < rowsToAdd : _i > rowsToAdd; i = 0 <= rowsToAdd ? ++_i : --_i) {
        mod = store.add({});
        this.recordsAdded.push(mod[0]);
      }
      grid.getView().scrollBy(0, 999, false);
    }
    placeEditor = Ext.Function.createDelayed(function() {
      var adjustment, bottomY, newLocalY;
      adjustment = (editorHeight / 2) - (rowHeight / 2);
      newLocalY = editor.getLocalY() - adjustment;
      gridHeight = grid.getHeight();
      bottomY = gridHeight - editorHeight;
      if (rowsAdded) {
        newLocalY = bottomY;
      }
      editor.setLocalY(newLocalY);
      if (btnPosition === 'bottom') {
        btns.setLocalY(editorHeight);
      } else {
        btns.setLocalY(-rowHeight);
      }
      return btns.setHeight(rowHeight);
    }, 1);
    placeEditor();
  },
  cancelEdit: function() {
    var ft, grid, record;
    this.suspendChangeEvents = true;
    this.cleanAfterEdit();
    grid = this.context.grid;
    grid.stopFireEvents = false;
    ft = grid.ownerCt;
    if (ft != null) {
      ft.valueChanged = true;
    }
    grid.isEditing = false;
    record = this.context.record;
    this.helper.updateRecord(record, this.origRowData, true);
    record.commit();
    record.dirty = true;
    this.helper.cancelEdit(this.context);
    this.hideMask();
    this.callParent(arguments);
    Corefw.util.InternalVar.setByNameProperty('roweditor', 'restoreinfo', null);
    delete this.suspendChangeEvents;
  },
  validateEdit: function() {
    var context, disabledNonComboboxField, disabledNonComboboxFields, editor, formRecord, passValidate, _i, _len;
    passValidate = this.callParent(arguments);
    if (passValidate) {
      editor = this.editor;
      context = this.context;
      formRecord = context.record;
      disabledNonComboboxFields = editor.query('>[editable=true][disabled=true]:not(combobox)');
      for (_i = 0, _len = disabledNonComboboxFields.length; _i < _len; _i++) {
        disabledNonComboboxField = disabledNonComboboxFields[_i];
        if (disabledNonComboboxField.getValue) {
          formRecord.set(disabledNonComboboxField.name, disabledNonComboboxField.getValue());
        }
      }
      this.cleanAfterEdit();
    }
    return passValidate;
  },
  cleanAfterEdit: function() {
    var gp, grid, gridField, gridpickers, recAddedArray, store, _i, _len;
    grid = this.grid;
    gridField = grid.up();
    store = grid.store;
    recAddedArray = this.recordsAdded;
    if (recAddedArray && recAddedArray.length && store.remove) {
      if (typeof store.remove === "function") {
        store.remove(recAddedArray);
      }
    }
    if (this.elementLayoutType === 'VBOX') {
      if (this.origMaxHeight != null) {
        gridField.maxHeight = this.origMaxHeight;
      }
      gridField.setHeight(this.origGridHeight);
      this.context.row.setAttribute('style', null);
    }
    gridpickers = this.editor.query('>roweditorgridpicker');
    for (_i = 0, _len = gridpickers.length; _i < _len; _i++) {
      gp = gridpickers[_i];
      gp.hideGridWindow();
    }
    this.recordsAdded = [];
  },
  initGridLayout: function() {
    var elementUp, grid, gridField, gridHeight, layoutType, _ref, _ref1, _ref2;
    grid = this.grid;
    elementUp = grid.up('coreelementform');
    layoutType = (_ref = elementUp.cache) != null ? (_ref1 = _ref._myProperties) != null ? (_ref2 = _ref1.layout) != null ? _ref2.type : void 0 : void 0 : void 0;
    this.originalGridHeight = gridHeight = grid.getHeight();
    this.origGridHeight = gridHeight;
    this.elementLayoutType = layoutType;
    if (layoutType === 'VBOX') {
      gridField = grid.up();
      this.origGridHeight = gridField.getHeight();
      this.origMaxHeight = gridField.maxHeight;
      gridHeight = gridField.getHeight();
      gridField.setHeight(gridHeight + 150);
    }
  },
  preventBackspaceEventOnRowEditing: function() {
    var cm, _dom, _ref, _ref1;
    cm = Corefw.util.Common;
    _dom = (_ref = this.editor) != null ? (_ref1 = _ref.el) != null ? _ref1.dom : void 0 : void 0;
    if (!_dom) {
      return;
    }
    if (_dom != null) {
      _dom.onkeydown = cm.preventBackspaceEvent;
    }
  },
  showMask: function(grid) {
    var body, mask, showEditingMask, _ref, _ref1;
    showEditingMask = true;
    if (!(grid && grid.el)) {
      showEditingMask = false;
    } else if (((_ref = grid.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.showEditingMask : void 0 : void 0) === false) {
      showEditingMask = false;
    }
    if (showEditingMask === false) {
      return;
    }
    mask = Ext.get('global');
    body = Ext.getBody();
    if (!mask) {
      mask = Ext.getBody().createChild({
        tag: 'div',
        "class": Ext.baseCSSPrefix + 'mask',
        id: 'global',
        style: ['z-index:4', 'width:' + body.getWidth(), 'height:' + body.getHeight(), 'right:auto', 'left:0px', 'top:0px', 'visibility:hidden'].join(';')
      });
    }
    grid.z_index = grid.el.dom.style.zIndex;
    grid.el.setStyle('z-index', 5);
    mask.show();
    this.mask = mask;
  },
  hideMask: function() {
    var grid, _ref;
    grid = this.grid;
    if (!(grid && grid.el && this.mask)) {
      return;
    }
    grid.el.dom.style['z-index'] = grid.z_index;
    if ((_ref = this.mask) != null) {
      _ref.remove();
    }
    delete this.mask;
  }
});
