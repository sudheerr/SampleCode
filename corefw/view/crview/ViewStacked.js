// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.crview.ViewStacked', {
  extend: 'Ext.panel.Panel',
  xtype: 'coreviewstacked',
  listeners: {
    beforecollapse: function() {
      var cef, me;
      me = this;
      cef = this.down('coreelementform[collapsed=false]');
      if (cef.title) {
        return me.setTitle(cef.title);
      } else {
        return me.setTitle('&nbsp;');
      }
    }
  },
  initComponent: function() {
    var cache, comp, config, props, su, uc;
    uc = Corefw.util.Common;
    su = Corefw.util.Startup;
    cache = this.cache;
    props = cache._myProperties;
    config = {
      layout: 'auto',
      padding: '10 0',
      overflowY: 'auto',
      cls: 'viewstacked-cls',
      items: [
        {
          xtype: 'panel',
          cls: 'viewstacked-panel-cls',
          ui: 'citirisk-view-innerpanel',
          layout: {
            type: 'vbox',
            align: 'stretch'
          },
          listeners: {
            resize: this.updateLayoutWhenResize
          }
        }
      ]
    };
    if (this.needFullHeight()) {
      config.layout = 'fit';
    }
    if (props.hasSubnav || props.subnavigator) {
      config.padding = 0;
      config.layout = 'fit';
    }
    uc.setThemeByGlobalVariable(su.getStartupObj().application, 'view', config);
    Ext.apply(this, config);
    this.configProps();
    this.callParent(arguments);
    comp = this.down('panel');
    comp.cache = cache;
    comp.layoutManager = Corefw.view.layout.Layout.create(comp, cache != null ? cache._myProperties : void 0);
    this.innerPanel = comp;
    this.layoutManager = comp.layoutManager;
    this.genElementDefs(comp, cache);
  },
  updateUIData: function(viewCache) {
    var childCache, childProps, cm, coretype, evt, innerPanel, key, me, newTooltip, oldTooltip, props, rd, _ref, _ref1, _ref2, _ref3;
    cm = Corefw.util.Common;
    rd = Corefw.util.Render;
    props = viewCache._myProperties;
    me = this;
    cm.updateCommon(me, props);
    oldTooltip = (_ref = me.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.toolTip : void 0 : void 0;
    newTooltip = props.toolTip;
    if (oldTooltip !== newTooltip) {
      if ((_ref2 = me.tab) != null) {
        _ref2.setTooltip(newTooltip);
      }
    }
    innerPanel = me.innerPanel;
    me.cache = viewCache;
    innerPanel.cache = viewCache;
    me.genElementDefs(innerPanel, viewCache);
    me.updateMessages(props);
    if (me.tab) {
      rd.loadErrors(me.tab, props);
    }
    if (!me.rendered) {
      return;
    }
    evt = Corefw.util.Event;
    if (this.viewONREFRESHevent) {
      evt.fireRenderEvent(this);
    }
    for (key in viewCache) {
      childCache = viewCache[key];
      if (key === '_myProperties') {
        continue;
      }
      childProps = childCache._myProperties;
      coretype = childProps != null ? (_ref3 = childProps.coretype) != null ? _ref3.toLowerCase() : void 0 : void 0;
      switch (coretype) {
        case 'element':
        case 'compositeelement':
          me.updateChildren(childCache);
      }
    }
    me.updateVisual(props);
  },
  replaceChild: function(elementCache, ev, isAncestorUpdating) {
    var elemComp, elementDef, name, panel, props, uip, uipath;
    uip = Corefw.util.Uipath;
    panel = this.innerPanel;
    if (!panel) {
      return;
    }
    props = elementCache._myProperties;
    name = props.name;
    uipath = props.uipath;
    elemComp = uip.uipathToComponent(uipath);
    if (!elemComp && !props.visible) {
      return;
    }
    if (!isAncestorUpdating) {
      Ext.suspendLayouts();
    }
    this.cache[name] = elementCache;
    if (elemComp) {
      props = elementCache._myProperties;
      elemComp.updateUIData(elementCache);
    } else {
      elementDef = this.genElementDef(elementCache);
      this.layoutManager.add(elementDef);
    }
    if (!isAncestorUpdating) {
      Ext.resumeLayouts(true);
    }
  },
  genElementDefs: function(comp, viewCache) {
    var elemCache, elemKey, elemProps, elementDef, elementDefs;
    elementDefs = [];
    for (elemKey in viewCache) {
      elemCache = viewCache[elemKey];
      elemProps = elemCache != null ? elemCache._myProperties : void 0;
      if (elemKey !== '_myProperties' && !(elemProps != null ? elemProps.isRemovedFromUI : void 0) && (elemProps != null ? elemProps.visible : void 0)) {
        elementDef = this.genElementDef(elemCache);
        if (elementDef) {
          elementDefs.push(elementDef);
        }
      }
    }
    comp.contentDefs = elementDefs;
  },
  genElementDef: function(elementCache) {
    var compType, compTypeMap, elementDef, props, widgetType;
    props = elementCache._myProperties;
    if (!props) {
      return;
    }
    compTypeMap = {
      FORM_BASED_ELEMENT: 'coreelementform',
      BAR_ELEMENT: 'coreelementbar',
      COMPOSITE_ELEMENT: 'corecompositeelement'
    };
    widgetType = props.widgetType;
    compType = compTypeMap[widgetType];
    if (!compType) {
      return;
    }
    elementDef = {
      xtype: compType,
      cache: elementCache
    };
    return elementDef;
  },
  updateChildren: function(elementCache) {
    this.replaceChild(elementCache, '', true);
  },
  needFullHeight: function() {
    var index, layoutItem, layoutItems, _ref, _ref1, _ref2;
    layoutItems = (_ref = this.cache) != null ? (_ref1 = _ref._myProperties) != null ? (_ref2 = _ref1.layout) != null ? _ref2.items : void 0 : void 0 : void 0;
    for (index in layoutItems) {
      layoutItem = layoutItems[index];
      if (layoutItem.flex) {
        return true;
      }
    }
    return false;
  },
  addElements: function() {
    var rdr;
    rdr = Corefw.util.Render;
    this.layoutManager.initLayout();
    rdr.renderNavs(this.cache._myProperties, this.innerPanel);
  },
  updateLayoutWhenResize: function(innerPanel) {
    var delayedFn, elements, needLayout, needUpdateLayout, view;
    needUpdateLayout = function(view) {
      var hasScrollBar, viewEl, viewInnerPanelEl, viewSize;
      viewEl = view.el;
      viewInnerPanelEl = view.innerPanel.el;
      viewSize = viewEl.getSize(true);
      hasScrollBar = false;
      if (!(view.layout instanceof Ext.layout.container.Auto)) {
        return false;
      }
      if (viewSize.height < viewInnerPanelEl.getHeight()) {
        hasScrollBar = true;
      }
      if ((view.hasScrollbar && !hasScrollBar) || (!view.hasScrollBar && hasScrollBar)) {
        view.hasScrollbar = hasScrollBar;
        return true;
      }
      return false;
    };
    view = innerPanel.up('coreviewstacked');
    needLayout = needUpdateLayout(view);
    if (needLayout) {
      elements = view.query('coreelementform[collapsed=false]');
      Ext.each(elements, function(element) {
        element.alreadyResize = false;
      });
      delayedFn = Ext.Function.createDelayed(function() {
        view.updateLayout();
      }, 1);
      delayedFn();
    }
  },
  configProps: function() {
    var cache, config, errArray, evt, isWorkflowView, parentCache, props, su, uip, _ref, _ref1, _ref2;
    evt = Corefw.util.Event;
    uip = Corefw.util.Uipath;
    su = Corefw.util.Startup;
    cache = this.cache;
    props = cache._myProperties;
    parentCache = uip.uipathToParentCacheItem(props.uipath);
    isWorkflowView = (parentCache != null ? (_ref = parentCache._myProperties) != null ? (_ref1 = _ref.layout) != null ? _ref1.style : void 0 : void 0 : void 0) === 'WORKFLOW_SEQUENTIAL' || 'WORKFLOW_NON_SEQUENTIAL';
    config = {
      uipath: props.uipath,
      coretype: 'view',
      closable: false,
      border: 1,
      hideCollapseTool: false,
      header: false,
      titleCollapse: false,
      hidden: !props.visible,
      disabled: !props.enabled
    };
    if (props.title) {
      config.errArray = errArray = (_ref2 = props.messages) != null ? _ref2.ERROR : void 0;
      config.title = props.title + (!isWorkflowView && errArray && errArray.length ? "<span style=\"color:#f00;\">(" + errArray.length + ")</span>" : '');
    } else {
      config.header = false;
      config.tabBar = {
        hidden: true
      };
    }
    if (props.toolTip) {
      config.tabConfig = {
        tooltip: props.toolTip + '\n<br>'
      };
    }
    if (props.hideBorder) {
      config.border = false;
    }
    if (props.closable) {
      config.closable = true;
    }
    evt.addEvents(props, 'view', config);
    this.renderMessages(props);
    if (su.getThemeVersion() === 2) {
      config.padding = 6;
      if (props.popup) {
        config.padding = 0;
      }
      if (props.hasSubnav || props.subnavigator) {
        config.padding = '6 0 0 0';
      }
    }
    Ext.apply(this, config);
    Corefw.customapp.Main.mainEntry('viewInit', this);
    this.addListeners();
  },
  renderMessages: function(props, isAncestorUpdating) {
    var items, statusMsgs, statusView;
    props = props || this.cache._myProperties;
    if (props.messages) {
      statusMsgs = this.getStatusMessages(props.messages);
      if (statusMsgs.length > 0) {
        statusView = Ext.create('Corefw.view.StatusView', {
          statusMsgs: statusMsgs
        });
        items = this.items;
        if (isAncestorUpdating) {
          items = items.items;
        }
        if (this.rendered) {
          this.insert(0, statusView);
        } else {
          items.unshift(statusView);
        }
      }
    }
  },
  updateMessages: function(props) {
    var statusView;
    statusView = this.down('statusview');
    if (statusView && statusView.ownerCt === this) {
      this.remove(statusView);
    }
    this.renderMessages(props, true);
  },
  addListeners: function() {
    var additionalListeners;
    this.listeners = this.listeners || {};
    additionalListeners = {
      beforedestroy: this.onViewDestroy,
      beforerender: this.onViewBeforeRender
    };
    Ext.apply(this.listeners, additionalListeners);
  },
  onViewDestroy: function() {
    var rdr;
    rdr = Corefw.util.Render;
    rdr.destroyThisComponent(this);
  },
  onViewBeforeRender: function() {
    if (this.up('[removingChild=true]')) {
      return false;
    }
    return true;
  },
  onRender: function() {
    var evt;
    evt = Corefw.util.Event;
    this.callParent(arguments);
    if (this.viewONLOADevent || this.viewONREFRESHevent) {
      evt.fireRenderEvent(this);
    }
  },
  afterRender: function() {
    var delayHeight, evt, me, rdr, viewReEnable;
    this.callParent(arguments);
    rdr = Corefw.util.Render;
    evt = Corefw.util.Event;
    this.addElements();
    me = this;
    delayHeight = Ext.Function.createDelayed(function() {
      var expectedHeight, extraHeight, heightStyle, heightStyles, popupBodyTop, popupHeight, popupWindow, props, tabpanel, _i, _j, _len, _len1, _ref;
      popupWindow = me.up('coreperspectivewindow');
      if (popupWindow && popupWindow.cache._myProperties.height) {
        popupHeight = popupWindow.getHeight();
        popupBodyTop = popupWindow.body.getStyle('top');
        heightStyles = ['border-top-width', 'border-bottom-width', 'padding-top', 'padding-bottom'];
        extraHeight = 0;
        for (_i = 0, _len = heightStyles.length; _i < _len; _i++) {
          heightStyle = heightStyles[_i];
          extraHeight += parseInt(popupWindow.body.getStyle(heightStyle));
        }
        for (_j = 0, _len1 = heightStyles.length; _j < _len1; _j++) {
          heightStyle = heightStyles[_j];
          extraHeight += parseInt(popupWindow.getEl().getStyle(heightStyle));
        }
        expectedHeight = parseInt(popupBodyTop) + me.getHeight() + extraHeight;
        if (expectedHeight < popupHeight) {
          popupWindow.setHeight(expectedHeight);
          popupWindow.doLayout();
        }
      }
      if (!me.title) {
        if (me.tab) {
          me.tab.hide();
        }
        tabpanel = me.up('tabpanel');
        if (tabpanel) {
          tabpanel.tabBar.hide();
        }
      }
      props = (_ref = me.cache) != null ? _ref._myProperties : void 0;
      if (props && !props.workflowType) {
        rdr.loadErrors(me.tab, props);
      }
    }, 1);
    delayHeight();
    viewReEnable = Ext.Function.createDelayed(function() {
      evt.enableUEvent(me.uipath, 'ONCLOSE');
    }, 10000);
    viewReEnable();
  },
  getStatusMessages: function(messageObj) {
    var msg, msgArray, msgType, newStatusMsg, statusMsgs, typesOfMessages, _i, _j, _len, _len1;
    statusMsgs = [];
    typesOfMessages = ['ERROR', 'WARNING', 'SUCCESS', 'INFORMATION'];
    for (_i = 0, _len = typesOfMessages.length; _i < _len; _i++) {
      msgType = typesOfMessages[_i];
      msgArray = messageObj[msgType];
      if (msgArray && msgArray.length) {
        for (_j = 0, _len1 = msgArray.length; _j < _len1; _j++) {
          msg = msgArray[_j];
          newStatusMsg = {
            level: msgType.toLowerCase(),
            text: msg
          };
          statusMsgs.push(newStatusMsg);
        }
      }
    }
    return statusMsgs;
  },
  getActiveStatus: function() {
    var parentComponent, props, uip;
    uip = Corefw.util.Uipath;
    props = this.cache._myProperties;
    if (props.popup) {
      return true;
    }
    parentComponent = uip.uipathToParentComponent(this.uipath);
    if (!parentComponent) {
      return true;
    }
    return parentComponent.getActiveTab() === this;
  },
  generatePostData: function() {
    var compArray, elemComp, elementPostData, elementsArray, postData, _i, _len;
    elementsArray = [];
    postData = {
      name: this.cache._myProperties.name,
      allContents: elementsArray,
      active: this.getActiveStatus()
    };
    compArray = this.query('panel > coreelementform, panel > corecompositeelement');
    for (_i = 0, _len = compArray.length; _i < _len; _i++) {
      elemComp = compArray[_i];
      elementPostData = elemComp.generatePostData();
      elementsArray.push(elementPostData);
    }
    return postData;
  },
  disableOncloseEvents: function() {
    var iv;
    iv = Corefw.util.InternalVar;
    iv.setByUipathProperty(this.uipath, 'suppressClosing', true);
  },
  enableOncloseEvents: function() {
    var iv;
    iv = Corefw.util.InternalVar;
    iv.setByUipathProperty(this.uipath, 'suppressClosing', false);
  },
  isOncloseEventDisabled: function() {
    var iv, parentUipath, suppressClosing, uip, uipath;
    iv = Corefw.util.InternalVar;
    uip = Corefw.util.Uipath;
    uipath = this.uipath;
    suppressClosing = iv.getByUipathProperty(uipath, 'suppressClosing');
    if (suppressClosing) {
      return true;
    }
    parentUipath = uip.uipathToParentUipath(uipath);
    suppressClosing = iv.getByUipathProperty(parentUipath, 'suppressClosing');
    return suppressClosing;
  },
  hasUpload: function() {
    var form, forms, _i, _len;
    forms = this.query('form');
    for (_i = 0, _len = forms.length; _i < _len; _i++) {
      form = forms[_i];
      if (form.getForm().hasUpload()) {
        return true;
      }
    }
    return false;
  },
  updateRelatedCache: function(json) {
    return Ext.merge(this.cache._myProperties, json);
  },
  updateVisual: function(json) {
    this.updateSelfVisual(json);
    return this.updateWorkflowVisual(json);
  },
  updateSelfVisual: function(json) {
    if (json.enabled) {
      return this.enable();
    }
  },
  updateWorkflowVisual: function(json) {
    var status, step, stepUipath;
    stepUipath = json.uipath + '/progressStep';
    step = Ext.ComponentQuery.query('[uipath=' + stepUipath + ']')[0];
    if (step) {
      status = step.calStatus(json);
      if (status !== step.status) {
        step.setStatus(status);
      }
    }
  }
});
