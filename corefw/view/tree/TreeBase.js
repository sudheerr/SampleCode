// Generated by CoffeeScript 1.8.0

/*
	creates a standard tree, with extra functions for Core Framework
 */
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Ext.define('Corefw.view.tree.TreeBase', {
  extend: 'CitiRiskLibrary.view.CitiRiskTreePanel',
  xtype: 'coretreebase',
  mixins: ['Corefw.mixin.Grid'],
  viewConfig: {
    getRowClass: function(record, index, rowParams, ds) {
      var cls;
      cls = [];
      if (this.ownerCt.isNodeDisabled(record)) {
        cls.push('treenode-disabled');
      }
      if (record.raw.semiSelected && record.get('checked')) {
        cls.push('x-checkbox-semi');
      }
      if (record.raw.matching) {
        cls.push('x-tree-node-mark');
      }
      return cls.join(' ');
    }
  },
  plugins: {
    ptype: 'inlinefilter'
  },
  initComponent: function() {
    this.initializeTreeBase();
    this.addTreeListeners();
    this.callParent(arguments);
  },
  initializeTreeBase: function() {
    var cache, columns, props, su, viewConfig, _ref, _ref1;
    cache = this.cache;
    props = cache != null ? cache._myProperties : void 0;
    su = Corefw.util.Startup;
    this.configurePlugins(props, false);
    viewConfig = {
      listeners: {
        viewready: this.expandAllNodesOnViewReady
      }
    };
    if (this.viewConfig) {
      Ext.merge(this.viewConfig, viewConfig);
    } else {
      this.viewConfig = viewConfig;
    }
    this.rootVisible = false;
    if ((_ref = this.selectType) === 'single' || _ref === 'SINGLE') {
      this.viewType = 'treeradioview';
      this.setColumnOption('treeradiocolumn');
    } else if (((_ref1 = this.selectType) === 'multiple' || _ref1 === 'MULTIPLE') && props.widgetType !== 'TREE_GRID') {
      this.setColumnOption('treecheckboxcolumn');
    }
    if (!su.useClassicTheme()) {
      this.ui = 'citirisktreeview';
      if (su.getThemeVersion() === 2) {
        this.ui = 'citirisktreeui';
        if (props.titleBackgroundIsWhite && !this.lines) {
          this.ui = 'latticetreelinesui';
        }
        if ((props != null ? props.widgetType : void 0) === 'TREE_GRID') {
          this.addCls('nolinescls');
        }
      }
    }
    this.setTreeSelectMode(props != null ? props.multiSelectable : void 0);
    if (!props || props.widgetType !== 'TREE_GRID') {
      return;
    }
    columns = this.columns;
    this.createColumnsFromCache(columns, columns);
    if (props.numberOfLockedHeaders > 0) {
      this.isLockedView = true;
    }
    this.configSelType();
  },
  addTreeListeners: function() {
    var listeners;
    this.listeners = this.listeners || {};
    listeners = {
      beforeselect: this.beforeItemSelect,
      checkchange: this.itemCheckChange
    };
    Ext.merge(this.listeners, listeners);
    return this.addListeners();
  },
  setColumnOption: function(columnXType) {
    if (this.hideHeaders === void 0) {
      this.hideHeaders = true;
    }
    this.addCls(this.autoWidthCls);
    this.columns = [
      {
        xtype: columnXType,
        text: 'Name',
        dataIndex: this.displayField
      }
    ];
  },
  isNodeDisabled: function(nodeOrModel) {
    var _ref;
    return nodeOrModel != null ? (_ref = nodeOrModel.raw) != null ? _ref.disabled : void 0 : void 0;
  },
  setTreeSelectMode: function(isMultiSelect) {
    if (isMultiSelect) {
      this.selModel = {
        xtype: 'rowmodel',
        mode: 'MULTI'
      };
    }
  },
  setNodeDisabled: function(node) {
    var className, htmlelement, treeview;
    if (this.isNodeDisabled(node)) {
      className = ' treenode-disabled';
      treeview = this.getView();
      htmlelement = treeview.getNode(node);
      if (htmlelement.className.indexOf(className) < 0) {
        htmlelement.className += className;
      }
    }
  },
  getNodeIndex: function(node, parent, counter) {
    var pn, _i, _len, _ref;
    if (parent == null) {
      parent = this.store.tree.root;
    }
    if (counter == null) {
      counter = -1;
    }
    _ref = parent.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pn = _ref[_i];
      if (node.stop) {
        delete node.stop;
        return counter;
      }
      counter++;
      if (node === pn) {
        node.stop = true;
        return counter;
      } else {
        counter = this.getNodeIndex(node, pn, counter);
      }
    }
    return counter;
  },
  beforeItemSelect: function(rowmodel, rec, index) {
    if (this.isNodeDisabled(rec)) {
      return false;
    }
    return true;
  },
  itemCheckChange: function(node, newCheckState, eOpts) {
    var allTopLevelNodes, allnodes, bubleUp, cascadeCheck, events, isFirstLevelChildNodesAllChecked, isFirstLevelChildNodesAllUnChecked, me, originalNode, postData, props, rq, selectType, setNodeNotSemiSelected, setNodeSemiSelected, treeField, url, view, _ref;
    view = this.view;
    if (view.disableSelection) {
      node.set('checked', !node.get('checked'));
      return false;
    }
    props = (_ref = this.cache) != null ? _ref._myProperties : void 0;
    if (props.enableClientSideSelectAll) {
      allnodes = this.getView().node;
      this.selectAllNodes(node, allnodes, newCheckState);
    }
    selectType = props != null ? props.selectType.toLowerCase() : void 0;
    originalNode = node;
    if (selectType === 'single') {
      return;
    }
    if (__indexOf.call('single', selectType) >= 0) {
      return;
    }
    if (this.isNodeDisabled(node)) {
      node.set('checked', !newCheckState);
      this.setNodeDisabled(node);
      return;
    }
    me = this;
    cascadeCheck = function(newnode) {
      var childNodes, _i, _len;
      childNodes = node.childNodes;
      if (childNodes && childNodes.length) {
        for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
          node = childNodes[_i];
          if (!node.raw.disabled) {
            cascadeCheck(node);
          }
        }
      }
      if (newCheckState) {
        if (isFirstLevelChildNodesAllChecked(newnode)) {
          setNodeNotSemiSelected(newnode, newCheckState);
        } else {
          setNodeSemiSelected(newnode);
        }
      } else {
        if (isFirstLevelChildNodesAllUnChecked(newnode)) {
          setNodeNotSemiSelected(newnode, newCheckState);
        }
      }
    };
    bubleUp = function(node, checkSate) {
      var conditionFn, parentNode;
      parentNode = node.parentNode;
      if (parentNode.raw.disabled) {
        return;
      }
      if (checkSate) {
        conditionFn = isFirstLevelChildNodesAllChecked;
      } else {
        conditionFn = isFirstLevelChildNodesAllUnChecked;
      }
      if (conditionFn(parentNode)) {
        setNodeNotSemiSelected(parentNode, checkSate);
      } else {
        setNodeSemiSelected(parentNode);
      }
      if (parentNode.parentNode) {
        bubleUp(parentNode, checkSate);
      }
    };
    isFirstLevelChildNodesAllChecked = function(parentNode) {
      var checked, childNodes, semiSelected, _i, _len;
      childNodes = parentNode.childNodes;
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        node = childNodes[_i];
        checked = node.get('checked');
        semiSelected = node.raw.semiSelected;
        if (!semiSelected && checked) {
          continue;
        } else {
          return false;
        }
      }
      return true;
    };
    isFirstLevelChildNodesAllUnChecked = function(parentNode) {
      var childNodes, _i, _len;
      childNodes = parentNode.childNodes;
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        node = childNodes[_i];
        if (node.get('checked')) {
          return false;
        }
      }
      return true;
    };
    setNodeSemiSelected = function(node) {
      var el;
      node.raw.semiSelected = true;
      node.set('checked', true);
      el = Ext.fly(view.getNode(node));
      if (el && !el.is('.x-checkbox-semi')) {
        el.addCls('x-checkbox-semi');
      }
    };
    setNodeNotSemiSelected = function(node, checked) {
      var el;
      node.raw.semiSelected = false;
      node.set('checked', !!checked);
      el = Ext.fly(view.getNode(node));
      if (el && el.is('.x-checkbox-semi')) {
        el.removeCls('x-checkbox-semi');
      }
    };
    Ext.suspendLayouts();
    cascadeCheck(node);
    bubleUp(node, newCheckState);
    Ext.resumeLayouts();
    originalNode.isEditing = true;
    treeField = this.up();
    events = props.events || {};
    rq = Corefw.util.Request;
    url = rq.objsToUrl3(events['ONCHANGE']);
    if ((treeField != null) && (url != null)) {
      postData = treeField.generatePostData();
      if (props.enableClientSideSelectAll) {
        allTopLevelNodes = postData.allTopLevelNodes;
        if (props.selectallnode) {
          allTopLevelNodes.shift();
        }
      }
      this.sendTreePostData(url, postData);
    }
    originalNode.isEditing = false;
  },
  expandAllNodesOnViewReady: function(view) {
    var fn;
    fn = Ext.Function.createDelayed(function() {
      var expandAllNodes, fc, _ref, _ref1;
      if (!view.el) {
        return;
      }
      fc = view.up('fieldcontainer');
      expandAllNodes = (_ref = fc.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.expandAllNodes : void 0 : void 0;
      if (expandAllNodes) {
        view.expandAll();
      }
    }, 1);
    return fn();
  },
  sendTreePostData: function(url, postData) {
    var props, rq, uipath;
    rq = Corefw.util.Request;
    props = this.cache._myProperties;
    uipath = props.uipath;
    rq.sendRequest5(url, rq.processResponseObject, uipath, postData, null, null, null, null);
  },
  afterRender: function() {
    var elementForm, fieldProps, layoutManager, _ref, _ref1;
    this.callParent(arguments);
    this.setSelection();
    elementForm = this.up('coreelementform');
    fieldProps = (_ref = this.cache) != null ? _ref._myProperties : void 0;
    layoutManager = elementForm != null ? elementForm.layoutManager : void 0;
    if (layoutManager && layoutManager.setMaxAndMixHeight) {
      layoutManager.setMaxAndMixHeight(this.up(), fieldProps);
    }
    if ((_ref1 = this.up()) != null) {
      _ref1.enableSelectEvent = true;
    }
  },
  setSelection: function() {
    var i, me, node, nodeHash, props, selectArray, st, _ref;
    me = this;
    me.suspendEvents();
    selectArray = [];
    st = this.store;
    nodeHash = st != null ? (_ref = st.tree) != null ? _ref.nodeHash : void 0 : void 0;
    if (!nodeHash) {
      return;
    }
    for (i in nodeHash) {
      node = nodeHash[i];
      props = node.raw._myProperties ? node.raw._myProperties : node.raw;
      if (props && props.selected) {
        selectArray.push(node);
      }
    }
    if (selectArray.length) {
      me.getSelectionModel().select(selectArray, false, true);
    }
    me.resumeEvents();
  },
  styleDecorate: function() {
    var cell, cellCssClass, cellCssClassObj, col, cssClass, errMsg, errorMsgs, key, lockedNode, lockedNodeCmp, node, nodeHash, normalNode, normalNodeCmp, oneErrMsg, pathString, props, record, store, view, _ref;
    store = this.getStore();
    nodeHash = store.tree.nodeHash;
    for (key in nodeHash) {
      node = nodeHash[key];
      props = node.raw._myProperties;
      if (key === 'root' || !props) {
        continue;
      }
      errorMsgs = (_ref = props.messages) != null ? _ref.ERROR : void 0;
      cssClass = props.cssClass;
      view = this.getView();
      for (pathString in errorMsgs) {
        errMsg = errorMsgs[pathString];
        oneErrMsg = errMsg.join(';');
        col = this.down('[pathString=' + pathString + ']');
        record = view.getRecord(node);
        if (!record || !col) {
          continue;
        }
        cell = view.getCell(record, col);
        cell.addCls('x-grid-cell-error');
        Ext.create('Ext.tip.ToolTip', {
          target: cell.id,
          html: oneErrMsg + '\n<br>',
          ui: 'form-invalid'
        });
      }
      if (cssClass != null) {
        normalNode = view.getNode(node, true);
        if (!normalNode) {
          return;
        }
        normalNodeCmp = Ext.get(normalNode);
        normalNodeCmp.addCls(cssClass);
        if (view.lockedView) {
          lockedNode = view.lockedView.getNode(node, true);
          lockedNodeCmp = Ext.get(lockedNode);
          lockedNodeCmp.addCls(cssClass);
        }
      }
      cellCssClassObj = node.raw._myProperties.cellCssClass;
      for (pathString in cellCssClassObj) {
        cellCssClass = cellCssClassObj[pathString];
        col = this.down('[pathString=' + pathString + ']');
        record = view.getRecord(node);
        if (!record || !col) {
          continue;
        }
        cell = view.getCell(node, col);
        if (cell) {
          cell.addCls(cellCssClass);
        }
      }
    }
  },
  selectAllNodes: function(node, allnodes, newCheckState) {
    var childNodes, eachnode, nodeselect, _i, _j, _len, _len1;
    childNodes = allnodes.childNodes;
    if (node.data[0] === 'Select All') {
      for (_i = 0, _len = childNodes.length; _i < _len; _i++) {
        eachnode = childNodes[_i];
        if (this.isNodeDisabled(eachnode)) {
          continue;
        }
        eachnode.set('checked', newCheckState);
      }
    } else {
      node.set('checked', newCheckState);
      if (!newCheckState) {
        childNodes[0].set('checked', newCheckState);
      }
      for (_j = 0, _len1 = childNodes.length; _j < _len1; _j++) {
        eachnode = childNodes[_j];
        if (eachnode.data[0] === 'Select All') {
          continue;
        }
        nodeselect = eachnode.data.checked;
        if (!nodeselect) {
          return;
        }
      }
      childNodes[0].set('checked', newCheckState);
    }
  },
  traverseNodes: function(nodes, childrenNodeName, fn) {
    var childrenNodes, node, _i, _len;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      if (typeof fn === "function") {
        fn(node);
      }
      childrenNodes = node[childrenNodeName];
      if (childrenNodes.length > 0) {
        this.traverseNodes(childrenNodes, childrenNodeName, fn);
      }
    }
  }
});
