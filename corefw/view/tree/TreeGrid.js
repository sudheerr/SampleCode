// Generated by CoffeeScript 1.8.0

/*
	implements a tree with multiple columns, similar to a grid
	the tree is in the first column
 */
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Ext.define('Corefw.view.tree.TreeGrid', {
  extend: 'Corefw.view.tree.TreeFieldBase',
  xtype: 'coretreegrid',
  mixins: ['Corefw.mixin.Grid'],
  hideLabel: true,
  afterRender: function() {
    var delayedFn, me;
    this.callParent(arguments);
    this.createPagingToolbar();
    me = this;
    delayedFn = Ext.Function.createDelayed(function() {
      var headercontainer;
      headercontainer = me.down('headercontainer');
      if (headercontainer && headercontainer.updateLayout) {
        headercontainer.updateLayout({
          isRoot: false
        });
      }
    }, 1);
    delayedFn();
  },
  configureTree: function() {
    var addlConfig, colType, colprops, column, columnArray, columns, index, me, newColumnObj, newStoreFieldObj, props, storeFields, treeCache, treeConfig, xtype, _i, _len;
    treeCache = this.cache;
    props = treeCache._myProperties;
    treeConfig = this.treeConfig;
    columns = [];
    storeFields = this.storeFields = [];
    me = this;
    addlConfig = {
      columns: columns,
      name: props.name,
      columnLines: true,
      cls: 'treegrid',
      viewType: 'coretreebaseview',
      lockedGridConfig: {
        viewType: 'coretreebaseview'
      },
      viewConfig: {
        stripeRows: true,
        enableTextSelection: true,
        listeners: {
          refresh: function(dataview) {
            return me.setSelection();
          }
        }
      }
    };
    Ext.apply(treeConfig, addlConfig);
    columnArray = props.columnAr;
    if (columnArray && columnArray.length) {
      for (index = _i = 0, _len = columnArray.length; _i < _len; index = ++_i) {
        column = columnArray[index];
        colprops = column._myProperties;
        if (index === 0) {
          this.firstField = column;
          this.firstColumnName = colprops.dataIndex;
          xtype = 'treecolumn';
        } else {
          if (colprops.type === 'COMBOBOX') {
            xtype = 'corecombocolumn';
          } else {
            xtype = 'gridcolumn';
          }
        }
        newColumnObj = {
          xtype: xtype,
          width: 150,
          text: colprops.title,
          name: colprops.name,
          dataIndex: colprops.index + ''
        };
        columns.push(newColumnObj);
        if (colprops.editable) {
          props.editableColumns = true;
          props.editable = true;
        }
        newStoreFieldObj = {
          name: colprops.index + ''
        };
        colType = colprops.type.toLowerCase();
        if (colType === 'date' || colType === 'datetime') {
          newStoreFieldObj.type = 'date';
        }
        storeFields.push(newStoreFieldObj);
      }
    }
    this.configSelType();
    this.configureTool();
  },
  setSelection: function() {
    var key, len, nodeHash, props, record, selectArray, st;
    selectArray = [];
    st = this.store;
    if (!st) {
      return;
    }
    nodeHash = st.tree.nodeHash;
    len = Object.keys(nodeHash);
    for (key in nodeHash) {
      record = nodeHash[key];
      props = record.raw._myProperties;
      if (props && props.selected) {
        selectArray.push(record);
      }
    }
    if (selectArray.length) {
      this.getSelectionModel().select(selectArray, false, true);
    }
  },
  createPagingToolbar: function() {
    var addlStoreConfig, header, me, pagingToolbarConfig, props, su;
    su = Corefw.util.Startup;
    me = this;
    props = this.cache._myProperties;
    addlStoreConfig = {
      totalCount: props.totalRows,
      pageSize: props.pageSize,
      currentPage: props.currentPage,
      selectablePageSizes: props.selectablePageSizes,
      getTotalCount: function() {
        return props.totalRows;
      },
      loadPage: function(pageNum) {
        me.loadPageForTreeGrid(pageNum);
      },
      nextPage: function() {
        me.loadPageForTreeGrid(this.currentPage + 1);
      },
      previousPage: function() {
        me.loadPageForTreeGrid(this.currentPage - 1);
      }
    };
    Ext.apply(this.tree.store, addlStoreConfig);
    if (!props.pageSize) {
      return;
    }
    pagingToolbarConfig = {
      xtype: 'corepagingtoolbar',
      store: this.tree.store,
      cache: props,
      displayInfo: true,
      margin: '0 20 0 0'
    };
    if (su.getThemeVersion() === 2) {
      pagingToolbarConfig.displayInfo = false;
      pagingToolbarConfig.margin = ' 0 8 0 0';
    }
    header = this.down('header');
    if (!header) {
      return;
    }
    header.insert(header.items.length, pagingToolbarConfig);
  },
  generatePagingPostData: function(pageNum, pageSize, total) {
    var postData, prop;
    prop = this.cache._myProperties;
    pageNum = pageNum || 1;
    pageSize = pageSize || prop.pageSize || 1;
    total = total || prop.totalRows || 1;
    if (pageNum > Math.ceil(total / pageSize)) {
      pageNum = Math.ceil(total / pageSize);
    }
    postData = {
      name: this.cache._myProperties.name,
      total: total,
      currentPage: pageNum,
      pageSize: pageSize
    };
    return postData;
  },
  loadPageForTreeGrid: function(pageNum) {
    var events, eventstr, pageSize, postData, rq, url, _ref, _ref1;
    rq = Corefw.util.Request;
    events = ((_ref = this.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.events : void 0 : void 0) || {};
    eventstr = events.ONRETRIEVE ? 'ONRETRIEVE' : 'ONLOAD';
    url = rq.objsToUrl3(this.eventURLs[eventstr], this.localUrl);
    pageSize = this.tree.store.pageSize;
    postData = this.generatePagingPostData(pageNum, pageSize);
    rq.sendRequest5(url, rq.processResponseObject, this.uipath, postData);
  },
  configureTool: function() {
    var addlConfig, cache, config, dockedItems, evt, fieldLabelTool, fieldProps, functionButtonType, gridToolObj, me, nav, navAr, su, tbar, tools, topBar, treeConfig, _i, _len, _ref;
    me = this;
    treeConfig = me.treeConfig;
    evt = Corefw.util.Event;
    su = Corefw.util.Startup;
    cache = me.cache;
    fieldProps = cache._myProperties;
    functionButtonType = 'tool';
    if (treeConfig != null) {
      treeConfig.functionButtonType = functionButtonType;
    }
    fieldLabelTool = {
      xtype: 'text',
      text: fieldProps.title,
      margin: '0 10 0 0',
      cls: 'custom-header'
    };
    switch (functionButtonType) {
      case 'tool':
        tools = [];
        tools.push(fieldLabelTool);
        break;
      case 'toolbar':
        dockedItems = [];
        tbar = [];
        topBar = {
          xtype: 'toolbar',
          dock: 'top',
          items: tbar
        };
        dockedItems.push(topBar);
        break;
      default:
        break;
    }
    navAr = fieldProps != null ? (_ref = fieldProps.navs) != null ? _ref._ar : void 0 : void 0;
    if (navAr) {
      for (_i = 0, _len = navAr.length; _i < _len; _i++) {
        nav = navAr[_i];
        gridToolObj = {
          uipath: nav.uipath,
          hidden: !nav.visible,
          disabled: !nav.enabled
        };
        switch (functionButtonType) {
          case 'tool':
            addlConfig = {
              xtype: 'button',
              ui: 'toolbutton',
              scale: 'small',
              style: 'margin-right:6px; background-color:white;',
              tooltip: nav.toolTip,
              iconCls: nav.style
            };
            if (su.getThemeVersion() === 2) {
              addlConfig.iconCls = 'icon icon-' + Corefw.util.Cache.cssclassToIcon[nav.style];
              addlConfig.style = 'margin-right:6px';
            }
            Ext.apply(gridToolObj, addlConfig);
            tools.push(gridToolObj);
            break;
          case 'toolbar':
            config = {
              margin: '0 0 0 9'
            };
            if (nav.title) {
              config.text = nav.title;
            } else {
              config.text = ' ';
            }
            if (!!nav.style) {
              config.iconCls = nav.style;
            }
            Ext.apply(gridToolObj, config);
            tbar.push(gridToolObj);
        }
        if (nav.localEvent) {
          gridToolObj.handler = nav.handler;
        } else {
          evt.addEvents(nav, 'nav', gridToolObj);
        }
      }
    }
    if (fieldProps.editable || (tbar != null ? tbar.length : void 0) > 0 || (tools != null ? tools.length : void 0) > 0) {
      switch (functionButtonType) {
        case 'tool':
          treeConfig.tools = tools;
          break;
        case 'toolbar':
          treeConfig.dockedItems = dockedItems;
      }
    }
  },
  createStoreFields: function() {
    return this.storeFields;
  },
  treeStoreAddChildren: function(nodeObj, childrenArray) {
    var cache, child, children, cm, colObj, copyProperties, dataIndex, dataObj, directCopyProps, fieldObj, key, prop, _i, _len;
    cm = Corefw.util.Common;
    cache = this.cache;
    fieldObj = {};
    for (key in cache) {
      colObj = cache[key];
      if (key !== '_myProperties') {
        prop = colObj._myProperties;
        dataIndex = prop.index + '';
        fieldObj[dataIndex] = prop;
      }
    }
    if (childrenArray && childrenArray.length) {
      children = [];
      nodeObj.children = children;
      copyProperties = ['changed', 'removed', 'new', 'selected', 'selectable', 'validValues', 'messages', 'cssClass', 'cellCssClass'];
      directCopyProps = ['expanded'];
      for (_i = 0, _len = childrenArray.length; _i < _len; _i++) {
        child = childrenArray[_i];
        dataObj = cm.objectClone(child.value);
        cm.parseDateData(dataObj, fieldObj);
        dataObj.__index = child.index;
        dataObj._myProperties = {};
        cm.copyObjProperties(dataObj._myProperties, child, copyProperties);
        cm.copyObjProperties(dataObj, child, directCopyProps);
        children.push(dataObj);
        this.treeStoreAddChildren(dataObj, child.children);
      }
    } else {
      nodeObj.leaf = true;
    }
  },
  generatePostData: function() {
    var childNodes, column, columns, dataIndexArray, fetchValue, forcedSelectRec, generatePostDataCreateChildren, modelToRowObj, postData, postDataItems, selected, st, storeFields, storeModel, tree, _i, _len, _ref, _ref1;
    postData = {
      name: this.name
    };
    tree = this.tree;
    columns = tree.columns;
    selected = tree.selModel.selected;
    forcedSelectRec = this.forcedSelectedRecord;
    dataIndexArray = [];
    for (_i = 0, _len = columns.length; _i < _len; _i++) {
      column = columns[_i];
      dataIndexArray.push(column.dataIndex);
    }
    postDataItems = [];
    postData.allTopLevelNodes = postDataItems;
    fetchValue = function(item) {
      if (Ext.isObject(item)) {
        return item.value;
      }
      return item;
    };
    modelToRowObj = function(inputModel) {
      var field, fieldDataIndex, retRowObj, val, vals, values, _j, _len1;
      retRowObj = {};
      values = {};
      retRowObj.value = values;
      if (forcedSelectRec) {
        if (forcedSelectRec === inputModel) {
          retRowObj.selected = true;
        } else {
          retRowObj.selected = false;
        }
      } else {
        if (selected.contains(inputModel)) {
          retRowObj.selected = true;
        } else {
          retRowObj.selected = false;
        }
      }
      for (_j = 0, _len1 = storeFields.length; _j < _len1; _j++) {
        field = storeFields[_j];
        fieldDataIndex = field.name;
        if (__indexOf.call(dataIndexArray, fieldDataIndex) >= 0) {
          val = inputModel.get(fieldDataIndex);
          if (field.type.type === 'date') {
            if (val) {
              val = val.valueOf();
            } else {
              val = '';
            }
          }
          if (val === null || val === void 0) {
            values[fieldDataIndex] = '';
            continue;
          }
          if (Ext.isArray(val)) {
            vals = [];
            Ext.each(val, function(item) {
              vals.push(fetchValue(item));
            });
            values[fieldDataIndex] = vals;
          } else {
            values[fieldDataIndex] = fetchValue(val);
          }
        }
      }
      if (!retRowObj.index) {
        retRowObj.index = inputModel.raw.__index;
      }
      return retRowObj;
    };
    generatePostDataCreateChildren = function(storeDataArray, postDataArray) {
      var children, childrenArray, record, rowObj, _j, _len1;
      for (_j = 0, _len1 = storeDataArray.length; _j < _len1; _j++) {
        record = storeDataArray[_j];
        rowObj = modelToRowObj(record);
        rowObj.editing = record.isEditing ? true : false;
        rowObj["new"] = record.phantom ? true : false;
        rowObj.changed = record.dirty ? true : false;
        rowObj.removed = false;
        rowObj.expanded = record.data.expanded ? true : false;
        postDataArray.push(rowObj);
        children = record.childNodes;
        if (children && children.length) {
          childrenArray = [];
          rowObj.children = childrenArray;
          generatePostDataCreateChildren(children, childrenArray);
        }
      }
    };
    st = tree.getStore();
    storeModel = st.getProxy().getModel();
    storeFields = storeModel.getFields();
    childNodes = (_ref = st.tree) != null ? (_ref1 = _ref.root) != null ? _ref1.childNodes : void 0 : void 0;
    if (childNodes && childNodes.length) {
      generatePostDataCreateChildren(childNodes, postDataItems);
    }
    postData.allContents = this.generateHeadersPostData(tree.cache);
    return postData;
  }
});
