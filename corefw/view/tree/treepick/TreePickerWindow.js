// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.tree.treepick.TreePickerWindow', {
  extend: 'Ext.window.Window',
  xtype: 'coretreepickerwindow',
  height: 210,
  header: false,
  autoShow: true,
  resizable: false,
  draggable: false,
  focusOnToFront: true,
  layout: 'fit',
  ui: 'coretreepickerwindowui',
  expandThreshold: 500,
  afterRender: function() {
    var evt, focusDelay, me, newtree, treeConfig, treeNode, treeNodeCount, treeNodesList, treecolumns, _base, _i, _len, _ref;
    this.callParent(arguments);
    treeConfig = {
      xtype: 'coretreefielddisplayvalue',
      layout: 'fit',
      cache: this.cache
    };
    evt = Corefw.util.Event;
    evt.addEvents(this.respObj, 'field', treeConfig);
    newtree = this.add(treeConfig);
    this.treefield = newtree;
    this.tree = newtree.tree;
    treecolumns = (_ref = newtree.tree) != null ? _ref.columns : void 0;
    console.log('treecolumns: ', treecolumns);
    if (treecolumns && treecolumns.length) {
      treecolumns[0].dataIndex = newtree.displayColumn.index + '';
    }
    treeNodesList = this.tree.store.tree.flatten();
    treeNodeCount = treeNodesList.length;
    console.log('the number of records in the tree is: ', treeNodeCount);
    if ((this.treeLoadMethod === 'init' || !this.parentField.sendValue) || (treeNodeCount < this.expandThreshold && this.treeLoadMethod === 'search')) {
      for (_i = 0, _len = treeNodesList.length; _i < _len; _i++) {
        treeNode = treeNodesList[_i];
        if (!treeNode.data.leaf && (!treeNode.data.children || !treeNode.data.children.length) && treeNode.parentNode && (typeof (_base = treeNode.parentNode).getPath === "function" ? _base.getPath() : void 0)) {
          this.tree.expandPath(treeNode.parentNode.getPath());
        } else {
          this.tree.expandPath(treeNode.getPath());
        }
      }
    }
    document.addEventListener('mousedown', this);
    me = this;
    focusDelay = Ext.Function.createDelayed(function() {
      var deleteFocusDiabledFlag;
      if (me.treeLoadMethod === 'locate') {
        me.hightlightMatchedNodeText(me.parentField.underlyingValue || me.parentField.value, 'locate');
      } else {
        me.hightlightMatchedNodeText(me.parentField.sendValue, 'search');
      }
      me.parentField.disableFocusEvents = true;
      me.parentField.focus();
      me.tree.header.hide();
      deleteFocusDiabledFlag = Ext.Function.createDelayed(function() {
        delete me.parentField.disableFocusEvents;
      }, 300);
      deleteFocusDiabledFlag();
    }, 1);
    focusDelay();
  },
  handleEvent: function(ev) {
    var parentField, target;
    if (this.rendered && this.parentField.rendered) {
      target = ev.target;
      if (this.el.dom.contains(target) || (this.parentField.el && this.parentField.el.dom.contains(target))) {
        return;
      }
      this.hide();
      parentField = this.parentField;
      if (parentField.lastLoadMethod === 'search') {
        parentField.forceLoad = true;
      }
      parentField.disableChangeEvents = true;
      parentField.setValue(parentField.lastDisplayValue);
      parentField.sendValue = parentField.lastSendValue;
      parentField.underlyingValue = parentField.lastSendValue;
      parentField.disableChangeEvents = false;
    }
  },
  isClickInside: function(comp, ev) {
    var height, width, x, y, _ref, _ref1, _ref2;
    _ref = comp.getXY(), x = _ref[0], y = _ref[1];
    width = comp.getWidth();
    height = comp.getHeight();
    if ((x < (_ref1 = ev.x) && _ref1 < x + width) && (y < (_ref2 = ev.y) && _ref2 < y + height)) {
      return true;
    }
    return false;
  },
  generateSeqDisplayText: function(record, displayField, text) {
    var path;
    path = record.getPath(displayField, '>');
    return path.substr(path.indexOf('>', 1) + 1);
  },
  hightlightMatchedNodeText: function(searchStr, treeLoadMethod) {
    var key, nodeHash, nodeObj, treeStore, value, valueField, _ref;
    treeStore = this.tree.store;
    if (!searchStr) {
      return;
    }
    valueField = this.tree.valueField;
    if (treeStore != null ? (_ref = treeStore.tree) != null ? _ref.nodeHash : void 0 : void 0) {
      nodeHash = treeStore.tree.nodeHash;
      for (key in nodeHash) {
        nodeObj = nodeHash[key];
        if (key !== 'root') {
          value = nodeObj.data;
          if (treeLoadMethod === 'locate' && value && value[valueField] === searchStr) {
            this.tree.selectPath(nodeObj.getPath());
            return;
          }
        }
      }
    }
  },
  onDestroy: function() {
    this.callParent(arguments);
    document.removeEventListener('click', this);
  }
});
