// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.view.filter.menu.TimeMark', {
  extend: 'Corefw.view.component.MenuWin',
  alias: 'widget.filterMenuTimeMark',
  requires: ['Corefw.util.Formatter', 'Corefw.view.component.SelectableList'],
  plain: true,
  cls: 'time_mark',
  config: {
    filterPath: '',
    itemName: '',
    repetitiveRatio: -1
  },
  getTimeMarkPath: function() {
    var reg, result, samplePath;
    samplePath = void 0;
    if (this.menuRecord) {
      samplePath = this.menuRecord.getChildren()[0].get('pathString');
    } else if (this.filterPath) {
      samplePath = this.filterPath;
    }
    if (samplePath) {
      reg = /(.+D:TimeMark-I:).*/i;
      result = reg.exec(samplePath);
      if (result) {
        return result[1];
      } else {
        return null;
      }
    }
  },
  style: {
    'z-index': '0'
  },
  getBatchDataType: function() {
    return this.down('[name=batchDataTypeBtngroup]').getBatchDataType();
  },
  showBatchDataType: function(cfg) {
    var batchFreGroup, btnGroup;
    cfg = cfg || {};
    btnGroup = this.down('[name=batchDataTypeBtngroup]');
    batchFreGroup = this.down('[name=batchFrequency]');
    if (cfg.hasMonthly) {
      if (!btnGroup.down('[batchDataType=monthly]')) {
        btnGroup.add({
          boxLabel: 'Monthly',
          name: 'batchDataType',
          batchDataType: 'monthly',
          checked: true
        });
      }
    } else {
      btnGroup.remove(btnGroup.down('[batchDataType=monthly]'));
    }
    if (cfg.hasDaily) {
      if (!btnGroup.down('[batchDataType=daily]')) {
        btnGroup.add({
          boxLabel: 'Daily',
          name: 'batchDataType',
          batchDataType: 'daily',
          checked: true
        });
      }
    } else {
      btnGroup.remove(btnGroup.down('[batchDataType=daily]'));
    }
  },
  items: [
    {
      xtype: 'checkbox',
      height: 22,
      name: 'bestAvailable',
      boxLabel: 'Best Available',
      getDDIName: function() {
        return 'Is BestAvailable';
      },
      getOprandString: function() {
        return true;
      },
      handler: function(me, newVal) {
        var batchFreGroup, btnGroup, hasVariance, menu, num, warnMsg;
        if (newVal) {
          warnMsg = 'Best Available does not support variance column(s):';
          hasVariance = false;
          num = 1;
          Ext.ComponentQuery.query('tableelement gridcolumn').forEach(function(e, i) {
            if (e['compareMeasureString']) {
              warnMsg += '<br/>' + num++ + ': ' + e['text'];
              hasVariance = true;
            }
          });
          if (hasVariance) {
            Corefw.Msg.alert('Alert', warnMsg);
            this.setValue(false);
            return;
          }
        }
        menu = this.up('menu');
        menu.down('[name=batchDataTypeBtngroup]').setDisabled(newVal);
        menu.down('[name=fiscalDateView]').setDisabled(newVal);
        menu.down('[name=operationCombo]').setDisabled(newVal);
        btnGroup = menu.down('[name=batchDataTypeBtngroup]');
        batchFreGroup = menu.down('[name=batchFrequency]');
        if (newVal) {
          btnGroup.hide();
          batchFreGroup.show();
        } else {
          batchFreGroup.hide();
          btnGroup.show();
        }
      },
      setFieldValue: function(val) {
        if (Ext.isArray(val)) {
          val = val[0];
        }
        this.setValue(val);
      }
    }, {
      xtype: 'radiogroup',
      name: 'batchFrequency',
      width: 150,
      items: [
        {
          boxLabel: 'Monthly',
          name: 'batchFrequency',
          frequency: 'Monthly',
          checked: true
        }, {
          boxLabel: 'Daily',
          name: 'batchFrequency',
          frequency: 'Daily',
          checked: false
        }
      ],
      getDDIName: function() {
        return 'Batch Frequency';
      },
      getBatchFrequency: function() {
        var checkedValues, groupMembers, i, len;
        groupMembers = this.query('radio');
        checkedValues = [];
        i = 0;
        len = groupMembers.length;
        while (i < len) {
          if (groupMembers[i].getValue()) {
            return groupMembers[i].frequency;
          }
          i++;
        }
      },
      setFieldValue: function(val) {
        var groupMembers, i, len, toSingleData;
        toSingleData = function(val) {
          if (Ext.isArray(val)) {
            return toSingleData(val[0]);
          }
          return val;
        };
        val = toSingleData(val);
        groupMembers = this.query('radio');
        i = 0;
        len = groupMembers.length;
        while (i < len) {
          if (groupMembers[i].frequency === val) {
            groupMembers[i].setValue(true);
          }
          i++;
        }
      }
    }, {
      xtype: 'checkboxgroup',
      name: 'batchDataTypeBtngroup',
      width: 150,
      getBatchDataType: function() {
        var checkedValues, groupMembers, i, len;
        groupMembers = this.query('checkbox');
        checkedValues = [];
        i = 0;
        len = groupMembers.length;
        while (i < len) {
          if (groupMembers[i].getValue()) {
            checkedValues.push(groupMembers[i].batchDataType);
          }
          i++;
        }
        return checkedValues;
      },
      defaults: {
        handler: function(me, checked) {
          this.up('filterMenuTimeMark').changeBatchDataType();
        }
      },
      items: []
    }, {
      xtype: 'combo',
      name: 'operationCombo',
      queryMode: 'local',
      displayField: 'desc',
      editable: false,
      selectOnFocus: false,
      hideLabel: true,
      valueField: 'operation',
      value: 'in',
      store: Ext.create('Ext.data.Store', {
        fields: ['operation', 'desc'],
        data: [
          {
            'operation': 'in',
            'desc': 'In'
          }, {
            'operation': 'ni',
            'desc': 'Not In'
          }
        ]
      })
    }, {
      xtype: 'selectableList',
      name: 'fiscalDateView',
      getDDIName: function() {
        return 'TimeMark Key';
      },
      labelRender: function(v, me) {
        return CorefwFormatter.formatRelativeDate(v.text);
      }
    }
  ],
  listeners: {
    beforeshow: function(m, eOp) {
      var a, dtFisVw, itemName, menuRecord;
      itemName = m.getItemName();
      dtFisVw = m.down('[name=fiscalDateView]');
      if (itemName) {
        m.setTitle(itemName);
      } else {
        a = m.filterPath.split(':');
        m.setTitle(a[a.length - 1]);
      }
      menuRecord = m.menuRecord;
      dtFisVw.getStore().pathString = m.getTimeMarkPath() + dtFisVw.getDDIName();
      dtFisVw.store.load(function() {
        var batchTypes, hasDaily, hasMonthly;
        hasDaily = dtFisVw.store.findByTypes(["Daily"]) > -1;
        hasMonthly = dtFisVw.store.findByTypes(["Monthly"]) > -1;
        m.showBatchDataType({
          hasMonthly: hasMonthly,
          hasDaily: hasDaily
        });
        batchTypes = m.getBatchDataType();
        dtFisVw.store.filterData(batchTypes);
        dtFisVw.refresh();
        dtFisVw.show();
        if (m.down('[name=bestAvailable]').getValue()) {
          dtFisVw.setDisabled(true);
          m.down('[name=batchDataTypeBtngroup]').hide();
          m.down('[name=batchFrequency]').show();
        } else {
          m.down('[name=batchDataTypeBtngroup]').show();
          m.down('[name=batchFrequency]').hide();
        }
      });
      if (this.menuRecord) {
        this.changeMenuFilterValue(this.menuRecord);
      }
    },
    hide: function() {
      this.clearMenu();
    }
  },
  bbar: [
    {
      xtype: 'button',
      scope: this,
      text: 'Apply',
      width: 55,
      cls: 'primaryBtn',
      handler: function(button, e) {
        var batchFrequency, bestbestAvailable, comb2, criObj, criObj1, criObj2, criteriaStore, dtFisVw, inputValue, menu, newValue, opValueChangMap, pathPreix, triggerOwner;
        menu = button.up('menu');
        pathPreix = menu.getTimeMarkPath();
        criteriaStore = button.up('filterMenuTimeMark').criteriaStore;
        dtFisVw = menu.down('[name=fiscalDateView]');
        comb2 = menu.down('combo');
        triggerOwner = menu.triggerOwner;
        criteriaStore.clearTimeMarkCriteria();
        if (menu.down('[name=bestAvailable]').getValue()) {
          bestbestAvailable = menu.down('[name=bestAvailable]');
          batchFrequency = menu.down('[name=batchFrequency]');
          criObj1 = {
            measure: false,
            dataTypeString: 'boolean',
            disabled: false,
            pathString: pathPreix + bestbestAvailable.getDDIName(),
            operator: 'eq',
            itemName: bestbestAvailable.getDDIName(),
            operandsString: [true]
          };
          criObj2 = {
            measure: false,
            dataTypeString: 'string',
            disabled: false,
            pathString: pathPreix + batchFrequency.getDDIName(),
            operator: 'eq',
            itemName: batchFrequency.getDDIName(),
            operandsString: [batchFrequency.getBatchFrequency()]
          };
          criteriaStore.loadData([criObj1, criObj2], true);
          menu.setVisible(false);
          return;
        }
        inputValue = [];
        Ext.Array.each(dtFisVw.checkboxes, function(r) {
          if (r.getValue()) {
            inputValue.push(r.inputValue);
          }
        });
        criObj = {};
        criObj.measure = false;
        criObj.pathString = pathPreix + dtFisVw.getDDIName();
        criObj.itemName = criteriaStore.getTimeMarkKeyItemName();
        criObj.operandsString = [];
        criObj.dataTypeString = 'date';
        criObj.disabled = false;
        if (!(inputValue && inputValue.length > 0)) {
          Corefw.Msg.alert('Alert', 'Please choose a value.');
          return;
        } else {
          opValueChangMap = {
            'eq': 'in',
            'ne': 'notIn'
          };
          newValue = opValueChangMap[comb2.getValue()];
          if (newValue) {
            comb2.setValue(newValue);
          }
          criObj.operandsString = inputValue;
          criObj.replaceOps = true;
          criObj.operator = comb2.getValue();
          criObj.repetitiveRatio = menu.repetitiveRatio;
          criteriaStore.addItemCriteriaStore(criObj, triggerOwner);
          menu.setVisible(false);
        }
      }
    }, '-', {
      xtype: 'button',
      text: 'Cancel',
      cls: 'secondaryBtn',
      handler: function(button, e) {
        var menu;
        menu = button.up('menu');
        menu.setVisible(false);
      }
    }
  ],
  setFilterMenuComboStore: function(menu, pathString, extraParams) {
    menu.pathString = pathString;
    if (extraParams) {
      Ext.apply(this.down('[name=fiscalDateView]').getStore().getProxy().extraParams, extraParams);
    }
  },
  changeBatchDataType: function() {
    this.down('[name=fiscalDateView]').filterBatchData(this.getBatchDataType());
  },
  clearMenu: function() {
    this.down('combobox').select('in');
    delete this.menuRecord;
  },
  setRecord: function(record) {
    this.menuRecord = record;
  },
  isOprandIn: function(oprand) {
    var allRecs, i, l;
    if (!this.menuRecord) {
      return false;
    }
    allRecs = this.menuRecord.getChildren();
    i = 0;
    l = allRecs.length;
    while (i < l) {
      if (allRecs[i].get('operandsString').indexOf(oprand) > -1) {
        return true;
      }
      i++;
    }
    return false;
  },
  changeMenuFilterValue: function(filterRecord) {
    var allRecds, cmps, filterData, j, menu, opCombo, operandList, operator, record, _i, _l, _len;
    menu = this;
    if (filterRecord && filterRecord.data) {
      filterData = filterRecord.data;
      opCombo = menu.down('combo[name=operationCombo]');
      allRecds = filterRecord.getChildren();
      cmps = [menu.down('[name=bestAvailable]'), menu.down('[name=batchFrequency]')];
      for (_i = 0, _len = allRecds.length; _i < _len; _i++) {
        record = allRecds[_i];
        if (record.get('pathString').indexOf('I:TimeMark Key') > -1) {
          operator = record.get('operator');
          if (operator === 'eq') {
            operator = 'in';
          }
          opCombo.select(operator);
          operandList = record.get('operandsString');
        } else {
          j = 0;
          _l = cmps.length;
          while (j < _l) {
            if (record.get('pathString').indexOf(cmps[j].getDDIName()) > -1) {
              cmps[j].setFieldValue(record.get('operandsString'));
            }
            j++;
          }
        }
      }
    }
  }
});
