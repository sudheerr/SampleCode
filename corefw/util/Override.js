// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.util.Override', {
  singleton: true,
  numberOverride: function() {
    Ext.util.Format.formatFns = {};
    return Ext.util.Format.number = function(v, formatString) {
      var I18NFormatCleanRe, allHashes, code, comma, decimalSeparator, extraChars, formatCleanRe, formatFn, formatPattern, hasComma, nl2brRe, originalFormatString, precision, splitFormat, stripScriptsRe, stripTagsRE, test, trimTrailingZeroes;
      test = parseInt(v) || parseFloat(v);
      if (isNaN(test)) {
        return v;
      }
      stripTagsRE = /<\/?[^>]+>/g;
      stripScriptsRe = /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/g;
      nl2brRe = /\r?\n/g;
      allHashes = /^#+$/;
      formatPattern = /[\d,\.#]+/;
      formatCleanRe = /[^\d\.#]/g;
      if (!formatString) {
        return v;
      }
      formatFn = Ext.util.Format.formatFns[formatString];
      if (!formatFn) {
        originalFormatString = formatString;
        comma = Ext.util.Format.thousandSeparator;
        decimalSeparator = Ext.util.Format.decimalSeparator;
        precision = 0;
        if (formatString.substr(formatString.length - 2) === "/i") {
          I18NFormatCleanRe = new RegExp("[^\\d\\" + Ext.util.Format.decimalSeparator + "]", "g");
          formatString = formatString.substr(0, formatString.length - 2);
          hasComma = formatString.indexOf(comma) !== -1;
          splitFormat = formatString.replace(I18NFormatCleanRe, "").split(decimalSeparator);
        } else {
          hasComma = formatString.indexOf(",") !== -1;
          splitFormat = formatString.replace(formatCleanRe, "").split(".");
        }
        extraChars = formatString.replace(formatPattern, "");
        if (splitFormat.length > 2) {
          Ext.Error.raise({
            sourceClass: "Ext.util.Format",
            sourceMethod: "number",
            value: v,
            formatString: formatString,
            msg: "Invalid number format, should have no more than 1 decimal"
          });
        } else if (splitFormat.length === 2) {
          precision = splitFormat[1].length;
          trimTrailingZeroes = allHashes.test(splitFormat[1]);
        }
        code = ["var utilFormat=Ext.util.Format,extNumber=Ext.Number,neg,absVal,fnum,parts" + (hasComma ? ",thousandSeparator,thousands=[],j,n,i" : "") + (extraChars ? ",formatString=\"" + formatString + "\",formatPattern=/[\\d,\\.#]+/" : "") + (trimTrailingZeroes ? ",trailingZeroes=/\\.?0+$/;" : ";") + "return function(v){" + "if(typeof v!==\"number\"&&isNaN(v=extNumber.from(v,NaN)))return\"\";" + "neg=v<0;", "absVal=Math.abs(v);", "fnum=Ext.Number.toFixed(absVal, " + precision + ");"];
        if (hasComma) {
          if (precision) {
            code[code.length] = "parts=fnum.split(\".\");";
            code[code.length] = "fnum=parts[0];";
          }
          code[code.length] = "if(absVal>=1000) {";
          code[code.length] = "thousandSeparator=utilFormat.thousandSeparator;" + "thousands.length=0;" + "j=fnum.length;" + "n=fnum.length%3||3;" + "for(i=0;i<j;i+=n){" + "if(i!==0){" + "n=3;" + "}" + "thousands[thousands.length]=fnum.substr(i,n);" + "}" + "fnum=thousands.join(thousandSeparator);" + "}";
          if (precision) {
            code[code.length] = "fnum += utilFormat.decimalSeparator+parts[1];";
          }
        } else {
          if (precision) {
            code[code.length] = "if(utilFormat.decimalSeparator!==\".\"){" + "parts=fnum.split(\".\");" + "fnum=parts[0]+utilFormat.decimalSeparator+parts[1];" + "}";
          }
        }
        if (trimTrailingZeroes) {
          code[code.length] = "fnum=fnum.replace(trailingZeroes,\"\");";
        }
        code[code.length] = "if(neg&&fnum!==\"" + (precision ? "0." + Ext.String.repeat("0", precision) : "0") + "\")fnum=\"-\"+fnum;";
        code[code.length] = "return ";
        if (extraChars) {
          code[code.length] = "formatString.replace(formatPattern, fnum);";
        } else {
          code[code.length] = "fnum;";
        }
        code[code.length] = "};";
        formatFn = Ext.util.Format.formatFns[originalFormatString] = Ext.functionFactory("Ext", code.join(""))(Ext);
      }
      return formatFn(v);
    };
  },
  ie11Override: function() {
    var check, docMode, ext;
    ext = Ext;
    check = function(regex) {
      return regex.test(Ext.userAgent);
    };
    docMode = parseInt(document.documentMode);
    ext.isIE = !ext.isOpera && (check(/msie/) || check(/trident/));
    ext.isIE11 = ext.isIE && ((check(/trident\/7\.0/) && docMode !== 7 && docMode !== 8 && docMode !== 9 && docMode !== 10) || docMode === 11);
    ext.isGecko = !ext.isWebKit && !ext.isIE && check(/gecko/);
    ext.isIE11m = ext.isIE6 || ext.isIE7 || ext.isIE8 || ext.isIE9 || ext.isIE10 || ext.isIE11;
    ext.isIE11p = ext.isIE && !(ext.isIE6 || ext.isIE7 || ext.isIE8 || ext.isIE9 || ext.isIE10);
    ext.isIE10p = ext.isIE && !(ext.isIE6 || ext.isIE7 || ext.isIE8 || ext.isIE9);
  },
  customColors: function() {
    var colors, themes;
    colors = ['#4caeed', '#ff944c', '#4ca977', '#e54343', '#a7a5a6', '#f7c54d', '#976ea0', '#ff694c', '#00b0b9', '#4C6C9C', '#53565a', '#99abc7'];
    themes = Ext.chart.theme;
    themes['CVCustom'] = (function(colors) {
      return Ext.extend(themes.Base, {
        constructor: function(config) {
          themes.Base.prototype.constructor.call(this, Ext.apply({
            colors: colors
          }, config));
        }
      });
    })(colors);
  },
  workarounds: function() {
    this.numberOverride();
    this.ie11Override();
    this.customColors();
    if (!window.console) {
      window.console = {
        log: function() {}
      };
    }
    if (Ext.isIE10p) {
      console.log('running in IE10p');
      Ext.supports.Direct2DBug = true;
    }
    if (Ext.isIE8) {
      console.log('running in IE8');
      Ext.override(Ext.dom.Element, {
        setStyle: function(prop, value) {
          var badprop, fixBadValue, key, _prop, _value;
          fixBadValue = function(val) {
            var re, result;
            result = val;
            re = new RegExp(/NaNpx/ig);
            if (val) {
              if (val.search) {
                if (val.search(re) > -1) {
                  result = 'inherit';
                }
              }
            }
            return result;
          };
          _prop = prop;
          _value = fixBadValue(value);
          if (_prop) {
            for (key in _prop) {
              badprop = _prop[key];
              _prop[key] = fixBadValue(badprop);
            }
          }
          return this.callSuper([_prop, _value]);
        }
      });
    }
  },
  workaroundsForNewTheme: function() {
    var su;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      Ext.override(Ext.picker.Date, {
        getDayInitial: function(value) {
          return value.substr(0, 2);
        }
      });
    }
  },
  columnComponentLayoutOverride: function() {
    Ext.override(Ext.grid.ColumnComponentLayout, {
      publishInnerHeight: function(ownerContext, outerHeight) {
        var availableHeight, cmp, inlineFilterOffset, innerHeight, owner, pb, pt, textHeight, that, titleHeight, _ref;
        if (!outerHeight) {
          return;
        }
        that = this;
        owner = that.owner;
        cmp = Ext.getCmp(ownerContext.id);
        inlineFilterOffset = 0;
        if (cmp != null ? (_ref = cmp.filter) != null ? _ref.inlineFilter : void 0 : void 0) {
          inlineFilterOffset = cmp.filter.filterWidget.getHeight();
        }
        innerHeight = outerHeight - ownerContext.getBorderInfo().height - inlineFilterOffset;
        availableHeight = innerHeight;
        if (!owner.noWrap && !ownerContext.hasDomProp('width')) {
          that.done = false;
          return;
        }
        if (ownerContext.hasRawContent) {
          titleHeight = availableHeight;
          textHeight = owner.textEl.getHeight();
          if (textHeight) {
            availableHeight -= textHeight;
            if (availableHeight > 0) {
              pt = Math.floor(availableHeight / 2);
              pb = availableHeight - pt;
              ownerContext.titleContext.setProp('padding-top', pt);
              ownerContext.titleContext.setProp('padding-bottom', pb);
            }
          }
        } else {
          titleHeight = owner.titleEl.getHeight();
          ownerContext.setProp('innerHeight', innerHeight - titleHeight, false);
        }
      },
      calculateOwnerWidthFromContentWidth: function(ownerContext, contentWidth) {
        var owner, triggerOffset;
        owner = this.owner;
        triggerOffset = this.getTriggerOffset(owner, ownerContext);
        if (owner.bugfixfromext5 && owner.isGroupHeader) {
          return contentWidth + ownerContext.getPaddingInfo().width + triggerOffset;
        }
        return this.callParent(arguments);
      }
    });
  },
  columnGetMaxContentWidthOverride: function() {
    return Ext.override(Ext.view.Table, {
      getMaxContentWidth: function(header) {
        var cells, columnSizer, hasPaddingBug, i, ln, max, maxWidth, me, originalMaxWidth, originalWidth, paddingAdjust, _i, _ref;
        me = this;
        cells = me.el.query(header.getCellInnerSelector());
        originalWidth = header.getWidth();
        ln = cells.length;
        hasPaddingBug = Ext.supports.ScrollWidthInlinePaddingBug;
        columnSizer = me.body.select(me.getColumnSizerSelector(header));
        max = Math.max;
        if (hasPaddingBug && ln > 0) {
          paddingAdjust = me.getCellPaddingAfter(cells[0]);
        }
        columnSizer.setWidth(1);
        maxWidth = originalMaxWidth = header.textEl.dom.offsetWidth + header.titleEl.getPadding('lr');
        for (i = _i = 0, _ref = ln - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          maxWidth = max(maxWidth, cells[i].scrollWidth);
        }
        if (hasPaddingBug) {
          maxWidth += paddingAdjust;
        }
        maxWidth = max(maxWidth, 40);
        if (originalMaxWidth !== maxWidth) {
          maxWidth++;
        }
        columnSizer.setWidth(originalWidth);
        return maxWidth;
      }
    });
  },
  xhrStatusOverride: function() {
    Ext.data.Connection.addStatics({
      xhrStatusCache: {},
      findXhrStatus: function(statusList, urlParams, exact) {
        var match, statusItem, _i, _len;
        if (exact == null) {
          exact = false;
        }
        if (!urlParams || (!exact && Ext.Object.getSize(urlParams) === 0)) {
          return statusList;
        }
        match = [];
        for (_i = 0, _len = statusList.length; _i < _len; _i++) {
          statusItem = statusList[_i];
          if (exact) {
            if ((statusItem != null ? statusItem.params : void 0) && Ext.encode(statusItem.params) === Ext.encode(urlParams)) {
              match.push(statusItem);
              break;
            }
          } else {
            if ((statusItem != null ? statusItem.params : void 0) && Ext.encode(statusItem.params).indexOf(Ext.encode(urlParams).slice(1, -1)) > -1) {
              match.push(statusItem);
            }
          }
        }
        return match;
      },
      setXhrStatus: function(options, status, exact) {
        var data, eventURL, match, matches, method, urlParams, urlParts, _base, _base1, _i, _len, _ref, _results;
        if (options != null ? options.url : void 0) {
          urlParts = Corefw.util.Request.getShortUrl(options.url).split("&");
          eventURL = urlParts[0];
          urlParams = {};
          urlParts.slice(1).forEach(function(v) {
            var pk, pv, _ref;
            _ref = v.split("="), pk = _ref[0], pv = _ref[1];
            return urlParams[pk] = decodeURI(pv);
          });
          method = (_ref = options.method) != null ? _ref : "POST";
          data = {
            status: status,
            params: urlParams
          };
          if ((_base = Ext.data.Connection.xhrStatusCache)[method] == null) {
            _base[method] = {};
          }
          if ((_base1 = Ext.data.Connection.xhrStatusCache[method])[eventURL] == null) {
            _base1[eventURL] = [];
          }
          matches = Ext.data.Connection.findXhrStatus(Ext.data.Connection.xhrStatusCache[method][eventURL], urlParams, exact);
          if (matches.length > 0) {
            _results = [];
            for (_i = 0, _len = matches.length; _i < _len; _i++) {
              match = matches[_i];
              _results.push(match.status = status);
            }
            return _results;
          } else {
            return Ext.data.Connection.xhrStatusCache[method][eventURL].push(data);
          }
        }
      },
      getXhrStatus: function(eventURL, method, urlParams) {
        var matches, statusList, _ref, _ref1, _ref2, _ref3, _ref4;
        if (method == null) {
          method = "POST";
        }
        statusList = (_ref = (_ref1 = Ext.data.Connection.xhrStatusCache) != null ? (_ref2 = _ref1[method]) != null ? _ref2[eventURL] : void 0 : void 0) != null ? _ref : [];
        matches = Ext.data.Connection.findXhrStatus(statusList, urlParams);
        return (_ref3 = matches != null ? (_ref4 = matches[0]) != null ? _ref4.status : void 0 : void 0) != null ? _ref3 : "na";
      },
      xhrInitiate: function(options, exact) {
        if (exact == null) {
          exact = false;
        }
        return Ext.data.Connection.setXhrStatus(options, "initial", exact);
      },
      xhrComplete: function(options, exact) {
        if (exact == null) {
          exact = false;
        }
        return Ext.data.Connection.setXhrStatus(options, "complete", exact);
      },
      isXhrCompleted: function(eventURL, method, urlParams) {
        return "complete" === Ext.data.Connection.getXhrStatus(eventURL, method, urlParams);
      }
    });
    Ext.override(Ext.data.Connection, {
      request: function(options) {
        var e, me;
        me = this;
        try {
          Ext.data.Connection.xhrInitiate(options, true);
        } catch (_error) {
          e = _error;
          console.error("Error on setting xhr status(request): ", e);
        }
        return me.callParent(arguments);
      }
    });
    return Ext.override(Ext.data.Connection, {
      onComplete: function(request) {
        var e, me, ret;
        me = this;
        ret = me.callParent(arguments);
        try {
          Ext.data.Connection.xhrComplete(request != null ? request.options : void 0, true);
        } catch (_error) {
          e = _error;
          console.error("Error on setting xhr status(onComplete): ", e);
        }
        return ret;
      }
    });
  },
  measureLabelErrorHeightOverride: function() {
    return Ext.override(Ext.layout.component.field.Field, {
      measureLabelErrorHeight: function(ownerContext) {
        var su;
        su = Corefw.util.Startup;
        if (su.getThemeVersion() === 2 && ownerContext.target.msgTarget === 'under') {
          return ownerContext.labelStrategy.getHeight(ownerContext);
        } else {
          return ownerContext.labelStrategy.getHeight(ownerContext) + ownerContext.errorStrategy.getHeight(ownerContext);
        }
      }
    });
  },
  pieChartEnhancementOverride: function() {
    Ext.override(Ext.ux.chart.SmartLegend, {
      getBBox: function() {
        var p;
        p = this.callParent(arguments);
        if (p.width < 0) {
          p.width = 0;
        }
        if (p.height < 0) {
          p.height = 0;
        }
        return p;
      },
      calcPosition: function() {
        var me, p;
        me = this;
        p = me.callParent(arguments);
        switch (me.position) {
          case 'bottom':
            p.y += me.getChartInsets().bottom;
        }
        return p;
      }
    });
    Ext.override(Ext.chart.Chart, {
      calculateInsets: function() {
        var axes, axis, bbox, edge, edges, getAxis, insets, isVertical, legend, me, _i, _len;
        me = this;
        legend = me.legend;
        axes = me.axes;
        edges = ['top', 'right', 'bottom', 'left'];
        getAxis = function(edge) {
          var i;
          i = axes.findIndex('position', edge);
          if (i < 0) {
            return null;
          } else {
            return axes.getAt(i);
          }
        };
        insets = me.getInsets();
        for (_i = 0, _len = edges.length; _i < _len; _i++) {
          edge = edges[_i];
          isVertical = edge === 'left' || edge === 'right';
          axis = getAxis(edge);
          if (legend !== false) {
            if (legend.position === edge) {
              bbox = legend.getBBox();
              insets[edge] += isVertical ? bbox.width : bbox.height;
            }
          }
          if (axis && axis.bbox) {
            bbox = axis.bbox;
            insets[edge] += isVertical ? bbox.width : bbox.height;
          }
        }
        return insets;
      }
    });
    Ext.override(Ext.draw.Draw, {
      normalizeDegrees: function(degrees) {
        if (degrees >= 0) {
          return degrees % 360;
        }
        return ((degrees % 360) + 360) % 360;
      }
    });
    return Ext.override(Ext.chart.series.Pie, {
      setSpriteAttributes: function(sprite, attrs, animate) {
        var me;
        me = this;
        if (animate) {
          sprite.stopAnimation();
          return sprite.animate({
            to: attrs,
            duration: me.highlightDuration
          });
        } else {
          return sprite.setAttributes(attrs, true);
        }
      },
      highlightItem: function(item) {
        var animate, attrs, display, group, highlightSegment, itemHighlightSegment, label, line, me, middle, prop, r, rad, shadow, to, x, y, _i, _j, _len, _len1, _ref, _results;
        me = this;
        rad = me.rad;
        item = item || this.items[this._index];
        this.unHighlightItem();
        if (!item || me.animating || (item.sprite && item.sprite._animating)) {
          return;
        }
        me.callSuper([item]);
        if (!me.highlight) {
          return;
        }
        if ('segment' in item.series.highlight) {
          highlightSegment = item.series.highlight.segment;
          animate = me.chart.animate;
          if (me.labelsGroup) {
            group = me.labelsGroup;
            display = me.label.display;
            label = group.getAt(item.index);
            middle = (item.startAngle + item.endAngle) / 2 * rad;
            r = highlightSegment.margin || 0;
            x = r * Math.cos(middle);
            y = r * Math.sin(middle);
            if (Math.abs(x) < 1e-10) {
              x = 0;
            }
            if (Math.abs(y) < 1e-10) {
              y = 0;
            }
            me.setSpriteAttributes(label, {
              translate: {
                x: x,
                y: y
              }
            }, animate);
            line = label.lineSprite;
            if (line) {
              me.setSpriteAttributes(line, {
                translate: {
                  x: x,
                  y: y
                }
              }, animate);
            }
          }
          if (me.chart.shadow && item.shadows) {
            _ref = item.shadows;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              shadow = _ref[_i];
              to = {};
              itemHighlightSegment = item.sprite._from.segment;
              for (_j = 0, _len1 = itemHighlightSegment.length; _j < _len1; _j++) {
                prop = itemHighlightSegment[_j];
                if (!(prop in highlightSegment)) {
                  to[prop] = itemHighlightSegment[prop];
                }
              }
              attrs = {
                segment: Ext.applyIf(to, me.highlightCfg.segment)
              };
              _results.push(me.setSpriteAttributes(shadow, attrs, animate));
            }
            return _results;
          }
        }
      },
      onPlaceLabel: function(label, storeItem, item, i, display, animate, index) {
        var animateLine, attrs, calloutLine, centerX, centerY, chart, config, cos, dg, field, format, from, fromPoint, height, isOutside, labelBox, labelCenter, labelHeight, labelPadding, labelPaddingX, labelPaddingY, labelWidth, line, lineWidth, me, middle, normalTheta, opt, prevDg, resizing, rho, sign, sin, theta, toPoint, width, x, y, _ref;
        me = this;
        chart = me.chart;
        resizing = chart.resizing;
        config = me.label;
        format = config.renderer;
        field = config.field;
        centerX = me.centerX;
        centerY = me.centerY;
        middle = item.middle;
        opt = {
          x: middle.x,
          y: middle.y
        };
        x = middle.x - centerX;
        y = middle.y - centerY;
        from = {};
        rho = 1;
        theta = Math.atan2(y, x || 1);
        dg = Ext.draw.Draw.degrees(theta);
        isOutside = display === 'outside';
        calloutLine = label.attr.calloutLine;
        lineWidth = (calloutLine && calloutLine.width) || 2;
        labelPadding = (_ref = label.attr.padding) != null ? _ref : 20;
        labelPadding += isOutside ? lineWidth / 2 : 0;
        labelPaddingX = 0;
        labelPaddingY = 0;
        opt.hidden = false;
        if (this.__excludes && this.__excludes[i]) {
          opt.hidden = true;
        }
        label.setAttributes({
          opacity: opt.hidden ? 0 : 1,
          text: format(storeItem.get(field), label, storeItem, item, i, display, animate, index)
        }, true);
        if (label.lineSprite) {
          attrs = {
            opacity: opt.hidden ? 0 : 1
          };
          if (opt.hidden) {
            attrs.translate = {
              x: 0,
              y: 0
            };
          }
          me.setSpriteAttributes(label.lineSprite, attrs, false);
        }
        switch (display) {
          case 'outside':
            label.isOutside = true;
            rho = item.endRho;
            labelPaddingX = Math.abs(dg) <= 90 ? labelPadding : -labelPadding;
            labelPaddingY = dg >= 0 ? labelPadding : -labelPadding;
            label.setAttributes({
              rotation: {
                degrees: 0
              }
            }, true);
            labelBox = label.getBBox();
            width = labelBox.width / 2 * Math.cos(theta);
            height = labelBox.height / 2 * Math.sin(theta);
            width += labelPaddingX;
            height += labelPaddingY;
            rho += Math.sqrt(width * width + height * height);
            opt.x = rho * Math.cos(theta) + centerX;
            opt.y = rho * Math.sin(theta) + centerY;
            break;
          case 'rotate':
            dg = Ext.draw.Draw.normalizeDegrees(dg);
            dg = dg > 90 && dg < 270 ? dg + 180 : dg;
            prevDg = label.attr.rotation.degrees;
            if (prevDg !== null && Math.abs(prevDg - dg) > 180 * 0.5) {
              if (dg > prevDg) {
                dg -= 360;
              } else {
                dg += 360;
              }
              dg = dg % 360;
            } else {
              dg = Ext.draw.Draw.normalizeDegrees(dg);
            }
            opt.rotate = {
              degrees: dg,
              x: opt.x,
              y: opt.y
            };
        }
        opt.translate = {
          x: 0,
          y: 0
        };
        if (animate && !resizing && (display !== 'rotate' || prevDg !== null)) {
          me.onAnimate(label, {
            to: opt
          });
        } else {
          label.setAttributes(opt, true);
        }
        label._from = from;
        if (label.isOutside && calloutLine) {
          line = label.lineSprite;
          animateLine = animate;
          fromPoint = {
            x: (item.endRho - lineWidth / 2) * Math.cos(theta) + centerX,
            y: (item.endRho - lineWidth / 2) * Math.sin(theta) + centerY
          };
          labelCenter = {
            x: opt.x,
            y: opt.y
          };
          toPoint = {};
          sign = function(x) {
            if (x) {
              if (x < 0) {
                return -1;
              } else {
                return 1;
              }
            }
            return 0;
          };
          if (calloutLine && calloutLine.length) {
            toPoint = {
              x: (item.endRho + calloutLine.length) * Math.cos(theta) + centerX,
              y: (item.endRho + calloutLine.length) * Math.sin(theta) + centerY
            };
          } else {
            normalTheta = Ext.draw.Draw.normalizeRadians(-theta);
            cos = Math.cos(normalTheta);
            sin = Math.sin(normalTheta);
            labelWidth = (labelBox.width + lineWidth + 4) / 2;
            labelHeight = (labelBox.height + lineWidth + 4) / 2;
            if (Math.abs(cos) * labelHeight > Math.abs(sin) * labelWidth) {
              toPoint.x = labelCenter.x - labelWidth * sign(cos);
              toPoint.y = labelCenter.y + labelWidth * sin / cos * sign(cos);
            } else {
              toPoint.x = labelCenter.x - labelHeight * cos / sin * sign(sin);
              toPoint.y = labelCenter.y + labelHeight * sign(sin);
            }
          }
          if (!line) {
            line = label.lineSprite = me.createLabelLine(i);
            animateLine = false;
          }
          return me.drawLabelLine(label, fromPoint, toPoint, animateLine);
        } else {
          return delete label.lineSprite;
        }
      }
    });
  },
  rowModelOverride: function() {
    return;
    return Ext.override(Ext.selection.RowModel, {
      isRowSelected: function(record, index) {
        var err, totalCount;
        try {
          if (Ext.isNumber(record)) {
            totalCount = this.store.totalCount;
            if (record >= totalCount) {
              return false;
            }
          }
          return this.isSelected(record);
        } catch (_error) {
          err = _error;
          return false;
        }
      }
    });
  },
  gridHeaderReordererPluginOverride: function() {
    var overrideBeforeDragOver;
    overrideBeforeDragOver = function(target, e) {
      var dragData, grid, sourceGroupHeader, sourceHeader, targetGroupHeader, targetHeader, _ref;
      dragData = this.dragData;
      grid = target.headerCt.grid;
      sourceHeader = dragData.header;
      targetHeader = Ext.getCmp((_ref = target.getTargetFromEvent(e)) != null ? _ref.id : void 0);
      if (!targetHeader) {
        return false;
      }
      if ('pivottable' === grid.xtype && 'pivotaxiscolumn' === sourceHeader.xtype && 'pivotaxiscolumn' !== targetHeader.xtype) {
        return false;
      }
      sourceGroupHeader = typeof sourceHeader.up === "function" ? sourceHeader.up() : void 0;
      targetGroupHeader = typeof targetHeader.up === "function" ? targetHeader.up() : void 0;
      if (grid.isEditing) {
        return false;
      }
      if (sourceGroupHeader != null ? sourceGroupHeader.isGroupHeader : void 0) {
        if (targetGroupHeader === sourceGroupHeader) {
          return true;
        }
      } else {
        if (!(targetGroupHeader && targetGroupHeader.isGroupHeader)) {
          return true;
        }
      }
      return false;
    };
    return Ext.override(Ext.grid.plugin.HeaderReorderer, {
      onHeaderCtRender: function() {
        var me;
        me = this;
        me.dragZone = new Ext.grid.header.DragZone(me.headerCt);
        me.dropZone = new Ext.grid.header.DropZone(me.headerCt);
        if (me.disabled) {
          me.dragZone.disable();
        }
        return me.dragZone.beforeDragOver = overrideBeforeDragOver;
      }
    });
  }
});
