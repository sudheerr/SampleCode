// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.util.Observer', {
  singleton: true,
  constructor: function() {
    return this.store.parent = this;
  },

  /*
     	@property {Object} stores the observed targets, observers, the relationship between target and observers
   */
  store: {
    mappings: {},
    targets: {},
    observers: {},
    addMapping: function(targetKey, state, observerKey, eventTypes) {
      var events, observer, target, _base;
      target = (_base = this.mappings)[targetKey] || (_base[targetKey] = {});
      state = target[state] || (target[state] = {});
      observer = state[observerKey] || (state[observerKey] = {});
      events = observer.events || (observer.events = []);
      observer.events = events.concat(eventTypes);
      return targetKey;
    },
    getMapping: function(targetKey) {
      return this.mappings[targetKey];
    },
    getMappings: function(targetKeys) {
      var me, res;
      if (targetKeys == null) {
        targetKeys = [];
      }
      res = [];
      me = this;
      targetKeys.forEach(function(t) {
        var mapping;
        mapping = me.getMapping(t);
        return mapping && res.push(mapping);
      });
      return res;
    },

    /*
      		register the observer
      		@param {String} targetKey The key of target, The default is uipath
      		@param {String} observerKey The key of observer, The default is uipath
      		@param {String} observedSate The state of target which observers observe to
      		@param {Array[String]} eventTypes The event of observer should be granted after target'state changed
     */
    registerObserver: function(targetKey, observerKey, observedSate, eventTypes) {
      var observer;
      if (eventTypes == null) {
        eventTypes = [];
      }
      observer = this.observers[observerKey];
      if (!observer) {
        observer = this.observers[observerKey] = {
          eventGrantedTable: {},
          targets: {}
        };
      }
      observer.targets[targetKey] = true;
      eventTypes.forEach(function(ev) {
        return !observer.eventGrantedTable[ev] && (observer.eventGrantedTable[ev] = true);
      });
      this.addMapping(targetKey, observedSate, observerKey, eventTypes);
      return true;
    },
    getObserver: function(observerKey) {
      return this.observers[observerKey];
    },
    addTarget: function(targetKey) {
      var target;
      if (target = this.targets[targetKey]) {
        this.parent.grantEvents(target.state, targetKey);
        return false;
      }
      this.targets[targetKey] = {
        state: this.parent.States.INIT,
        key: targetKey
      };
      return true;
    },

    /*
      		search all related targets for key
      		@param {String} targetKey The default value is 'all' which means will return all targets, Specially, This method
      		will find all targets matched by key's hierarchy.
      		for example:
      		The key is 'A/B/C/D', will return the targets matched keys:
      		'A/B/C/D','A/B/C','A/B','A'
     */
    getTargets: function(targetKey) {
      var keys, tar, target, targets, ts, _;
      if (targetKey == null) {
        targetKey = 'all';
      }
      ts = [];
      targets = this.targets;
      if (targetKey === 'all') {
        for (_ in targets) {
          tar = targets[_];
          ts.push(tar);
        }
        return ts;
      }
      while (targetKey) {
        target = targets[targetKey];
        if (target) {
          ts.push(target);
        }
        keys = targetKey.split('/');
        keys.pop();
        if (keys.length === 0) {
          break;
        }
        targetKey = keys.join('/');
      }
      return ts;
    },
    getTarget: function(targetKey) {
      return this.targets[targetKey];
    },
    getTargetsByObserver: function(observerKey) {
      return this.mappings[observerKey] || [];
    },
    clear: function() {
      this.mappings = {};
      this.targets = {};
      return this.observers = {};
    }
  },

  /*
     	enum for defining target's states
   */
  States: {
    INIT: 'initialized',
    DIRTY: 'dirty',
    SYNCED: 'synced'
  },
  keyProperty: 'uipath',

  /*
     	to add a component to be observed target and set its state as the 'INIT' if it is not exists in targets in store, then mark it is observed
   */
  addTarget: function(target) {
    return this.store.addTarget(target);
  },

  /*
  		to register a component to be the observer, any observed target information all comes from it event
  		@param {String} observerKey The key of observer, the default is uipath
     	@events {Array[Object]} events The event object list
   */
  registerObserver: function(observerKey, events) {
    var me, parentKey, store, uip;
    if (events == null) {
      events = [];
    }
    uip = Corefw.util.Uipath;
    store = this.store;
    parentKey = uip.uipathToParentUipath(observerKey);
    me = this;
    events.forEach(function(event) {
      var observeTargetKeys;
      if (event.dirtyCheck) {
        store.registerObserver(parentKey, observerKey, me.States.DIRTY, [event.type]);
      }
      if (observeTargetKeys = event.observeKeys) {
        observeTargetKeys = Ext.Array.from(observeTargetKeys);
        return observeTargetKeys.forEach(function(targetKey) {
          return store.registerObserver(targetKey, observerKey, me.States.SYNCED, [event.type]);
        });
      }
    });
    return true;
  },
  updateStateFromResponse: function(response, state) {
    var allContents, content, keyProperty, me, _i, _len;
    if (!response) {
      return;
    }
    me = this;
    if (Ext.isArray(response)) {
      response.forEach(function(res) {
        return me.updateStateFromResponse(res, state);
      });
      return;
    }
    keyProperty = this.keyProperty;
    this.updateState(state, response[keyProperty]);
    allContents = response.allContents || [];
    for (_i = 0, _len = allContents.length; _i < _len; _i++) {
      content = allContents[_i];
      this.updateStateFromResponse(content, state);
    }
  },

  /*
     	update the target'state and grant its observers's event
  		@param {String} key target key
   */
  updateState: function(state, key) {
    var store, target;
    if (!((key && state) || this.isSuspended)) {
      return false;
    }
    store = this.store;
    target = store.getTarget(key);
    if (!target) {
      return false;
    }
    target.state = state;
    this.grantEvents(state, key);
    return true;
  },

  /*
     	grant the events of observers which observing target by target's state
  		@param {String} key target key
   */
  grantEvents: function(state, key) {
    var mappings, stateMappings, store, target;
    store = this.store;
    target = store.getTarget(key);
    if (!target) {
      return;
    }
    mappings = store.getMappings([target.key]);
    stateMappings = mappings.map(function(m) {
      return m[state];
    });
    stateMappings.forEach(function(m) {
      var events, ob, observer, observerKey;
      for (observerKey in m) {
        ob = m[observerKey];
        observer = store.getObserver(observerKey);
        events = ob.events;
        events.forEach(function(ev) {
          return observer.eventGrantedTable[ev] = true;
        });
      }
    });
  },
  isEventGranted: function(observerKey, eventType) {
    var observer;
    observer = this.store.getObserver(observerKey);
    if (!observer) {
      return true;
    }
    return observer.eventGrantedTable[eventType];
  },

  /*
     	disable all events of observer
   */
  disableAllEvents: function(key) {
    var event, eventGrantedTable, observer;
    if (observer = this.store.getObserver(key)) {
      eventGrantedTable = observer.eventGrantedTable;
      for (event in observer.eventGrantedTable) {
        eventGrantedTable[event] = false;
      }
    }
  },
  suspend: function() {
    return this.isSuspended = true;
  },
  resume: function() {
    return this.isSuspended = false;
  }
});
