// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.util.RowEditorHelper', {
  singleton: true,
  beforeEdit: function(context, editor) {
    this.retrieveEditingRowData(context, editor);
    context.backupData = Ext.clone(context.record.data);
    this.sendData(context, 'before', false);
    this.disableOrEnableCells(editor);
  },
  retrieveEditingRowData: function(context, editor) {
    var cm, currentEditingRowData, grid, gridData, parent, record, rowIndex, store, _ref;
    if (!context) {
      return;
    }
    cm = Corefw.util.Common;
    grid = context.grid;
    record = context.record;
    if (!grid || !record) {
      return;
    }
    store = record.store;
    parent = grid.up('fieldcontainer');
    cm = Corefw.util.Common;
    rowIndex = cm.findRecordIndex(store, record);
    if (rowIndex < 0) {
      return;
    }
    if (parent.xtype === "coretreegrid") {
      gridData = cm.converTreeGridDataToDataList(parent.cache._myProperties.allTopLevelNodes);
      if ((gridData != null ? gridData.length : void 0) === 0) {
        gridData = cm.converTreeGridDataToDataList(grid.cache._myProperties.allTopLevelNodes);
      }
    } else {
      gridData = parent.cache._myProperties.items;
      if ((gridData != null ? gridData.length : void 0) === 0) {
        gridData = (_ref = grid.cache) != null ? _ref._myProperties.items : void 0;
      }
    }
    gridData || (gridData = []);
    currentEditingRowData = gridData[rowIndex];
    if (currentEditingRowData) {
      editor.currentEditingRowData = currentEditingRowData;
    }
  },
  processDataBeforeEdit: function(context) {
    var iv, me;
    me = this;
    iv = Corefw.util.InternalVar;
    return function(res, ev, uipath) {
      var cm, editable, editingRow, grid, gridData, isNotEditable, newRowData, parent, props, record, responseGridData, rowIndex, store, _ref;
      grid = context.grid;
      if (grid) {
        if (0 > ((_ref = res.widgetType) != null ? _ref.toLowerCase().indexOf("grid") : void 0) || Ext.isArray(res)) {
          Corefw.util.Request.processResponseObject(res, ev, uipath);
          if (!grid.el) {
            grid.isEditing = false;
          }
          return;
        }
        cm = Corefw.util.Common;
        parent = grid.up("fieldcontainer");
        if (parent.xtype === "coretreegrid") {
          gridData = cm.converTreeGridDataToDataList(parent.cache._myProperties.allTopLevelNodes);
          responseGridData = cm.converTreeGridDataToDataList(res.allTopLevelNodes);
        } else {
          responseGridData = res.items;
          gridData = parent.cache._myProperties.items;
        }
        record = context.record;
        store = grid.getStore();
        rowIndex = cm.findRecordIndex(store, record);
        editingRow = gridData[rowIndex];
        newRowData = responseGridData[rowIndex];
        editable = newRowData.hasOwnProperty('editable') ? newRowData.editable : true;
        isNotEditable = newRowData.readOnly || !editable;
        iv.setByNameProperty('roweditor', 'cancelEdit', isNotEditable);
        if (editingRow) {
          editingRow.disabledHeaders = newRowData.disabledHeaders;
          editingRow.enabledHeaders = newRowData.enabledHeaders;
          editingRow.validations = newRowData.validations;
          editingRow.messages = newRowData.messages;
        }
        if (res.uipath = uipath) {
          props = Corefw.util.Uipath.uipathToComponent(uipath).cache._myProperties;
          props.allContents = res.allContents;
        }
        me.converDateField(res.allContents, newRowData.value);
        me.bindDataForComboboxes(context, newRowData);
        record.raw._myProperties.messages = newRowData.messages;
        record.raw._myProperties.tooltipValue = newRowData.tooltipValue;
        record.raw._myProperties.cssClassList = newRowData.cssClassList;
        record.raw._myProperties.cellCssClass = newRowData.cellCssClass;
        me.updateRecord(record, newRowData.value);
        if (grid.updateItemDecorate != null) {
          grid.updateItemDecorate(record);
        }
        grid.setLoading(false);
      }
    };
  },
  converDateField: function(columnDefs, itemValue) {
    var col, dataIndex, dataValue, date, dateCols, _i, _j, _len, _len1;
    dateCols = columnDefs.filter(function(v) {
      return v.type === 'DATE' || v.type === 'MONTH_PICKER';
    });
    for (_i = 0, _len = dateCols.length; _i < _len; _i++) {
      col = dateCols[_i];
      dataIndex = col.index + '';
      dataValue = itemValue[dataIndex];
      if (typeof dataValue === 'number') {
        itemValue[dataIndex] = new Date(dataValue);
      }
    }
    date = 'DATESTRING';
    dateCols = columnDefs.filter(function(v) {
      return v.type === date;
    });
    for (_j = 0, _len1 = dateCols.length; _j < _len1; _j++) {
      col = dateCols[_j];
      dataIndex = col.index + '';
      dataValue = itemValue[dataIndex];
      if (typeof dataValue === 'string') {
        itemValue[dataIndex] = Ext.Date.parse(dataValue, 'Y-m-d H:i:s');
      }
    }
  },
  startEdit: function(editor, columnHeader) {
    var context, form, me, record;
    context = editor.context;
    record = context.record;
    form = editor.form;
    this.correctValueToGridPickers(editor, record);
    this.refocusOnCorrectField(form, columnHeader);
    this.addMoreActionsToRowEditor(editor);
    me = this;
    form.updateRecord = function() {
      me.updateRecord(editor.context.record, me.getFormValues(editor.getForm()));
      return form;
    };
    form.reset = function() {};
    editor.hideToolTip();
    editor.updateButton(editor.isValid());
  },
  cancelEdit: function(context) {
    var _ref;
    context.record.isEditing = false;
    if ((_ref = context.grid) != null ? _ref.skipCancelEditing : void 0) {
      return;
    }
    this.sendData(context, 'cancel');
  },
  addMoreActionsToRowEditor: function(editor) {
    var context, currentEditingRowData, errors, newFieldValidationMap, record, _ref;
    context = editor.context;
    if (!context) {
      return;
    }
    record = context.record;
    if (!context || !record) {
      return;
    }
    currentEditingRowData = editor.currentEditingRowData;
    if (!currentEditingRowData) {
      return;
    }
    if (!context.view.body) {
      context.view.body = context.view;
    }
    this.bindEditorUIMessages(editor);
    newFieldValidationMap = currentEditingRowData.validations || {};
    errors = ((_ref = currentEditingRowData.messages) != null ? _ref.ERROR : void 0) || {};
    this.bindValidatorToFields(editor, newFieldValidationMap, errors);
  },
  bindEditorUIMessages: function(editor) {
    var currentEditingRowData, editorWarnings, itemWarnings, path, textEditor, textEditors, _i, _len, _ref;
    currentEditingRowData = editor.currentEditingRowData;
    itemWarnings = (_ref = currentEditingRowData.messages) != null ? _ref.WARNING : void 0;
    textEditors = editor.query("textfield[hidden=false]");
    for (_i = 0, _len = textEditors.length; _i < _len; _i++) {
      textEditor = textEditors[_i];
      textEditor.clearMessages();
      path = textEditor.pathString;
      if (!path || (editorWarnings = (itemWarnings && itemWarnings[path]) || []).length < 1) {
        continue;
      }
      editorWarnings = editorWarnings.join('<br>');
      textEditor.setActiveWarning(editorWarnings);
    }
  },
  correctValueToGridPickers: function(editor, record) {
    return editor.query('roweditorgridpicker').forEach(function(picker) {
      var fieldValue;
      fieldValue = record.get(picker.name);
      return picker.setPickValue(fieldValue);
    });
  },
  bindDataForComboboxes: function(context, newRowItem) {
    var comboboxes, validValues;
    comboboxes = context.grid.rowEditor.editor.query('comboboxfield');
    validValues = newRowItem.validValues;
    comboboxes.forEach(function(c) {
      var comboValues;
      if (comboValues = validValues[c.pathString]) {
        c.setComboValues(comboValues);
      }
    });
  },
  updateFieldValueFromResponse: function(roweditor, newRowItem) {
    var cm, column, columnType, comboboxValueMap, corecolumntype, data, displayValue, field, fieldType, fields, findField, form, format, grid, isLookupable, iv, key, newValues, props, v, validValues, _ref, _ref1;
    if (!roweditor || !roweditor.context) {
      return;
    }
    iv = Corefw.util.InternalVar;
    iv.setByNameProperty('roweditor', 'suspendChangeEvents', true);
    form = roweditor.form;
    grid = roweditor.context.grid;
    cm = Corefw.util.Common;
    newValues = newRowItem.value;
    comboboxValueMap = newRowItem.validValues;
    fields = form.getFields();
    findField = function(pathString) {
      return fields.findBy(function(f) {
        return f.pathString === pathString;
      });
    };
    for (key in comboboxValueMap) {
      validValues = comboboxValueMap[key];
      field = findField(key);
      v = field.getValue();
      if (field != null) {
        field.setComboValues(validValues);
      }
      field.setValue(v);
    }
    for (key in newValues) {
      data = newValues[key];
      field = form.findField(key);
      if (!field) {
        continue;
      }
      field.suspendEvents(false);
      isLookupable = false;
      fieldType = field.xtype;
      if (fieldType === 'displayfield') {
        columnType = (_ref = field.column) != null ? (_ref1 = _ref.cache) != null ? _ref1._myProperties.corecolumntype : void 0 : void 0;
        if (columnType === 'datestring' || columnType === 'date') {
          fieldType = 'datefield';
        }
      }
      switch (fieldType) {
        case 'displayfield':
        case 'comboboxfield':
          isLookupable = typeof field.isLookupable === "function" ? field.isLookupable() : void 0;
          if (isLookupable || fieldType === 'displayfield') {
            displayValue = cm.getDisplayValue(data);
          }
          data = cm.getValue(data);
          break;
        case 'roweditorgridpicker':
          if (field.selChanging) {
            field.selChanging = false;
          }
          field.addComboValue(data);
          break;
        case 'datefield':
        case 'coredatefield':
          if (Ext.isEmpty(data)) {
            break;
          }
          column = grid.columns.filter(function(c) {
            if (c.dataIndex === key) {
              return true;
            } else {
              return false;
            }
          })[0];
          props = column.cache._myProperties;
          corecolumntype = props.corecolumntype;
          if (corecolumntype === 'datestring') {
            format = 'Y-m-d H:i:s';
          } else {
            format = field.format;
          }
          if (typeof data === 'number') {
            data = new Date(data);
          } else {
            data = Ext.Date.parse(data, format);
          }
          if (format && (Ext.Date.format(field.getValue(), format) === Ext.Date.format(data, format))) {
            continue;
          }
          newValues[key] = data;
          break;
        case 'coremonthpicker':
          if (!Ext.isEmpty(data)) {
            data = new Date(data);
          }
      }
      field.setValue(data);
      if (field.xtype === 'corenumberfield' && field.focused) {
        field.setRawValue(field.getValue());
        delete field.focused;
      }
      if (isLookupable || fieldType === 'displayfield') {
        field.setRawValue(displayValue);
      }
      field.resumeEvents();
    }
    iv.setByNameProperty('roweditor', 'suspendChangeEvents', false);
  },
  bindHistoryInfoToCombobox: function(editor, headers, rowItem) {
    var combos, findMatchHeader;
    combos = editor.query("combobox");
    findMatchHeader = function(combo) {
      var result;
      result = null;
      Ext.each(headers, function(header) {
        if (header.pathString === combo.pathString) {
          result = header;
          return false;
        }
      });
      return result;
    };
    Ext.each(combos, function(combo) {
      var header, historyInfo;
      header = findMatchHeader(combo);
      historyInfo = rowItem.historyInfo ? rowItem.historyInfo : header.historyInfo;
      if (historyInfo) {
        return combo.historyInfo = historyInfo;
      }
    });
  },
  bindValidatorToFields: function(editor, newFieldValidationMap, errors) {
    var allContents, columnCache, context, defaultValidator, field, fieldValidationMaps, fields, newFieldValidation, originalFieldValidations, parentCache, path, validations, _i, _j, _len, _len1, _ref;
    fields = editor.form.getFields().items;
    context = editor.context;
    parentCache = context.grid.up('fieldcontainer').cache;
    allContents = parentCache._myProperties.allContents;
    fieldValidationMaps = {};
    defaultValidator = function() {
      return true;
    };
    for (_i = 0, _len = allContents.length; _i < _len; _i++) {
      columnCache = allContents[_i];
      path = columnCache.path || columnCache.pathString;
      originalFieldValidations = columnCache.validations || [];
      newFieldValidation = newFieldValidationMap[path] || [];
      if (newFieldValidation && newFieldValidation.length > 0) {
        originalFieldValidations = Ext.Array.merge(originalFieldValidations, newFieldValidation);
      }
      if (originalFieldValidations && originalFieldValidations.length > 0) {
        fieldValidationMaps[path] = originalFieldValidations;
      }
    }
    for (_j = 0, _len1 = fields.length; _j < _len1; _j++) {
      field = fields[_j];
      validations = fieldValidationMaps[field.pathString] || fieldValidationMaps[field.id] || [];
      field.validator = defaultValidator;
      if (validations.length || ((_ref = errors[field.pathString]) != null ? _ref.length : void 0)) {
        field.validator = this.createValidator(editor, field, validations, errors);
      } else {
        this.cleanEmptyText(field);
      }
    }
  },
  disableOrEnableCells: function(editor) {
    var allFields, disabledHeaders, enabledHeaders, field, form, _i, _len, _ref, _ref1;
    form = editor.form;
    disabledHeaders = ((_ref = editor.currentEditingRowData) != null ? _ref.disabledHeaders : void 0) || [];
    enabledHeaders = ((_ref1 = editor.currentEditingRowData) != null ? _ref1.enabledHeaders : void 0) || [];
    this.resetCellDisabledState(form);
    if (disabledHeaders.length === 0 && enabledHeaders.length === 0) {
      return;
    }
    allFields = form.getFields().items;
    for (_i = 0, _len = allFields.length; _i < _len; _i++) {
      field = allFields[_i];
      if (disabledHeaders.indexOf(field.pathString) !== -1 || disabledHeaders.indexOf(field.id) !== -1) {
        field.disable();
      }
      if (enabledHeaders.indexOf(field.pathString) !== -1 || enabledHeaders.indexOf(field.id) !== -1) {
        field.enable();
      }
    }
  },
  resetCellDisabledState: function(form) {
    var allFields, field, _i, _len, _results;
    allFields = form.getFields().items;
    _results = [];
    for (_i = 0, _len = allFields.length; _i < _len; _i++) {
      field = allFields[_i];
      if (!field.hasOwnProperty('origDisabled')) {
        field.origDisabled = field.disabled;
      }
      _results.push(field.setDisabled(field.origDisabled));
    }
    return _results;
  },
  createValidator: function(editor, field, validationRules, errors) {
    var me;
    field.errMsg = {};
    me = this;
    return function(value) {
      var validateResult;
      validateResult = me.validateByErrorMessage(editor, field, value, errors);
      if (validateResult.isValid === true) {
        validateResult = me.validateValueByValidationRules(this, value, validationRules);
      }
      me.cancelValidationTooltip(editor);
      return validateResult.isValid || validateResult.errMsg;
    };
  },
  validateByErrorMessage: function(editor, field, value, errors) {
    var errorMessage, validateResult;
    if (!errors) {
      return;
    }
    validateResult = {
      'isValid': true,
      'errMsg': null
    };
    errorMessage = errors[field.pathString] || [];
    if ((errorMessage != null ? errorMessage.length : void 0) > 0) {
      validateResult.isValid = false;
      validateResult.errMsg = errorMessage.join('<br>&nbsp;');
    }
    this.cancelValidationTooltip(editor);
    return validateResult;
  },
  validateValueByValidationRules: function(field, value, validations) {
    var emptyText, maxLength, minLength, reg, valdtn, validateResult, _i, _len;
    validateResult = {
      'isValid': true,
      'errMsg': null
    };
    for (_i = 0, _len = validations.length; _i < _len; _i++) {
      valdtn = validations[_i];
      if (valdtn.constraintName === "FieldRegex") {
        reg = eval('/' + valdtn.constraintMap.pattern + '/');
        if (!reg.test(value)) {
          validateResult.errMsg = valdtn.constraintMessage;
          validateResult.isValid = false;
          break;
        }
      } else if (valdtn.constraintName === "FieldNotNull") {
        if (Ext.isEmpty(value)) {
          emptyText = "required";
          field.emptyText = emptyText;
          this.setPlaceHolderValue(field, emptyText);
          validateResult.errMsg = valdtn.constraintMessage;
          validateResult.isValid = false;
          break;
        }
      } else if (valdtn.constraintName === "FieldLength") {
        minLength = valdtn.constraintMap.minLength;
        maxLength = valdtn.constraintMap.maxLength;
        if (!value && minLength === 0) {
          break;
        }
        if (minLength && value.length < minLength || maxLength && value.length > maxLength) {
          validateResult.errMsg = valdtn.constraintMessage;
          validateResult.isValid = false;
          break;
        }
      }
    }
    return validateResult;
  },
  cancelValidationTooltip: function(editor) {
    var hide;
    hide = Ext.Function.createDelayed(function() {
      editor.hideToolTip();
    }, 1);
    hide();
  },
  cleanEmptyText: function(field) {
    if (field.emptyText === 'required') {
      field.emptyText = '';
      field.applyEmptyText();
      this.setPlaceHolderValue(field, '');
    }
  },
  setPlaceHolderValue: function(field, value) {
    var e;
    e = Ext.DomQuery.select('input', field.el.dom)[0];
    if (e != null) {
      e.placeholder = value;
    }
  },
  refocusOnCorrectField: function(form, columnHeader) {
    var field, fieldId;
    fieldId = columnHeader.getEditor().id;
    field = form.findField(fieldId);
    if (field && !field.isDisabled()) {
      field.suspendEvents(false);
      field.focus(false, 1);
      field.resumeEvents();
    }
  },
  processProhibited: function(grid, record) {
    var cm, data, isItemReadOnly, isProhibited, props, rowIndex, store, _ref, _ref1, _ref2;
    cm = Corefw.util.Common;
    store = record.store;
    rowIndex = cm.findRecordIndex(store, record);
    isProhibited = cm.processProhibited(grid);
    props = (grid != null ? (_ref = grid.up('fieldcontainer')) != null ? (_ref1 = _ref.cache) != null ? _ref1._myProperties : void 0 : void 0 : void 0) || {};
    data = props.widgetType === "TREE_GRID" ? cm.converTreeGridDataToDataList(props.allTopLevelNodes) : props.items;
    isItemReadOnly = (_ref2 = data[rowIndex]) != null ? _ref2.readOnly : void 0;
    if (isItemReadOnly || isProhibited) {
      return true;
    } else {
      return false;
    }
  },
  valueGetter: {
    roweditorgridpicker: function(field) {
      var cm, currVal, currValues, vals, valueMap, _i, _len;
      cm = Corefw.util.Common;
      vals = [];
      valueMap = field.valueMap;
      currValues = field.value;
      if (Ext.isArray(currValues)) {
        for (_i = 0, _len = currValues.length; _i < _len; _i++) {
          currVal = currValues[_i];
          vals.push({
            displayValue: cm.getKeyByValue(currVal, valueMap),
            value: currVal
          });
        }
      } else {
        vals.push({
          displayValue: cm.getKeyByValue(currValues, valueMap),
          value: currValues
        });
      }
      if (field.multiSelect) {
        return vals;
      } else {
        return vals[0];
      }
    },
    comboboxfield: function(field) {
      return {
        displayValue: field.getRawValue(),
        value: field.getValue()
      };
    }
  },
  valueComparator: {
    roweditorgridpicker: function(newValue, oldValue, multiSelect) {
      var i, v, _i, _len;
      if (multiSelect) {
        if (newValue.length !== oldValue.length) {
          return false;
        } else {
          for (i = _i = 0, _len = newValue.length; _i < _len; i = ++_i) {
            v = newValue[i];
            if (!(v.value === oldValue[i].value)) {
              return false;
            }
          }
        }
        return true;
      } else {
        return newValue.value === oldValue.value;
      }
    },
    comboboxfield: function(newValue, oldValue) {
      if (Ext.isObject(newValue)) {
        newValue = newValue.value || '';
      }
      if (Ext.isObject(oldValue)) {
        oldValue = oldValue.value || '';
      }
      return newValue === oldValue;
    },
    coremonthpicker: function(newValue, oldValue) {
      var mFormat;
      mFormat = function(d) {
        var month;
        month = d.getMonth() + 1;
        return d.getFullYear() + (month < 10 ? '-0' : '-') + month;
      };
      if (newValue instanceof Date) {
        newValue = mFormat(newValue);
      }
      if (oldValue instanceof Date) {
        oldValue = mFormat(oldValue);
      }
      return newValue === oldValue;
    },
    datefield: function(newValue, oldValue) {
      var dFormat;
      dFormat = function(d) {
        return d.getFullYear() + '-' + (d.getMonth() + 1) + '-' + d.getDate();
      };
      if (newValue instanceof Date) {
        newValue = dFormat(newValue);
      }
      if (oldValue instanceof Date) {
        oldValue = dFormat(oldValue);
      }
      return newValue === oldValue;
    }
  },
  updateRecord: function(record, values) {
    var changedValues, getValue, key, newValue, oldValue, value;
    changedValues = {};
    getValue = function(value) {
      if (Ext.isObject(value) && value.hasOwnProperty('value')) {
        return value.value;
      } else if (Ext.isDate(value)) {
        return value.getTime();
      } else if (Ext.isArray(value)) {
        return (value.map(function(v) {
          return v.value || v;
        })).sort().join(',');
      } else {
        return value;
      }
    };
    for (key in values) {
      value = values[key];
      if (value === void 0) {
        continue;
      }
      oldValue = getValue(record.get(key));
      newValue = getValue(value);
      if (oldValue !== newValue) {
        if ((Ext.isDate(record.get(key))) && Ext.isNumber(value)) {
          value = new Date(value);
        }
        changedValues[key] = value;
      }
    }
    record.beginEdit();
    record.set(changedValues);
    record.endEdit();
  },
  getFormValues: function(form) {
    var displayValue, field, fieldValues, fields, value, _i, _len;
    fields = form.getFields().items;
    fieldValues = form.getFieldValues();
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      value = fieldValues[field.name];
      if (value && field.getDisplayValue) {
        displayValue = field.getRawValue();
        fieldValues[field.name] = {
          displayValue: displayValue,
          value: value
        };
      }
    }
    return fieldValues;
  },
  sendData: function(context, evt, isAsync) {
    var callback, dataGrid, dataItems, evtMap, grid, postData, root, rq, uipath, updateURL, url;
    if (isAsync == null) {
      isAsync = true;
    }
    evtMap = this.evtMap || {
      'update': 'ONAFTEREDIT',
      'cancel': 'ONCANCELEDIT',
      'before': 'ONBEFOREEDIT'
    };
    grid = context.grid;
    if (grid.xtype === 'coretreebase') {
      dataGrid = context.grid.up('coretreegrid');
      root = grid.store.tree.root;
      Corefw.util.Common.traverseTreeStore(root, function(record) {
        record.isEditing = false;
      });
    } else {
      dataGrid = context.grid.up('coreobjectgrid');
      dataItems = grid.store.data.items;
      Ext.Array.forEach(dataItems, function(r) {
        r.isEditing = false;
      });
    }
    context.record.isEditing = true;
    updateURL = dataGrid.eventURLs[evtMap[evt]];
    uipath = dataGrid.uipath;
    rq = Corefw.util.Request;
    url = rq.objsToUrl3(updateURL);
    if (!url) {
      return;
    }
    postData = dataGrid.generatePostData();
    callback = evt === 'before' ? this.processDataBeforeEdit(context) : rq.processResponseObject;
    rq.sendRequest5(url, callback, uipath, postData, void 0, void 0, void 0, void 0, void 0, isAsync);
  }
});
