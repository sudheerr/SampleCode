// Generated by CoffeeScript 1.8.0
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Ext.define('Corefw.mixin.FieldContainer', {
  constructor: function() {
    this.initializeConstants();
  },
  initializeConstants: function() {
    var cm, rdr, su;
    cm = Corefw.util.Common;
    rdr = Corefw.util.Render;
    su = Corefw.util.Startup;
    this.xtypeConfigDef = {
      'Default': {
        xtype: 'citirisktextinput'
      },
      textfield: {
        xtype: 'citirisktextinput'
      },
      number: {
        xtype: 'corenumberfield'
      },
      combobox: {
        xtype: 'comboboxfield'
      },
      trigger: {
        xtype: 'coretriggerfield'
      },
      advanced_combobox: {
        xtype: 'advancedcomboboxfield'
      },
      textarea: {
        xtype: 'coretextarea'
      },
      radiogroup: {
        xtype: 'coreradiogroup'
      },
      switchbutton: {
        xtype: 'coreSwitchBtn'
      },
      'date': {
        xtype: 'coredatefield',
        format: 'd M Y'
      },
      datestring: {
        xtype: 'coredatestringfield',
        format: 'd M Y'
      },
      month_picker: {
        xtype: 'coremonthpicker',
        format: 'Y-m'
      },
      togglebutton: {
        xtype: 'coretoggleslidefield'
      },
      richtext: {
        xtype: 'corehtmleditor'
      },
      checkbox: {
        xtype: 'checkbox'
      },
      checkgroup: {
        xtype: 'corecheckboxgroup'
      },
      icon: {
        xtype: 'coreiconfield'
      },
      objectgrid: {
        xtype: 'coreobjectgrid'
      },
      object_grid: {
        xtype: 'coreobjectgrid'
      },
      rcgrid: {
        xtype: 'corercgrid'
      },
      simpletree: {
        xtype: 'coretreesimple'
      },
      tree: {
        xtype: 'coretreesimple'
      },
      tree_grid: {
        xtype: 'coretreegrid'
      },
      tree_navigation: {
        xtype: 'coretreeleftnavigation'
      },
      treenavigation: {
        xtype: 'coretreeleftnavigation'
      },
      mixedgrid: {
        xtype: 'coretreemixedgrid'
      },
      mixed_grid: {
        xtype: 'coretreemixedgrid'
      },
      hierarchy_object_grid: {
        xtype: 'corehierarchygrid'
      },
      chart: {
        xtype: 'corechartfield'
      },
      cell_grid: {
        xtype: 'coreallocgrid'
      },
      grouped_grid: {
        xtype: 'coregroupedtreegrid'
      },
      cellgrid: {
        xtype: 'coreallocgrid'
      },
      label: {
        xtype: 'displayfield',
        fieldStyle: {
          'white-space': 'nowrap',
          'overflow': 'hidden',
          'text-overflow': 'ellipsis'
        }
      },
      link: {
        xtype: 'corelinkfield',
        labelStyle: su.getThemeVersion() === 2 ? 'padding-bottom: 6px' : void 0,
        fieldStyle: su.getThemeVersion() === 2 ? {
          'margin-top': '0px'
        } : void 0
      },
      file_upload: {
        xtype: 'corefileupload'
      },
      remoteurl: {
        xtype: 'coreiframefield',
        element: this
      },
      remote_url: {
        xtype: 'coreiframefield',
        element: this
      },
      tree_picker: {
        xtype: 'coretreepickernew'
      },
      grid_picker: {
        xtype: 'coregridpicker'
      },
      fieldset: {
        xtype: 'corefieldset'
      },
      pivotgrid: {
        xtype: 'pivottablefield'
      },
      dual_listbox: {
        xtype: 'coreduallistbox'
      }
    };
    return this.fieldObjDef = {
      xtype: 'displayfield',
      labelAlign: 'top',
      msgTarget: su.getThemeVersion() === 2 ? 'under' : 'side',
      labelStyle: su.getThemeVersion() === 2 ? 'padding-bottom: 6px' : void 0
    };
  },
  deleteConstants: function() {
    delete this.xtypeConfigDef;
    delete this.fieldObjDef;
  },
  layoutMain: function() {
    var cache, field, fieldDef, fieldDefs, fieldProps, fields, layoutManager, me, props, su, verSepExists, _i, _len;
    me = this;
    layoutManager = me.layoutManager;
    if (!layoutManager.validate()) {
      me.addCls('invalid-layout');
      return;
    }
    if (typeof layoutManager.setLayoutVariables === "function") {
      layoutManager.setLayoutVariables(me);
    }
    me.initializeConstants();
    cache = me.cache;
    props = cache._myProperties;
    fields = me.getFormCacheFields();
    fieldDefs = [];
    me.contentDefs = fieldDefs;
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      fieldProps = field != null ? field._myProperties : void 0;
      if (!(fieldProps != null ? fieldProps.isRemovedFromUI : void 0) && (fieldProps != null ? fieldProps.visible : void 0)) {
        verSepExists = false;
        if (props.verticalSeparator) {
          verSepExists = props.verticalSeparator.length;
        }
        fieldDef = me.genFieldDef(field, verSepExists);
        if (fieldDef) {
          fieldDefs.push(fieldDef);
        }
      }
    }
    layoutManager.initLayout();
    Corefw.util.Render.renderNavs(props, me);
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      me.initCorrectMessage();
      me.addErrorMessageTips();
    }
    me.renderMessages();
    me.renderFieldMessages();
    me.deleteConstants();
    me.verticalSep();
    Corefw.util.Data.displayFormData(this, cache);
  },
  initCorrectMessage: function() {
    var correctMsg, field, fields, me, props, validations, validtnXtypes, _i, _len, _ref, _ref1;
    me = this;
    fields = me.query('field');
    validtnXtypes = ['citirisktextinput', 'textareafield', 'corenumberfield', 'comboboxfield', 'citiriskdatepicker', 'coretreepickernew', 'coredatefield', 'coredatestringfield'];
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      if (_ref = field.xtype, __indexOf.call(validtnXtypes, _ref) >= 0) {
        props = (_ref1 = field.cache) != null ? _ref1._myProperties : void 0;
        if ((props != null ? props.validations.length : void 0) > 0) {
          validations = props.validations;
          correctMsg = '';
          this.setCorrectMessage(field, correctMsg);
        }
      }
    }
  },
  setCorrectMessage: function(field, correctMsg) {
    var generateCorrectMessage;
    generateCorrectMessage = function(field) {
      Ext.create('Corefw.view.form.field.CorrectMessage', {
        field: field,
        renderTo: field.bodyEl,
        correctMsg: correctMsg
      });
    };
    if (field.rendered) {
      generateCorrectMessage(field);
    } else {
      field.on && field.on('afterrender', function(field) {
        generateCorrectMessage(field);
      });
    }
  },
  addErrorMessageTips: function() {
    var field, fields, generateErrorMessageTips, me, _i, _len;
    me = this;
    fields = me.query('field');
    for (_i = 0, _len = fields.length; _i < _len; _i++) {
      field = fields[_i];
      generateErrorMessageTips = function(field) {
        field.on('errorchange', function(field) {
          var error, errorTip, _j, _len1, _ref, _ref1;
          errorTip = '';
          if (((_ref = field.activeErrors) != null ? _ref.length : void 0) > 0 && field.errorEl) {
            _ref1 = field.activeErrors;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              error = _ref1[_j];
              errorTip += error;
            }
            field.errorEl.set({
              'data-qtip': errorTip
            });
          }
        });
      };
      if (field.rendered) {
        generateErrorMessageTips(field);
      } else {
        field.on && field.on('afterrender', function(field) {
          generateErrorMessageTips(field);
        });
      }
    }
  },
  verticalSep: function() {
    var SepAr, lv, margin, me, props, su, th, verticalSep, verticalSepAr, verticalSepArCoord, verticalSepArobj, _i, _len;
    su = Corefw.util.Startup;
    me = this;
    lv = me.lv;
    props = me.cache._myProperties;
    verticalSepAr = props != null ? props.verticalSeparator : void 0;
    if (!(verticalSepAr && verticalSepAr.length)) {
      return;
    }
    SepAr = [];
    for (_i = 0, _len = verticalSepAr.length; _i < _len; _i++) {
      verticalSep = verticalSepAr[_i];
      verticalSepArCoord = {
        x: verticalSep,
        y: 0,
        xsize: 0,
        ysize: 0
      };
      th = lv.numRows * lv.panelRowHeight - 20 + 'px';
      margin = "" + ((lv.extraMarginTop || 0) + 20) + "px 0px 0px";
      if (su.getThemeVersion() === 2) {
        margin = margin + ' -15px';
      } else {
        margin = margin + ' -6px';
      }
      verticalSepArobj = {
        xtype: 'component',
        width: '1px',
        height: th,
        orig: verticalSepArCoord,
        style: {
          borderColor: '#BFBFBF',
          margin: margin,
          borderWidth: '0px 1px 0px 0px',
          borderStyle: 'solid'
        }
      };
      SepAr.push(verticalSepArobj);
      this.add(SepAr);
    }
  },
  updateUIData: function(cache) {
    var cm, iv, props, relativeForm;
    cm = Corefw.util.Common;
    iv = Corefw.util.InternalVar;
    props = cache._myProperties;
    cm.updateCommon(this, props);
    this.cache = cache;
    if (!this.rendered) {
      return;
    }
    this.layoutManager.removeAll();
    relativeForm = this.form;
    if (relativeForm) {
      delete relativeForm.wasValid;
      delete relativeForm._boundItems;
    }
    this.initializeConstants();
    this.disableFormEvents = true;
    this.layoutMain();
    if (typeof this.elementMixinRender === "function") {
      this.elementMixinRender();
    }
    this.deleteConstants();
    this.disableFormEvents = false;
    Corefw.util.Render.appendPendingLayout(this);
  },
  updateField: function(field, cache) {
    var disabled, error, hidden, me, messages, newClsList, newClsListStr, oldCache, oldClsList, oldClsListStr, parent, props, readOnly, value, warning, _ref, _ref1;
    oldCache = field.cache;
    me = this;
    me.disableFormEvents = true;
    field.cache = cache;
    props = cache._myProperties;
    if (props.isRemovedFromUI) {
      parent = field.up();
      parent.remove(field);
      return;
    }
    disabled = !props.enabled;
    disabled !== field.disabled && field.setDisabled(disabled);
    hidden = !props.visible;
    hidden !== field.hidden && field.setVisible(props.visible);
    readOnly = props.readOnly;
    readOnly !== field.readOnly && (typeof field.setReadOnly === "function" ? field.setReadOnly(readOnly) : void 0);
    if (props.type === 'COMBOBOX' && ((_ref = props.validValues) != null ? _ref.length : void 0) > 0) {
      field.setComboValues(props.validValues);
    }
    if (field.updateByCache) {
      field.updateByCache(cache);
    } else if ((_ref1 = props.type) === 'RADIOGROUP' || _ref1 === 'CHECKGROUP') {
      value = {};
      value[props.name] = props.value;
      field.setValue(value);
    } else {
      value = props.value;
      field.setValue(value);
    }
    me.disableFormEvents = false;
    field.unsetActiveError();
    field.unsetActiveWarning();
    messages = props.messages;
    if (error = messages.ERROR) {
      field.setActiveError(error);
      field.doComponentLayout();
    } else if (warning = messages.WARNING) {
      field.setActiveWarning(warning);
    }
    oldClsListStr = oldCache._myProperties.cssClass;
    oldClsList = oldCache._myProperties.cssClassList;
    if (oldClsList.length > 0) {
      oldClsListStr = oldClsList.join(' ');
    }
    newClsListStr = props.cssClass;
    newClsList = props.cssClassList;
    if (newClsList.length > 0) {
      newClsListStr = newClsList.join(' ');
    }
    if (oldClsListStr !== newClsListStr) {
      oldClsList.forEach(function(oldCls) {
        return field.removeCls(oldCls);
      });
      field.addCls(newClsListStr);
    }
  },
  shouldUpdateField: function(comp, cache) {
    var excludedTypes, isExcludedType, props, res, type, widgetType;
    res = true;
    props = cache._myProperties;
    widgetType = props.widgetType, type = props.type;
    excludedTypes = ['advanced_combobox', 'grid_picker', 'tree_picker'];
    isExcludedType = excludedTypes.includes ? excludedTypes.includes(type) : excludedTypes.indexOf(type) > -1;
    return (comp.setValue || comp.updateByCache) && !isExcludedType;
  },
  replaceChild: function(cache, ev) {
    var comp, componentIndex, fieldDef, grid, layoutManager, me, props, restoreScroll, shouldReCreateGrid, uip, uipath, verSepExists, _ref;
    uip = Corefw.util.Uipath;
    me = this;
    layoutManager = me.layoutManager;
    props = cache._myProperties;
    uipath = props.uipath;
    comp = uip.uipathToComponent(uipath);
    if (!comp) {
      return;
    }
    if (props.widgetType === 'FIELD') {
      if (me.shouldUpdateField(comp, cache)) {
        me.updateField(comp, cache);
      }
      return;
    }
    componentIndex = layoutManager.getContentIndex(comp);
    if (comp.grid) {
      Ext.suspendLayouts();
      shouldReCreateGrid = comp.grid.shouldReCreateGrid(cache);
      if (((_ref = comp.grid) != null ? _ref.isEditing : void 0) === true) {
        comp.cache = cache;
        grid = comp.grid;
        grid.updateFromCache(cache);
        Ext.resumeLayouts(true);
        return;
      } else if (!shouldReCreateGrid) {
        comp.cache = cache;
        grid = comp.grid;
        restoreScroll = grid.cacheScrollValue();
        Ext.resumeLayouts(true);
        grid.updateStoreFromCache(cache);
        restoreScroll();
        return;
      }
      layoutManager.remove(comp);
    } else {
      layoutManager.remove(comp);
    }
    if (me.el) {
      me.initializeConstants();
      verSepExists = props.verticalSeparator;
      fieldDef = me.genFieldDef(cache, verSepExists);
      me.deleteConstants();
      layoutManager.add(fieldDef, componentIndex);
      if (!(comp.grid || comp.tree)) {
        me.disableFormEvents = true;
        Corefw.util.Data.updateDisplayFormData(me, cache);
        me.disableFormEvents = false;
      }
    }
    if (comp && comp.grid) {
      Ext.resumeLayouts(true);
    }
    Corefw.util.Render.appendPendingLayout(this);
  },
  genFieldDef: function(field, verSepExists) {
    var addlConfig, addlSetup, cm, cssClass, cssClassList, evt, fieldProps, fieldType, iv, newObj, su, uipath, xtypeObj, _ref, _ref1;
    cm = Corefw.util.Common;
    evt = Corefw.util.Event;
    su = Corefw.util.Startup;
    iv = Corefw.util.InternalVar;
    fieldProps = field._myProperties;
    newObj = cm.objectClone(this.fieldObjDef);
    fieldType = (_ref = fieldProps.type) != null ? _ref.toLowerCase() : void 0;
    if (!fieldType) {
      fieldType = (_ref1 = fieldProps.widgetType) != null ? _ref1.toLowerCase() : void 0;
      if (!fieldType) {
        console.log('ERROR: genFieldDef: field type not found ', fieldType, fieldProps);
        return;
      }
    }
    fieldType = fieldType.toLowerCase();
    xtypeObj = this.xtypeConfigDef[fieldType];
    if (fieldProps.format) {
      xtypeObj.format = fieldProps.format;
    }
    if (xtypeObj && typeof xtypeObj === 'object') {
      Ext.apply(newObj, xtypeObj);
    } else {
      console.log('ERROR: genFieldDef: field type not found: type, props: ', fieldType, fieldProps);
      return;
    }
    addlConfig = {
      cache: field,
      name: fieldProps.name,
      labelSeparator: '',
      disabled: !fieldProps.enabled,
      hidden: !fieldProps.visible
    };
    if (fieldProps.width) {
      addlConfig.width = fieldProps.width;
    }
    if (fieldProps.readOnlyStyle === true) {
      if (su.getThemeVersion() === 2) {
        newObj.baseBodyCls = 'fieldReadOnlyCls';
      } else {
        newObj.fieldStyle = {
          backgroundColor: '#D5D6D7',
          backgroundImage: 'none',
          borderColor: '#a2a2a2 ',
          opacity: 0.98
        };
        newObj.labelStyle = 'opacity:1';
      }
    }
    if (su.getThemeVersion() === 2) {
      newObj.overCls = 'fieldOverCls';
    }
    Ext.apply(newObj, addlConfig);
    cssClassList = fieldProps.cssClassList;
    if (!fieldProps.cssClass && iv.getByUipathProperty(fieldProps.uipath, 'mixed-form-element') === true) {
      cssClassList.push('mixed-form-element');
    }
    if (cssClassList != null ? cssClassList.length : void 0) {
      newObj.cls = cssClassList.join(' ');
    } else {
      cssClass = fieldProps.cssClass;
      if (cssClass) {
        newObj.cls = cssClass;
      }
    }
    this.setFieldLabel(newObj, fieldProps);
    if (fieldProps.style) {
      newObj.fieldStyle = this.getFieldStyle(fieldProps);
    }
    uipath = fieldProps.uipath;
    newObj.uipath = uipath;
    newObj.setActiveWarning = this.setFieldWarningMessage;
    newObj.unsetActiveWarning = this.unsetFieldWarningMessage;
    addlSetup = this.addlComponentSetup[fieldType];
    if (addlSetup) {
      addlSetup.call(this, newObj, fieldProps);
    }
    if (verSepExists) {
      newObj.style = {
        backgroundColor: '#ffffff',
        zIndex: 1
      };
    }
    evt.addEvents(fieldProps, 'field', newObj);
    this.configureValidation(fieldProps, newObj);
    if (fieldProps.fieldMask) {
      newObj.inputMask = fieldProps.fieldMask;
      newObj.enableKeyEvents = true;
    }
    evt.enableUEvent(uipath, 'ONSELECT');
    evt.enableUEvent(uipath, 'ONCHANGE');
    evt.enableUEvent(uipath, 'ONBLUR');
    return newObj;
  },
  setFieldWarningMessage: function(warningMessage) {
    var field, genWarningMessage;
    field = this;
    genWarningMessage = function(field) {
      var inputRow;
      inputRow = field.inputRow;
      if (!inputRow) {
        return;
      }
      field.activeWarning = Ext.create('Corefw.view.form.field.WarningMessage', {
        field: field,
        renderTo: inputRow,
        message: warningMessage
      });
    };
    if (field.rendered) {
      genWarningMessage(field);
    } else {
      field.on && field.on('afterrender', function(field) {
        genWarningMessage(field);
      });
    }
  },
  unsetFieldWarningMessage: function() {
    var field, _ref;
    field = this;
    if (field.activeWarning) {
      field.activeWarning.destroy();
      field.inputEl.dom.classList.remove('x-form-warning-field');
      if ((_ref = field.inputRow.dom.querySelector('.x-component-field-warningmessage')) != null) {
        if (typeof _ref.remove === "function") {
          _ref.remove();
        }
      }
      delete field.activeWarning;
    }
  },
  setFieldLabel: function(newObj, fieldProps) {
    var su;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      if (newObj.xtype === 'corechartfield') {
        return;
      }
    }
    if (fieldProps.title) {
      newObj.fieldLabel = fieldProps.title;
    } else {
      if (su.getThemeVersion() === 2) {
        if (newObj.xtype !== 'textareafield') {
          newObj.fieldLabel = '&nbsp;';
        }
      } else {
        newObj.fieldLabel = '&nbsp;';
      }
    }
  },
  getFormCacheFields: function() {
    var field, fields, formCache, key;
    formCache = this.cache;
    fields = [];
    for (key in formCache) {
      field = formCache[key];
      if (key !== '_myProperties') {
        fields.push(field);
      }
    }
    return fields;
  },
  renderTooltips: function(fieldDefs) {
    var formItemCls, me, needDelayTooltips, tooltipConfig;
    me = this;
    needDelayTooltips = Corefw.util.Startup.getStartupObj().delayTooltips === true;
    formItemCls = Ext.form.Labelable.prototype.formItemCls;
    tooltipConfig = {
      dismissDelay: 0,
      target: me.el,
      delegate: ":any(." + formItemCls + "|.cv-form-abs-btn)",
      renderTo: Ext.getBody(),
      listeners: {
        beforeshow: function(tip) {
          var compXtype, contentComp, labelDom, tooltip, triggerElement, visibleTooltips, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
          triggerElement = tip.triggerElement;
          contentComp = Ext.getCmp(tip.triggerElement.id);
          if (!contentComp) {
            return false;
          }
          tooltip = (_ref = contentComp.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.toolTip : void 0 : void 0;
          if (!tooltip) {
            compXtype = contentComp.xtype;
            switch (compXtype) {
              case 'button':
                labelDom = (_ref2 = contentComp.btnInnerEl) != null ? _ref2.dom : void 0;
                break;
              case 'coreSwitchBtn':
                labelDom = (_ref3 = contentComp.header) != null ? (_ref4 = _ref3.titleCmp) != null ? (_ref5 = _ref4.textEl) != null ? _ref5.dom : void 0 : void 0 : void 0;
                break;
              case 'coretriggerfield':
                labelDom = (_ref6 = contentComp.inputEl) != null ? _ref6.dom : void 0;
                if (labelDom && labelDom.scrollWidth > labelDom.clientWidth) {
                  tip.update(labelDom.value);
                  tip.maxWidth = 600;
                  return;
                }
                return false;
              default:
                labelDom = (_ref7 = contentComp.labelEl) != null ? _ref7.dom : void 0;
            }
            if (labelDom && labelDom.scrollWidth > labelDom.clientWidth) {
              tip.update(labelDom.textContent);
              return;
            }
            return false;
          }
          visibleTooltips = Ext.ComponentQuery.query('tooltip[hidden=false]');
          if (visibleTooltips.length > 0) {
            return false;
          }
          tip.update(tooltip);
        },
        click: {
          element: 'el',
          fn: function(el, d) {
            Ext.getCmp(this.id).showAt(this.getXY);
          }
        }
      }
    };
    if (needDelayTooltips) {
      tooltipConfig.hideDelay = 1200;
    }
    me.tooltipManager = Ext.create('Ext.tip.ToolTip', tooltipConfig);
  },
  renderFieldMessages: function() {
    var errorDisplayFunc, errorMessage, fieldDef, fieldDefs, genFieldMessage, me, message, messages, messagesToDisplay, myFunc, props, uipath, warningMessage, _i, _len, _ref;
    me = this;
    fieldDefs = me.contentDefs;
    messagesToDisplay = [];
    genFieldMessage = function(fmessages) {
      var fmessage, messageStr, _i, _len;
      if (!fmessages) {
        return;
      }
      messageStr = '';
      for (_i = 0, _len = fmessages.length; _i < _len; _i++) {
        fmessage = fmessages[_i];
        if (fmessage) {
          messageStr += fmessage + '<br>';
        }
      }
      if (messageStr) {
        messageStr += '&nbsp;';
      }
      return messageStr;
    };
    for (_i = 0, _len = fieldDefs.length; _i < _len; _i++) {
      fieldDef = fieldDefs[_i];
      props = (_ref = fieldDef.cache) != null ? _ref._myProperties : void 0;
      uipath = props.uipath;
      messages = props.messages;
      if (messages) {
        errorMessage = genFieldMessage(messages.ERROR);
        warningMessage = genFieldMessage(messages.WARNING);
        if (errorMessage || warningMessage) {
          message = {
            uipath: uipath,
            error: errorMessage,
            warning: warningMessage
          };
          messagesToDisplay.push(message);
        }
      }
    }
    errorDisplayFunc = function() {
      var comp, su, _j, _len1, _ref1;
      console.log('messagesToDisplay: messagesToDisplay: ', messagesToDisplay, this);
      if (!messagesToDisplay) {
        console.log('messagesToDisplay not found');
        return;
      } else {
        console.log({
          'messagesToDisplay found': messagesToDisplay
        });
      }
      for (_j = 0, _len1 = messagesToDisplay.length; _j < _len1; _j++) {
        message = messagesToDisplay[_j];
        uipath = message.uipath;
        comp = me.down("[uipath=" + uipath + "]");
        if (!comp) {
          return;
        }
        if (message.error) {
          comp.setActiveError(message.error);
          su = Corefw.util.Startup;
          if (su.getThemeVersion() === 2) {
            if ((_ref1 = comp.errorEl) != null) {
              _ref1.set({
                'data-qtip': message.error
              });
            }
          }
        } else {
          if (message.warning) {
            comp.setActiveWarning(message.warning);
          }
        }
        comp.doComponentLayout();
      }
    };
    if (messagesToDisplay.length) {
      myFunc = Ext.Function.createDelayed(errorDisplayFunc, 1);
      myFunc();
    }
  },
  renderMessages: function() {
    var me, messageObj, msg, msgArray, msgType, newStatusMsg, props, statusMsgs, statusObj, typesOfMessages, _i, _j, _len, _len1;
    me = this;
    props = me.cache._myProperties;
    messageObj = props.messages;
    if (!messageObj) {
      return;
    }
    statusMsgs = [];
    typesOfMessages = ['ERROR', 'WARNING', 'SUCCESS', 'INFORMATION'];
    for (_i = 0, _len = typesOfMessages.length; _i < _len; _i++) {
      msgType = typesOfMessages[_i];
      msgArray = messageObj[msgType];
      if (msgArray && msgArray.length) {
        for (_j = 0, _len1 = msgArray.length; _j < _len1; _j++) {
          msg = msgArray[_j];
          newStatusMsg = {
            level: msgType.toLowerCase(),
            text: msg
          };
          statusMsgs.push(newStatusMsg);
        }
      }
    }
    if (!statusMsgs.length) {
      return;
    }
    statusObj = {
      xtype: 'statusview',
      statusMsgs: statusMsgs,
      margin: '6 0 0 0'
    };
    me.layoutManager.addStatus(statusObj);
  },
  addlComponentSetup: {
    textfield: function(newCompObj, fieldProps) {
      if (fieldProps.masked) {
        newCompObj.inputType = 'password';
      }
      if (fieldProps.emptyText) {
        newCompObj.emptyText = fieldProps.emptyText;
      }
      if (fieldProps.format) {
        if (fieldProps.format.indexOf('#') > -1) {
          newCompObj.transformRawValue = function(value) {
            var formarReg, index, newValue;
            formarReg = /([#]+)([^#]+)?/g;
            index = 0;
            newValue = this.format.replace(formarReg, function(word, g1, g2) {
              var result;
              result = value.substring(index, index + g1.length);
              if (g2) {
                result = result + g2;
                index += g1.length;
              }
              return result;
            });
            return newValue;
          };
        }
      }
    },
    citirisktextinput: function(newCompObj, fieldProps) {
      if (fieldProps.masked) {
        newCompObj.inputType = 'password';
      }
      if (fieldProps.emptyText) {
        newCompObj.emptyText = fieldProps.emptyText;
      }
    },
    number: function(newCompObj, fieldProps) {
      var spinnerSpec;
      newCompObj.hideTrigger = false;
      newCompObj.keyNavEnabled = false;
      newCompObj.mouseWheelEnabled = false;
      newCompObj.format = fieldProps.format;
      newCompObj.checkChangeBuffer = 50;
      spinnerSpec = fieldProps.spinnerSpec;
      if (spinnerSpec) {
        newCompObj.step = spinnerSpec.numberStep;
        newCompObj.maxValue = spinnerSpec.upperBound;
        newCompObj.minValue = spinnerSpec.lowerBound;
      }
    },
    treepicker: function(newCompObj, fieldProps) {
      return this.addlComponentSetup.combobox(newCompObj, fieldProps);
    },
    chart: function(newCompObj, fieldProps) {
      var su;
      su = Corefw.util.Startup;
      if (su.getThemeVersion() !== 2) {
        newCompObj.fieldLabel = fieldProps.title;
      }
    },
    combobox: function(newCompObj, fieldProps) {
      var addlConfig, comboClass, config, lookupCls, name, st, su, validValues;
      su = Corefw.util.Startup;
      if (fieldProps.emptyText) {
        newCompObj.emptyText = fieldProps.emptyText;
      }
      addlConfig = {};
      config = {
        displayField: 'dispField',
        valueField: 'val'
      };
      comboClass = Corefw.view.form.field.ComboboxField;
      if (comboClass.isLookupable(fieldProps)) {
        lookupCls = 'citiriskLookup';
        addlConfig = {
          isLookup: true,
          hideTrigger: true,
          cls: newCompObj.cls ? newCompObj.cls + ' ' + lookupCls : lookupCls,
          minChars: 1
        };
      } else {
        addlConfig = {
          queryMode: 'local'
        };
        if (su.getThemeVersion() === 2) {
          addlConfig.triggerBaseCls = 'formtriggericon';
          addlConfig.triggerCls = 'combotrig';
          if (fieldProps.readOnly !== true) {
            newCompObj.fieldStyle = {
              borderRightWidth: '0px'
            };
          }
        }
      }
      addlConfig.multiSelect = fieldProps.multiSelect;
      addlConfig.autoSelect = !fieldProps.multiSelect;
      addlConfig.editable = comboClass.isEditable(fieldProps);
      addlConfig.typeAhead = addlConfig.editable;
      name = fieldProps.uipath;
      validValues = fieldProps.validValues;
      if (!validValues.length) {
        if (fieldProps.hasOwnProperty('displayValue')) {
          validValues = validValues.concat({
            displayValue: fieldProps.displayValue,
            value: fieldProps.value
          });
        } else {
          validValues = validValues.concat(fieldProps.value);
        }
      }
      st = Corefw.util.Data.arrayToStore(name, null, validValues, config);
      if (st) {
        config.store = st;
      }
      Ext.apply(config, addlConfig);
      Ext.apply(newCompObj, config);
    },
    advanced_combobox: function(newCompObj, fieldProps) {
      return this.addlComponentSetup.combobox(newCompObj, fieldProps);
    },
    radiogroup: function(newCompObj, fieldProps) {
      var addlConfig, cm, groupValue, itemConfig, itemConfigDef, items, radioValue, su, _i, _len, _ref;
      cm = Corefw.util.Common;
      su = Corefw.util.Startup;
      items = [];
      addlConfig = {
        defaultType: 'radiofield',
        items: items
      };
      newCompObj.columns = fieldProps.columns;
      newCompObj.vertical = fieldProps.vertical;
      itemConfigDef = {
        name: fieldProps.name
      };
      if (su.getThemeVersion() === 2) {
        itemConfigDef.checkedCls = 'radiogroupcls';
      }
      groupValue = cm.getValue(fieldProps.value);
      if (fieldProps.validValues) {
        _ref = fieldProps.validValues;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          radioValue = _ref[_i];
          itemConfig = cm.objectClone(itemConfigDef);
          itemConfig.boxLabel = cm.getDisplayValue(radioValue);
          itemConfig.inputValue = cm.getValue(radioValue);
          itemConfig.checked = itemConfig.inputValue === groupValue;
          if (!Ext.Object.isEmpty(fieldProps.disabledValidValues) && Ext.Array.contains(fieldProps.disabledValidValues, itemConfig.inputValue)) {
            itemConfig.disabled = true;
          } else {
            itemConfig.disabled = false;
          }
          items.push(itemConfig);
        }
      }
      Ext.apply(newCompObj, addlConfig);
    },
    switchbutton: function(newCompObj, fieldProps) {
      var addlConfig, cm, groupValue, itemConfig, itemConfigDef, items, radioValue, su, _i, _len, _ref;
      cm = Corefw.util.Common;
      su = Corefw.util.Startup;
      items = [];
      addlConfig = {
        layout: 'hbox',
        defaultType: 'button',
        items: items
      };
      if (su.getThemeVersion() !== 2) {
        addlConfig.defaults = {
          flex: 1
        };
      }
      itemConfigDef = {
        name: fieldProps.name
      };
      groupValue = cm.getValue(fieldProps.value);
      if (fieldProps.validValues) {
        _ref = fieldProps.validValues;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          radioValue = _ref[_i];
          itemConfig = cm.objectClone(itemConfigDef);
          itemConfig.text = cm.getDisplayValue(radioValue);
          itemConfig.inputValue = cm.getValue(radioValue);
          itemConfig.pressed = itemConfig.inputValue === groupValue;
          items.push(itemConfig);
        }
      }
      Ext.apply(newCompObj, addlConfig);
    },
    checkgroup: function(newCompObj, fieldProps) {
      var checkItem, cm, groupValue, itemConfig, itemConfigDef, items, su, _i, _len, _ref;
      cm = Corefw.util.Common;
      items = [];
      su = Corefw.util.Startup;
      newCompObj.items = items;
      delete newCompObj.name;
      newCompObj.columns = fieldProps.columns;
      newCompObj.vertical = fieldProps.vertical;
      itemConfigDef = {
        name: fieldProps.name,
        xtype: 'checkboxfield'
      };
      if (su.getThemeVersion() === 2) {
        itemConfigDef.checkedCls = 'checkboxfieldcls';
      }
      groupValue = cm.getValue(fieldProps.value);
      if (!Ext.isArray(groupValue)) {
        groupValue = [groupValue];
      }
      if (fieldProps.validValues) {
        _ref = fieldProps.validValues;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          checkItem = _ref[_i];
          itemConfig = cm.objectClone(itemConfigDef);
          itemConfig.boxLabel = cm.getDisplayValue(checkItem);
          itemConfig.inputValue = cm.getValue(checkItem);
          itemConfig.checked = Ext.Array.contains(groupValue, itemConfig.inputValue);
          if (!Ext.Object.isEmpty(fieldProps.disabledValidValues) && Ext.Array.contains(fieldProps.disabledValidValues, itemConfig.inputValue)) {
            itemConfig.disabled = true;
          } else {
            itemConfig.disabled = false;
          }
          items.push(itemConfig);
        }
      }
    },
    checkbox: function(newCompObj, fieldProps) {
      var su;
      su = Corefw.util.Startup;
      if (su.getThemeVersion() === 2) {
        newCompObj.checkedCls = 'checkboxcls';
      }
    }
  },
  configureValidation: function(props, fieldObj) {
    var message, name, pattern, redend, su, validations, validtn, validtnXtypes, _i, _len, _ref, _ref1, _ref2;
    validations = props.validations;
    if (!validations) {
      validations = props.feValidations;
      if (!validations) {
        return;
      }
    }
    validtnXtypes = ['citirisktextinput', 'textfield', 'textareafield', 'corenumberfield', 'combobox', 'comboboxfield', 'citiriskdatepicker', 'coretreepickernew', 'coredatefield', 'coredatestringfield'];
    su = Corefw.util.Startup;
    if (validations && validations.length) {
      for (_i = 0, _len = validations.length; _i < _len; _i++) {
        validtn = validations[_i];
        name = validtn.constraintName;
        message = validtn.constraintMessage;
        if (!name) {
          name = validtn.name;
          message = validtn.message;
        }
        switch (name) {
          case 'FieldNotNull':
            if (_ref = fieldObj.xtype, __indexOf.call(validtnXtypes, _ref) >= 0) {
              redend = '&nbsp;*';
              if (su.getThemeVersion() === 2) {
                fieldObj.fieldLabel = fieldObj.fieldLabel;
                fieldObj.labelClsExtra = 'mandatoryLabel';
                redend = '';
              }
              if (!Ext.String.endsWith(fieldObj.fieldLabel, redend)) {
                fieldObj.fieldLabel = fieldObj.fieldLabel + redend;
              }
              fieldObj.allowBlank = false;
              fieldObj.blankText = message ? message + '\n<br>' : 'Field can not be blank';
            }
            break;
          case 'FieldRegex':
            if (_ref1 = fieldObj.xtype, __indexOf.call(validtnXtypes, _ref1) >= 0) {
              pattern = validtn != null ? (_ref2 = validtn.constraintMap) != null ? _ref2.pattern : void 0 : void 0;
              if (!pattern) {
                continue;
              }
              fieldObj.regex = new RegExp(pattern);
              fieldObj.regexText = message ? message + '\n<br>' : 'Field failed validation';
            }
        }
      }
    }
  },
  getFieldStyle: function(props) {
    var bgcolor, fieldStyle, getBgColor, style, temp, typeReg;
    style = props.style;
    getBgColor = function(bg) {
      var bgcolor, colorMap;
      colorMap = {
        'HIGHLIGHT': '#f6efcc'
      };
      bgcolor = colorMap[bg];
      if (bgcolor) {
        return bgcolor;
      } else {
        return bg;
      }
    };
    fieldStyle = '';
    if (style.fontStyle !== 'NORMAL') {
      fieldStyle = "" + fieldStyle + " font-style:" + (style.fontStyle.toLowerCase()) + ";";
    }
    if (style.fontWeight !== 'NORMAL') {
      fieldStyle = "" + fieldStyle + " font-weight:" + (style.fontWeight.toLowerCase()) + ";";
    }
    if (style.textDecoration !== 'NONE') {
      temp = style.textDecoration.toLowerCase();
      if (temp === 'linethrough') {
        temp = 'line-through';
      }
      fieldStyle = "" + fieldStyle + " text-decoration:" + temp + ";";
    }
    if (style.cursor !== 'DEFAULT') {
      fieldStyle = "" + fieldStyle + " cursor:" + (style.cursor.toLowerCase()) + ";";
    }
    if (style.bgcolor) {
      bgcolor = getBgColor(style.bgcolor);
      typeReg = /(combobox)|(checkbox)/i;
      if (typeReg.test(props.type)) {
        fieldStyle = "" + fieldStyle + " background-color: " + bgcolor + ";";
      } else {
        fieldStyle = "" + fieldStyle + " background-image:none; background-color: " + bgcolor + ";";
      }
    }
    fieldStyle = "" + fieldStyle + " color:#" + style.hexColor + ";";
    return fieldStyle;
  },
  generatePostData: function() {
    var cache, comp, field, fieldObj, fieldProps, fields, key, postData, props, uip, uipath, val;
    uip = Corefw.util.Uipath;
    cache = this.cache;
    props = cache._myProperties;
    fields = [];
    postData = {
      name: props.name,
      allContents: fields
    };
    for (key in cache) {
      field = cache[key];
      if (key !== '_myProperties') {
        fieldObj = null;
        fieldProps = field._myProperties;
        uipath = fieldProps.uipath;
        comp = uip.uipathToComponent(uipath);
        if (!comp) {
          continue;
        }
        if (comp.generatePostData) {
          fieldObj = comp.generatePostData();
        } else {
          val = comp.getValue && comp.getValue();
          if (val === void 0) {
            continue;
          }
          fieldObj = {
            name: key,
            value: val
          };
        }
        if (fieldObj) {
          fields.push(fieldObj);
        }
      }
    }
    return postData;
  },
  inheritableStatics: {
    createDataCache: function(dataItem, cache) {
      cache._myProperties.data = {};
    }
  }
});
