// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.mixin.Perspective', {
  statics: {
    configView: (function() {
      var getLayoutType, layoutDef, _configView;
      layoutDef = {
        HBOX: {
          layout: {
            type: 'hbox',
            align: 'stretch'
          }
        },
        VBOX: {
          layout: {
            type: 'vbox',
            align: 'stretch'
          }
        }
      };
      getLayoutType = function(viewCache) {
        var layoutDefObj, layoutProps, layoutType, _ref;
        layoutProps = viewCache != null ? (_ref = viewCache._myProperties) != null ? _ref.layout : void 0 : void 0;
        layoutType = layoutProps != null ? layoutProps.type : void 0;
        layoutDefObj = layoutDef[layoutType];
        if (!layoutType || layoutType === 'DEFAULT' || !layoutDefObj || (layoutType === 'VBOX' && !layoutProps.hasFlex)) {
          return 'stacked';
        }
      };
      _configView = function(viewCache) {
        var layoutType, newview, viewXtype, _ref;
        layoutType = getLayoutType(viewCache);
        switch (layoutType) {
          case 'stacked':
            viewXtype = 'coreviewstacked';
        }
        newview = {
          xtype: viewXtype,
          cache: viewCache
        };
        if ((viewCache != null ? (_ref = viewCache._myProperties) != null ? _ref.type : void 0 : void 0) === 'PIVOT') {
          newview.xtype = 'coreviewpivot';
          newview.title = viewCache._myProperties.title;
          newview.closable = viewCache._myProperties.closable;
        }
        return newview;
      };
      return _configView;
    })()
  },
  addOneView: function(viewCache, insertFlag, insertIndex) {
    var childview, comp, newview, props;
    props = viewCache._myProperties;
    if (props.subnavigator) {
      return;
    }
    newview = Corefw.mixin.Perspective.configView(viewCache);
    if (this.cache._myProperties.hasSubnavViews) {
      childview = newview;
      childview.cache._myProperties.hasSubnav = true;
      newview = {
        xtype: 'coreviewsubnav',
        cache: viewCache,
        title: props.title,
        items: [
          {
            xtype: childview.xtype,
            cache: childview.cache,
            region: 'center'
          }
        ]
      };
    }
    if (!props.title) {
      this.hideTabBar = true;
    }
    if (insertFlag && insertIndex >= 0) {
      comp = this.insert(insertIndex, newview);
    } else {
      comp = this.add(newview);
    }
    if (comp.tab) {
      comp.tab.coreview = comp;
    }
    return comp;
  },
  addToolbarNew: function(toolbarCache, attachTop) {
    var dockedTopItem, dockedTopItems, index, props, rdr, su, toolbar, _ref, _ref1;
    rdr = Corefw.util.Render;
    props = toolbarCache._myProperties;
    su = Corefw.util.Startup;
    toolbar = {};
    if (((_ref = props.layout) != null ? _ref.type : void 0) === 'TABLE') {
      toolbar = this.configComplexToolbar(toolbarCache);
    } else {
      toolbar = this.configSimpleToolbar(toolbarCache);
    }
    if (su.getThemeVersion()) {
      toolbar.border = '0px';
    }
    toolbar.uipath = props.uipath;
    if (props.cssClass) {
      toolbar.cls = props.cssClass;
    }
    this.toolbarObj = toolbar;
    if (attachTop) {
      rdr.attachToolbarToTopTabpanel(this);
    } else {
      if ((_ref1 = this.up()) != null) {
        if (typeof _ref1.hideAllTopToolbars === "function") {
          _ref1.hideAllTopToolbars();
        }
      }
      dockedTopItems = this.getDockedItems("toolbar[dock='top'],panel[dock='top']");
      for (index in dockedTopItems) {
        dockedTopItem = dockedTopItems[index];
        this.removeDocked(dockedTopItem);
      }
      this.addDocked(toolbar);
    }
    return toolbar;
  },
  configComplexToolbar: function(toolbarCache) {
    var toolbar;
    toolbar = {
      xtype: 'corecomplextoolbar',
      dock: 'top',
      padding: 3,
      border: '1 1 1 1',
      cache: toolbarCache
    };
    return toolbar;
  },
  configSimpleToolbar: function(toolbarCache) {
    var toolbar;
    toolbar = {
      xtype: 'coretoolbar',
      ui: 'commandbar',
      dock: 'top',
      padding: '3px 3px 3px 10px',
      border: '1 1 1 1',
      cache: toolbarCache
    };
    return toolbar;
  },
  updateUIData: function(perspectiveCache) {
    var cm, contentCache, contentProps, coretype, currentActiveTab, evt, isTabBarHidden, key, newTooltip, oldTooltip, previousActiveTab, props, rd, _ref, _ref1, _ref2, _ref3, _ref4;
    cm = Corefw.util.Common;
    rd = Corefw.util.Render;
    props = perspectiveCache._myProperties;
    cm.updateCommon(this, props);
    oldTooltip = (_ref = this.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.toolTip : void 0 : void 0;
    newTooltip = props.toolTip;
    if (oldTooltip !== newTooltip) {
      if ((_ref2 = this.tab) != null) {
        _ref2.setTooltip(newTooltip);
      }
    }
    if (this.tab) {
      rd.loadErrors(this.tab, props);
    }
    isTabBarHidden = false;
    this.cache = perspectiveCache;
    previousActiveTab = this.selectedActiveTab;
    evt = Corefw.util.Event;
    if (this.perspectiveONREFRESHevent && this.rendered) {
      evt.fireRenderEvent(this);
    }
    for (key in perspectiveCache) {
      contentCache = perspectiveCache[key];
      if (key === "_myProperties") {
        continue;
      }
      contentProps = contentCache._myProperties;
      coretype = contentProps != null ? (_ref3 = contentProps.coretype) != null ? _ref3.toLowerCase() : void 0 : void 0;
      switch (coretype) {
        case 'view':
          if (contentProps.subnavigator) {
            props.hasSubnavViews = true;
          }
          if (!contentProps.popup) {
            this.updateChild(contentCache);
            if (contentProps.visible && !contentProps.title) {
              isTabBarHidden = true;
            }
          }
          break;
        case 'toolbar':
          this.updateToolbar(contentCache);
      }
    }
    if (typeof this.createOrUpdateProgressIndicator === "function") {
      this.createOrUpdateProgressIndicator();
    }
    if (!(this instanceof Corefw.view.PerspectiveWorkflow) && ((_ref4 = this.tabBar) != null ? typeof _ref4.isHidden === "function" ? _ref4.isHidden() : void 0 : void 0) && !isTabBarHidden) {
      this.tabBar.setVisible(true);
    }
    currentActiveTab = this.selectedActiveTab;
    if (previousActiveTab !== currentActiveTab) {
      this.setActiveTab(currentActiveTab);
    }
  },
  updateToolbar: function(toolbarCache) {
    var toolbarComp, toolbarObj, toolbarUIPath, toptabPanel, _ref;
    toolbarObj = this.toolbarObj;
    if (!toolbarObj) {
      this.addToolbar(toolbarCache);
    } else {
      toolbarUIPath = toolbarObj.uipath;
      toolbarComp = this.down("[uipath=" + toolbarUIPath + "]");
      if (!toolbarComp) {
        toptabPanel = this.up('toptabpanel');
        toolbarComp = (_ref = toptabPanel.topToolbars) != null ? _ref[toolbarUIPath] : void 0;
      }
      toolbarComp.updateUIData(toolbarCache);
      this.toolbarObj.cache = toolbarCache;
    }
    toptabPanel = this.up('toptabpanel');
    if ((toptabPanel != null ? toptabPanel.activeTab : void 0) === this) {
      this.startTimerAndHeartBeats();
    }
  },
  updateChild: function(viewCache) {
    this.replaceChild(viewCache, '', '', true);
  },
  replaceChild: function(viewCache, ev, disablePageSwitch, isAncestorUpdating) {
    var borderParent, childview, cm, delVariable, hasSubnav, me, name, newview, origTabNumber, props, uip, uipath, viewComp, _ref, _ref1;
    uip = Corefw.util.Uipath;
    cm = Corefw.util.Common;
    props = viewCache._myProperties;
    name = props.name;
    uipath = props.uipath;
    me = this;
    origTabNumber = uip.uipathToTabNumber(uipath);
    if (origTabNumber === -1 && this.cache[name]) {
      origTabNumber = this.getViewOrderFromCache(name);
    }
    this.cache[name] = viewCache;
    if (props.popup) {
      this.createPopupview(viewCache, ev, props);
      return;
    }
    viewComp = uip.uipathToComponent(uipath);
    if (!isAncestorUpdating) {
      if (typeof me.createOrUpdateProgressIndicator === "function") {
        me.createOrUpdateProgressIndicator();
      }
      Ext.suspendLayouts();
    }
    if (props.isRemovedFromUI || !props.visible) {
      if (viewComp) {
        this.removingChild = true;
        this.remove(viewComp);
        delete this.removingChild;
      }
      if (!isAncestorUpdating) {
        Ext.resumeLayouts(true);
      }
      return;
    }
    if (viewComp) {
      if (typeof viewComp.disableOncloseEvents === "function") {
        viewComp.disableOncloseEvents();
      }
      hasSubnav = viewComp != null ? (_ref = viewComp.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.hasSubnav : void 0 : void 0 : void 0;
      if (hasSubnav) {
        borderParent = viewComp.up('coreviewsubnav');
        if (borderParent.contains(viewComp)) {
          borderParent.remove(viewComp);
        }
        childview = Corefw.mixin.Perspective.configView(viewCache);
        childview.cache._myProperties.hasSubnav = true;
        newview = {
          xtype: childview.xtype,
          cache: childview.cache,
          region: 'center'
        };
        borderParent.add(newview);
        if (!isAncestorUpdating) {
          Ext.resumeLayouts(true);
        }
        return;
      }
      viewComp.updateUIData(viewCache);
      if (props.active) {
        this.selectedActiveTab = viewComp;
      }
      if (!viewComp.rendered) {
        if (!props.popup && !disablePageSwitch && !hasSubnav && props.respIndex === 0) {
          uip.uipathActivateTab(uipath);
        }
        if (!isAncestorUpdating) {
          Ext.resumeLayouts(true);
        }
        return;
      }
      delVariable = Ext.Function.createDelayed(function() {
        return Corefw.util.InternalVar.deleteUipathProperty(uipath, 'suppressClosing', 1);
      });
      delVariable();
    } else {
      viewComp = this.addOneView(viewCache, true, origTabNumber);
      if (props.active) {
        this.selectedActiveTab = viewComp;
      }
    }
    if (!props.popup) {
      if (!disablePageSwitch && !hasSubnav && props.respIndex === 0) {
        uip.uipathActivateTab(uipath);
      }
    }
    if (!isAncestorUpdating) {
      Ext.resumeLayouts(true);
    }
  },
  getViewOrderFromCache: function(viewName2Find) {
    var pCache, viewName, viewOrder, viewProps;
    viewOrder = -1;
    pCache = this.cache;
    for (viewName in pCache) {
      viewProps = pCache[viewName];
      if (viewName !== '_myProperties') {
        viewOrder++;
      }
      if (viewName === viewName2Find) {
        return viewOrder;
      }
    }
    return -1;
  },
  createPopupview: function(viewCache, ev, props) {
    var config, persUipath, perspectiveWindow, view, win;
    persUipath = props.uipath + 'PerspectiveWindow';
    config = {
      cache: viewCache,
      title: props.title.toUpperCase(),
      uipath: persUipath,
      coretype: 'perspective'
    };
    if (props.position === 'ON_MOUSE' && ev) {
      config.x = ev.getX();
      config.y = ev.getY();
    }
    if (props.height && (Ext.getBody().getHeight() < props.height)) {
      config.y = 0;
    }
    win = Ext.ComponentQuery.query("coreperspectivewindow[uipath=" + persUipath + "]")[0];
    if (win) {
      view = win.down('coreviewstacked');
      view && view.disableOncloseEvents();
      win.destroy();
    }
    if (props.closed === true || props.visible === false) {
      return;
    }
    perspectiveWindow = Ext.create('Corefw.view.PerspectiveWindow', config);
    perspectiveWindow.addOneView(viewCache);
    view = perspectiveWindow.down('coreviewstacked');
    view && view.enableOncloseEvents();
    if (props.position === 'SCREEN_CENTER' && config.y !== 0) {
      perspectiveWindow.center();
    }
  },
  hasSubnavViews: function() {
    var cache, key, view;
    cache = this.cache;
    for (key in cache) {
      view = cache[key];
      if (key === '_myProperties') {
        continue;
      }
      if (view._myProperties.subnavigator) {
        return true;
      }
    }
    return false;
  },
  addFakeViewAfter: function(currView) {
    var currTabNumber, fakeObj, fakeview;
    currTabNumber = this.items.indexOf(currView);
    fakeview = {
      xtype: 'panel',
      tabConfig: {
        hidden: true
      }
    };
    fakeObj = this.insert(currTabNumber, fakeview);
    this.setActiveTab(fakeObj);
    return fakeObj;
  },
  disableOncloseEvents: function() {
    var iv;
    iv = Corefw.util.InternalVar;
    iv.setByUipathProperty(this.uipath, 'suppressClosing', true);
  },
  isOncloseEventDisabled: function() {
    var iv, suppressClosing;
    iv = Corefw.util.InternalVar;
    suppressClosing = iv.getByUipathProperty(this.uipath, 'suppressClosing');
    return suppressClosing;
  },
  onPerspectiveDestroy: function() {
    var rdr;
    rdr = Corefw.util.Render;
    rdr.destroyThisComponent(this);
  },
  startTimerAndHeartBeats: function() {
    this.updateTimerNavs();
    if (window.isActive) {
      this.startAllHeartBeats();
    }
  },
  onPerspectiveActive: function() {
    this.startTimerAndHeartBeats();
  },
  updateTimerNavs: function() {
    var allTimerNavs, me, rdr, timerNav, _i, _len;
    allTimerNavs = this.findAllTimerNavs();
    me = this;
    rdr = Corefw.util.Render;
    for (_i = 0, _len = allTimerNavs.length; _i < _len; _i++) {
      timerNav = allTimerNavs[_i];
      if (timerNav.interval > 0 && timerNav.events['ONTIMER']) {
        rdr.startTask(timerNav, me);
      }
    }
  },
  startAllHeartBeats: function() {
    var hb, heartBeats, _i, _len;
    heartBeats = this.cache._myProperties.heartBeats;
    if (heartBeats) {
      for (_i = 0, _len = heartBeats.length; _i < _len; _i++) {
        hb = heartBeats[_i];
        this.startHeartBeat(hb);
      }
    }
  },
  startHeartBeat: function(heartBeat) {
    var iv, props, runner, startHB, task;
    iv = Corefw.util.InternalVar;
    props = this.cache._myProperties;
    runner = iv.getTaskByUipath(props.uipath, heartBeat.name);
    if (!runner) {
      runner = iv.addTaskByUipath(props.uipath, heartBeat.name);
    }
    task = runner.tasks[0];
    if (!task) {
      if (heartBeat.url && heartBeat.url !== "") {
        startHB = function() {
          Ext.Ajax.request({
            url: heartBeat.url
          });
          console.log("-------------- start heart beat!!!", heartBeat.name);
        };
        return task = runner.start({
          run: startHB,
          interval: heartBeat.interval
        });
      }
    } else {
      if (task.stopped) {
        return Ext.TaskManager.start(task);
      }
    }
  },
  onPerspectiveDeactive: function() {
    this.stopAllHeartBeats();
  },
  findAllTimerNavs: function() {
    var allTimerNavs, nav, navsAr, toolbarObj, _i, _len, _ref, _ref1, _ref2;
    allTimerNavs = [];
    toolbarObj = this.toolbarObj;
    navsAr = toolbarObj != null ? (_ref = toolbarObj.cache) != null ? (_ref1 = _ref._myProperties) != null ? (_ref2 = _ref1.navs) != null ? _ref2._ar : void 0 : void 0 : void 0 : void 0;
    if (navsAr && navsAr.length) {
      for (_i = 0, _len = navsAr.length; _i < _len; _i++) {
        nav = navsAr[_i];
        if ((nav.started != null) && (nav.interval != null)) {
          allTimerNavs.push(nav);
        }
      }
    }
    return allTimerNavs;
  },
  stopAllHeartBeats: function() {
    var hb, heartBeats, _i, _len;
    heartBeats = this.cache._myProperties.heartBeats;
    if (heartBeats) {
      for (_i = 0, _len = heartBeats.length; _i < _len; _i++) {
        hb = heartBeats[_i];
        this.stopHeartBeat(hb);
      }
    }
  },
  stopHeartBeat: function(heartBeat) {
    var iv, runner;
    iv = Corefw.util.InternalVar;
    runner = iv.getTaskByUipath(this.cache._myProperties.uipath, heartBeat.name);
    if (runner && runner.tasks.length && !runner.tasks[0].stopped) {
      Ext.TaskManager.stop(runner.tasks[0]);
      console.log("-------------STOP heart beat", heartBeat.name);
    }
  }
});
