// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.mixin.Grid', {
  defaultRowHeight: 22,
  constructor: function() {},
  configureBufferedRenderPlugin: function() {
    var bp, bpConfig;
    bpConfig = {
      pluginId: 'corebufferedplugin',
      trailingBufferZone: 10,
      leadingBufferZone: 20
    };
    bp = Ext.create('Corefw.view.grid.BufferedRenderer', bpConfig);
    if (this.plugins) {
      this.plugins.push(bp);
    } else {
      this.plugins = [bp];
    }
  },
  configureBufferedSelPlugin: function() {
    var bs, bsConfig;
    bsConfig = {
      pluginId: 'corebufferedselplugin'
    };
    bs = Ext.create('Corefw.view.grid.plugin.BufferedSelect', bsConfig);
    if (this.plugins) {
      this.plugins.push(bs);
    } else {
      this.plugins = [bs];
    }
  },
  configureEditPlugin: function() {
    var rowEditingConfig, rowedit;
    rowEditingConfig = {
      clicksToEdit: 2
    };
    rowedit = Ext.create('Corefw.view.grid.RowEditing', rowEditingConfig);
    this.rowEditor = rowedit;
    if (this.plugins) {
      this.plugins.push(rowedit);
    } else {
      this.plugins = [rowedit];
    }
  },
  configureDragAndDropPlugins: function(props, isGrid) {
    var dropToUipath, generateDragDropPostData, isDraggable, isDroppable, listeners, pluginConfig, plugins, ptype, recievablePaths, rq, viewConfig, _ref;
    rq = Corefw.util.Request;
    generateDragDropPostData = this.generateDragDropPostData;
    ptype = isGrid ? 'coregridviewdragdrop' : 'coretreeviewdragdrop';
    isDraggable = props.draggable || false;
    recievablePaths = props.recievablePaths || [];
    isDroppable = recievablePaths.length > 0;
    dropToUipath = props.uipath;
    plugins = (_ref = this.viewConfig) != null ? _ref.plugins : void 0;
    if (!isDraggable && !isDroppable) {
      return;
    }
    pluginConfig = {
      ptype: ptype,
      enableDrag: isDraggable
    };
    listeners = {
      beforeDrop: function(node, data) {
        var dragFromView;
        dragFromView = data.view;
        if (dragFromView === this) {
          data.copy = false;
        } else {
          data.copy = true;
        }
        return true;
      },
      drop: function(node, data) {
        var container, dragFromUipath, dragFromView, droppedTarget, postData, url, _ref1;
        dragFromView = data.view;
        container = this.up('fieldcontainer');
        if (dragFromView === this) {
          url = container.eventURLs['ONROWSTATECHANGE'];
          if (!url) {
            return;
          }
          postData = container.generatePostData();
          if (isGrid) {
            postData.items.forEach(function(item, index) {
              item.index = index;
              return item.changed = true;
            });
          }
          url = rq.objsToUrl3(url);
          rq.sendRequest5(url, rq.processResponseObject, dropToUipath, postData, 'The drag and drop request is failed', 'POST');
          return;
        }
        droppedTarget = container.grid || container.tree;
        droppedTarget.getStore().remove(data.records);
        dragFromView.getSelectionModel().select(+data.item.dataset.recordindex);
        dragFromUipath = (_ref1 = dragFromView.up('fieldcontainer')) != null ? _ref1.cache._myProperties.uipath : void 0;
        if (!dragFromUipath) {
          return;
        }
        postData = generateDragDropPostData(dragFromView, this, dragFromUipath);
        url = dropToUipath + '/ONDND/' + dragFromUipath;
        url = rq.objsToUrl3(url);
        rq.sendRequest5(url, rq.processResponseObject, dropToUipath, postData, 'The drag and drop request is failed', 'POST');
      }
    };
    viewConfig = {
      _uipath: props.uipath,
      copy: true,
      plugins: [pluginConfig],
      listeners: listeners
    };
    if (plugins) {
      plugins.push(pluginConfig);
      Ext.merge(this.viewConfig.listeners, listeners);
    } else {
      this.viewConfig = viewConfig;
    }
  },
  generateDragDropPostData: function(dragFromComp, dropToComp, dragFromUipath) {
    var dragFromPostData, dropToPostData;
    dragFromPostData = dragFromComp.up('fieldcontainer').generatePostData();
    dropToPostData = dropToComp.up('fieldcontainer').generatePostData();
    dropToPostData.from = dragFromPostData;
    dropToPostData.from.uipath = dragFromUipath;
    return dropToPostData;
  },
  configurePlugins: function(props, isGrid) {
    props.infinity && this.configureBufferedRenderPlugin();
    props.buffered && this.configureBufferedSelPlugin();
    props.editableColumns && this.configureEditPlugin();
    this.configureDragAndDropPlugins(props, isGrid);
  },
  defaultDef: {
    lockable: false
  },
  createColumnsFromCache: function(itemsArray) {
    var cache, colCache, colProps, columnsAlreadyExist, grid, index, itemNew, key, newColumnObj, props;
    cache = this.cache;
    grid = this;
    props = cache._myProperties;
    itemNew = [];
    if (itemsArray.length) {
      columnsAlreadyExist = true;
    }
    if ((props != null ? props.supportAutoNumber : void 0) && !columnsAlreadyExist) {
      itemsArray.push({
        xtype: 'rownumberer',
        resizable: true,
        width: 60
      });
    }
    index = 0;
    this.columnGroups = {};
    for (key in cache) {
      colCache = cache[key];
      colProps = colCache._myProperties;
      if (key !== '_myProperties' && !(colProps != null ? colProps.isRemovedFromUI : void 0)) {
        if (columnsAlreadyExist) {
          newColumnObj = this.configureOneColumn(colCache, cache, index, itemsArray[index]);
          if (colCache._myProperties.group && colCache._myProperties.group.groupName) {
            this.addToColumnGroup(colCache._myProperties, newColumnObj, itemNew);
          } else {
            itemNew.push(newColumnObj);
          }
        } else {
          newColumnObj = this.configureOneColumn(colCache, cache, index);
          this.addColumn(colCache, newColumnObj, itemsArray);
        }
        if (newColumnObj.hidden) {
          newColumnObj.getEditor = function(c, h) {
            return grid.rowEditor.getColumnField(this, h);
          };
        }
        index++;
      }
    }
    delete this.columnGroups;
    if (itemNew.length) {
      this.columns = itemNew;
      this.setGroupLocked(itemNew);
    } else {
      this.setGroupLocked(itemsArray);
    }
    this.hideGroupColumn(itemNew.length > 0 ? itemNew : itemsArray);
  },
  hideGroupColumn: function(columns) {
    var column, i, subColumn, subColumns, _i, _j, _len, _len1;
    for (_i = 0, _len = columns.length; _i < _len; _i++) {
      column = columns[_i];
      subColumns = column.columns;
      if (subColumns) {
        i = 0;
        for (_j = 0, _len1 = subColumns.length; _j < _len1; _j++) {
          subColumn = subColumns[_j];
          if (subColumn.hidden) {
            i++;
          }
        }
        if (i === subColumns.length) {
          column.hidden = true;
        }
      }
    }
  },
  addToColumnGroup: function(props, newColumnObj, itemsArray) {
    var gridmenu, group, groupColumnArray, groupHeaderObj, groupKey, groupName;
    group = props.group;
    groupName = group.groupName;
    groupKey = groupName + (group.groupID || '');
    groupColumnArray = this.columnGroups[groupKey];
    gridmenu = this.cache._myProperties;
    if (!groupColumnArray) {
      groupColumnArray = [];
      this.columnGroups[groupKey] = groupColumnArray;
      groupHeaderObj = {
        text: groupName,
        columns: groupColumnArray
      };
      if (gridmenu.hideGridHeaderMenus) {
        groupHeaderObj.menuDisabled = true;
      }
      itemsArray.push(groupHeaderObj);
    }
    Ext.apply(newColumnObj, this.defaultDef);
    groupColumnArray.push(newColumnObj);
  },
  configureOneColumn: function(colCache, gridCache, colIndex, existingColumnObj) {
    var cm, colType, colXtype, columnType, config, definedWidth, evt, grid, gridProps, headerLines, maxWidth, minWidth, newColumnObj, props, protocolMap, su, textAlign, tip, typeToXtypes;
    grid = this;
    evt = Corefw.util.Event;
    cm = Corefw.util.Common;
    su = Corefw.util.Startup;
    props = colCache._myProperties;
    gridProps = gridCache._myProperties;
    colType = props.columnType ? props.columnType : props.type;
    columnType = colType != null ? colType.toLowerCase() : void 0;
    if (!props.columnType && columnType) {
      props.columnType = columnType;
    }
    if (existingColumnObj) {
      newColumnObj = existingColumnObj;
      newColumnObj.cache = colCache;
    } else {
      newColumnObj = {
        cache: colCache
      };
    }
    newColumnObj.toggleSortState = function() {
      var column;
      column = this;
      return grid.toggleColumnSortState(column);
    };
    minWidth = props.minWidth || 30;
    maxWidth = props.maxWidth || 200;
    protocolMap = {
      TELEPHONE: 'tel:',
      MAIL: 'mailto:'
    };
    if (props.width) {
      definedWidth = props.width;
      if (definedWidth < minWidth) {
        minWidth = definedWidth;
      }
      if (definedWidth > maxWidth) {
        maxWidth = definedWidth + 100;
      }
    }
    config = {
      text: props.title,
      tooltip: props.toolTip || props.title,
      dataIndex: props.index + '',
      pathString: props.pathString,
      name: props.name,
      minWidth: minWidth,
      maxWidth: maxWidth,
      uipath: props.uipath,
      allowAutoWidth: gridProps.allowAutoWidth,
      lockable: props.lockable,
      draggable: props.draggable
    };
    textAlign = props.textAlign;
    if (textAlign) {
      config.align = textAlign.toLowerCase();
    }
    if (gridProps.hideGridHeaderMenus) {
      config.menuDisabled = true;
    }
    if (gridProps.widgetType !== 'TREE_GRID') {
      config.listeners = {
        headertriggerclick: this.onShowColumnMenu
      };
    }
    if (gridProps.headerEllipses) {
      config.cls = 'grid-header-ellipses-cls';
    } else {
      headerLines = gridProps.headerTitleRows;
      if (headerLines > 1) {
        config.cls = 'headerTitleEllipse';
      } else if (gridProps.widgetType === 'TREE_GRID') {
        config.cls = 'headerTitleEllipse';
      } else {
        config.cls = 'grid-header-no-ellipses-cls';
      }
    }
    if (props.columnType) {
      props.corecolumntype = columnType;
    }
    if (props.toolTip) {
      config.tooltip = (props.toolTip + '\n<br>').replace(/"/g, '&quot;');
      tip = Ext.getCmp('ext-quicktips-tip');
      if (tip != null) {
        tip.dismissDelay = 0;
      }
    }
    if (props.locked) {
      config.locked = true;
    }
    if (gridProps.numberOfLockedHeaders && colIndex < gridProps.numberOfLockedHeaders) {
      config.locked = true;
    } else {
      config.locked = false;
    }
    if (definedWidth) {
      config.width = definedWidth;
    } else {
      if (!config.locked) {
        config.flex = 1;
        if (!props.maxWidth) {
          delete config.maxWidth;
        }
      }
    }
    if (props.flexWidth) {
      config.flex = props.flexWidth;
      delete config.maxWidth;
    }
    if (props.hideable === false) {
      config.hideable = false;
    } else {
      config.hideable = true;
    }
    config.sortable = props.supportSort;
    if (props.sortState === 'ASC') {
      config.possibleSortStates = ['DESC', 'ASC'];
    }
    config.iconMap = props.iconMap;
    config.linkMap = props.linkMap;
    Ext.apply(newColumnObj, config);
    if (props.editable) {
      this.configureOneEditableColumn(colCache, newColumnObj, gridCache, this);
    }
    typeToXtypes = {
      textfield: {
        tdCls: 'x-align-left',
        renderer: function(value) {
          if (Ext.isObject(value)) {
            if (value.displayValue) {
              value = value.displayValue;
            } else {
              value = '';
            }
          }
          return value;
        }
      },
      checkbox: {
        xtype: 'corecheckcolumn'
      },
      grid_picker: {
        xtype: 'corecombocolumn'
      },
      datestring: {
        xtype: 'datecolumn',
        format: props.format || 'Y-m-d H:i:s',
        renderer: function(value, meta) {
          var dateFormat, valueFormat;
          dateFormat = 'Y-m-d H:i:s';
          valueFormat = props.format || 'Y-m-d H:i:s';
          if (!Ext.isDate(value)) {
            try {
              value = Ext.Date.parse(value, dateFormat);
            } catch (_error) {
              return value;
            }
          }
          return Ext.util.Format.date(value, valueFormat);
        }
      },
      combobox: {
        xtype: 'corecombocolumn',
        validValues: props.validValues,
        filterOptions: props.filterOptions
      },
      number: {
        xtype: 'numbercolumn',
        tdCls: 'x-align-right',
        renderer: function(value) {
          var d2d, denomination, denominationRegExp, divisor, format, isPercent, rawValue;
          denominationRegExp = /[0,\.#]+(K|MM|BN)?$/;
          denomination = '';
          format = props.format;
          isPercent = format.substr(format.length - 1) === '%';
          if (Ext.isNumber(value) && isPercent) {
            value = value * 100;
          }
          if (denominationRegExp.test(format)) {
            d2d = {
              K: 1000,
              MM: 1000000,
              BN: 1000000000
            };
            denomination = RegExp.$1;
            divisor = d2d[denomination];
            if (Ext.isNumber(value) && divisor) {
              value = value / divisor;
            }
          }
          if (Ext.isNumber(value)) {
            if (value < 0) {
              rawValue = -value;
              if (!Ext.isEmpty(format)) {
                return '(' + (Ext.util.Format.number(rawValue, format)) + ')';
              } else {
                return '(' + rawValue + ')';
              }
            } else {
              if (!Ext.isEmpty(format)) {
                return Ext.util.Format.number(value, format);
              } else {
                return value;
              }
            }
          } else {
            return value;
          }
        }
      },
      date: {
        xtype: 'datecolumn',
        format: props.format || 'd M Y'
      },
      datetime: {
        xtype: 'datecolumn',
        format: props.format || 'd M Y, g:i a T'
      },
      month_picker: {
        xtype: 'datecolumn',
        format: props.format || 'Y-m'
      },
      icon: {
        renderer: function(value, metaData, record, rowIndex, colIndex, store) {
          var column, iconList, iconStr, recordIndex, _i, _len;
          if (value == null) {
            value = '';
          }
          column = metaData.column;
          recordIndex = metaData.recordIndex;
          if (this.viewType === 'coretreebaseview') {
            recordIndex = store.treeStore.tree.flatten().indexOf(record) - 1;
          }
          if (props.events['ONCLICK']) {
            metaData.style = metaData.style + ';cursor:pointer';
          }
          if (column && column.iconMap) {
            iconStr = column.iconMap[recordIndex];
            if (su.getThemeVersion() === 2 && iconStr) {
              metaData.tdCls = 'iconInGrid';
              iconList = iconStr.split(' ');
              value = '';
              for (_i = 0, _len = iconList.length; _i < _len; _i++) {
                iconStr = iconList[_i];
                value = value + "<div class='icon icon-" + Corefw.util.Cache.cssclassToIcon[iconStr] + "'></div>";
              }
              return value;
            } else {
              metaData.tdCls = iconStr;
            }
          }
          if (typeof value === 'string') {
            return value.split('<br>').join(' ');
          } else {
            return value;
          }
        }
      },
      link: {
        renderer: function(value, metaData) {
          var column, emptyText, format, linkMap, pseudoProtocol, pt, recordIndex;
          format = props.format;
          pseudoProtocol = props.pseudoProtocol;
          if (!Ext.isEmpty(format)) {
            cm = Corefw.util.Common;
            value = cm.formatValueBySpecial(value, format);
          }
          if (Ext.isObject(value)) {
            if (value.displayValue) {
              value = value.displayValue;
            } else {
              value = '';
            }
          }
          column = metaData.column;
          if (column) {
            linkMap = column.linkMap;
            recordIndex = metaData.recordIndex;
            if (linkMap && linkMap[recordIndex]) {
              return value;
            }
          }
          pt = protocolMap[pseudoProtocol];
          emptyText = Ext.Object.isEmpty(value) ? '&nbsp;' : '';
          if (pt) {
            return emptyText + ("<a href='" + pt + value + "'>" + value + "</a>");
          } else {
            return emptyText + ("<a href='javascript:;'>" + value + "</a>");
          }
        }
      },
      radio: {
        renderer: function(value, metaData, record, rowIndex, colIndex, store) {
          return "<input type='radio' " + (value ? "checked=checked" : "") + " name=" + store.storeId + "/>";
        }
      },
      togglebutton: {
        renderer: function(value, metaData, record, rowIndex, colIndex, store) {
          if (value) {
            return 'Yes';
          } else {
            return 'No';
          }
        }
      }
    };
    if (gridProps.widgetType === 'RC_GRID') {
      typeToXtypes.textfield.renderer = function(value, metaData, record, rowIndex, colIndex, store) {
        var _ref, _ref1;
        return value.displayValue || ((_ref = record.raw) != null ? (_ref1 = _ref.__misc[(metaData != null ? metaData.column.dataIndex : void 0) || '']) != null ? _ref1.displayValue : void 0 : void 0) || value;
      };
    }
    colXtype = typeToXtypes[columnType];
    if (colXtype) {
      Ext.apply(newColumnObj, colXtype);
    }
    if (colXtype && colXtype.xtype === 'corecheckcolumn') {
      this.addCls('hasCheckColumn');
      if (props.supportWholeCheck === true) {
        newColumnObj.enableAllSelecting = true;
      } else {
        newColumnObj.enableAllSelecting = false;
      }
    }
    evt.addEvents(props, 'column', props);
    return newColumnObj;
  },
  toggleColumnSortState: function(column) {
    var idx, nextIdx;
    if (column.sortable) {
      idx = Ext.Array.indexOf(column.possibleSortStates, column.cache._myProperties.sortState);
      nextIdx = (idx + 1) % column.possibleSortStates.length;
      return column.setSortState(column.possibleSortStates[nextIdx]);
    }
  },
  configureOneEditableColumn: function(colCache, newColumnObj, gridCache, gridComp) {
    var colEditorXType, colName, columnType, comboClass, dt, editor, evt, format, gridProps, identify, key, lookupCls, lookupable, maxEditorHeight, newEditorHeight, props, spinnerSpec, st, storename, su, typeToEditorXtypes, val, valdtn, valdtnArray, _i, _len, _ref, _ref1;
    dt = Corefw.util.Data;
    su = Corefw.util.Startup;
    evt = Corefw.util.Event;
    props = colCache._myProperties;
    gridProps = gridCache._myProperties;
    columnType = (_ref = props.columnType || props.type) != null ? _ref.toLowerCase() : void 0;
    if (!columnType) {
      console.log('columnType not found, returning...');
      return;
    }
    typeToEditorXtypes = {
      'default': 'coretextfield',
      textfield: 'coretextfield',
      date: 'coredatefield',
      datetime: 'datefield',
      header: 'textfield',
      combobox: 'combobox',
      grid_picker: 'roweditorgridpicker',
      multicombobox: 'combobox',
      checkbox: 'checkbox',
      textarea: 'coretextarea',
      radiogroup: 'radiogroup',
      number: 'corenumberfield',
      icon: 'textfield',
      link: 'textfield',
      datestring: 'coredatestringfield',
      month_picker: 'coremonthpicker',
      togglebutton: 'coretoggleslidefield'
    };
    if (su.useClassicTheme()) {
      typeToEditorXtypes.radiogroup = 'combobox';
    }
    colEditorXType = typeToEditorXtypes[columnType];
    if (!colEditorXType) {
      console.log('editable columnType not found: ', columnType);
      return;
    }
    newColumnObj.editor = {
      xtype: colEditorXType
    };
    valdtnArray = props.validations;
    if (valdtnArray) {
      for (_i = 0, _len = valdtnArray.length; _i < _len; _i++) {
        valdtn = valdtnArray[_i];
        switch (valdtn.constraintName) {
          case 'FieldRegex':
            newColumnObj.editor.validator = function(val) {
              var reg;
              reg = eval('/' + valdtn.constraintMap.pattern + '/');
              if (reg.test(val)) {
                return true;
              }
              return valdtn.constraintMessage;
            };
            break;
          case 'FieldNotNull':
            newColumnObj.editor.emptyText = 'required';
        }
      }
    }
    comboClass = Corefw.view.form.field.ComboboxField;
    switch (colEditorXType) {
      case 'datefield':
        newColumnObj.editor.format = props.format || 'd M Y, g:i a T';
        break;
      case 'coredatefield':
      case 'dateStringField':
        if (format = props.format) {
          editor = newColumnObj.editor;
          editor.format = format;
        }
        break;
      case 'roweditorgridpicker':
        newColumnObj.editor = {
          xtype: 'roweditorgridpicker',
          cache: colCache,
          valueMap: {},
          multiSelect: props.multiSelect,
          lookupable: comboClass.isLookupable(props)
        };
        if (su.getThemeVersion() === 2) {
          newColumnObj.editor.triggerBaseCls = 'formtriggericon';
          newColumnObj.editor.triggerCls = 'editorcombotrig';
          newColumnObj.editor.height = 20;
          if (props.readOnly !== true) {
            newColumnObj.editor.fieldStyle = {
              'border-right-width': '0px'
            };
          }
        }
        break;
      case 'combobox':
        colName = gridComp.cache._myProperties.uipath;
        storename = "gridbaseregcombo" + colName + props.uipath;
        st = dt.arrayToStore(colName, storename, props.validValues, newColumnObj);
        lookupable = comboClass.isLookupable(props);
        newColumnObj.editor = {
          xtype: 'comboboxfield',
          store: st,
          displayField: 'dispField',
          valueField: 'val',
          queryMode: 'local',
          multiSelect: props.multiSelect,
          editable: comboClass.isEditable(props),
          lookupable: lookupable
        };
        if (lookupable) {
          lookupCls = 'citiriskLookup';
          Ext.apply(newColumnObj.editor, {
            hideTrigger: true,
            cls: newColumnObj.editor.cls ? newColumnObj.editor.cls + ' ' + lookupCls : lookupCls,
            historyInfo: props.historyInfo
          });
          if (su.getThemeVersion() === 2) {
            newColumnObj.editor.height = 20;
            newColumnObj.editor.fieldStyle = {
              'line-height': '12px'
            };
          }
        } else {
          if (su.getThemeVersion() === 2) {
            newColumnObj.editor.triggerBaseCls = 'formtriggericon';
            newColumnObj.editor.triggerCls = 'editorcombotrig';
            newColumnObj.editor.height = 20;
            if (props.readOnly !== true) {
              newColumnObj.editor.fieldStyle = {
                'border-right-width': '0px'
              };
            }
          }
        }
        newColumnObj.editor.typeAhead = newColumnObj.editor.editable;
        break;
      case 'textareafield':
        newEditorHeight = props.rows * 17;
        newColumnObj.editor.height = newEditorHeight;
        maxEditorHeight = gridCache._myProperties.maxEditorHeight;
        if (!maxEditorHeight || newEditorHeight > maxEditorHeight) {
          gridProps.maxEditorHeight = newEditorHeight;
        }
        break;
      case 'radiogroup':
        identify = props.path;
        newColumnObj.editor = {
          id: "" + identify + "radiogroup",
          xtype: 'radiogroup',
          items: []
        };
        _ref1 = props.validValues;
        for (key in _ref1) {
          val = _ref1[key];
          newColumnObj.editor.items.push({
            boxLabel: val,
            name: identify,
            inputValue: val
          });
        }
        break;
      case 'corenumberfield':
        editor = newColumnObj.editor;
        if (format = props.format) {
          format = format.replace(/(K|MM|BN)?$/, '');
          editor.format = format;
        }
        if (props.fieldMask) {
          editor.inputMask = props.fieldMask;
          editor.enableKeyEvents = true;
        }
        spinnerSpec = props.spinnerSpec;
        if (spinnerSpec) {
          editor.step = spinnerSpec.numberStep;
          editor.maxValue = spinnerSpec.upperBound;
          editor.minValue = spinnerSpec.lowerBound;
        }
        if (su.getThemeVersion() === 2 && props.readOnly !== true) {
          newColumnObj.editor.fieldStyle = {
            'border-right-width': '0px'
          };
        }
        break;
      case 'coretoggleslidefield':
        newColumnObj.editor.onText = 'Yes';
        newColumnObj.editor.offText = 'No';
    }
    if (newColumnObj.editor) {
      Ext.apply(newColumnObj.editor, {
        setActiveWarning: function(message) {
          var me;
          me = this;
          if (!me.warningMessage && me.inputEl) {
            me.warningMessage = Ext.create('Corefw.view.form.field.GridItemWarningMessage', {
              field: me
            });
          }
          me.warningMessage.showMessage(message);
        },
        clearMessages: function() {
          var me, warningMessage;
          me = this;
          warningMessage = me.warningMessage;
          if (!warningMessage) {
            return;
          }
          warningMessage.clearMessage();
        }
      });
      if (!props.enabled) {
        newColumnObj.editor.disabled = true;
      }
    }
    newColumnObj.editor.pathString = props.pathString;
    if (su.getThemeVersion() === 2) {
      newColumnObj.editor.overCls = 'fieldOverCls';
    }
    evt.addEvents(props, 'column', newColumnObj.editor);
  },
  setGroupLocked: function(colItemsArray) {
    var col, subcol, _i, _j, _len, _len1, _ref;
    for (_i = 0, _len = colItemsArray.length; _i < _len; _i++) {
      col = colItemsArray[_i];
      if (col.columns) {
        _ref = col.columns;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          subcol = _ref[_j];
          if (subcol.locked) {
            col.locked = true;
          }
        }
      }
    }
  },
  addColumn: function(colCache, newColumnObj, colItemsArray) {
    var props;
    props = colCache._myProperties;
    if (newColumnObj.hidden) {
      newColumnObj.visible = false;
    }
    if (props.group && props.group.groupName) {
      this.addCls('hasGroupHeaders');
      this.addToColumnGroup(props, newColumnObj, colItemsArray);
    } else {
      colItemsArray.push(newColumnObj);
    }
    if (this.configureFilters) {
      this.configureFilters(colCache, newColumnObj);
    }
  },
  configSelType: function() {
    var buffered, cache, checkOnly, props, selectType, _ref;
    cache = this.cache;
    props = cache._myProperties;
    selectType = (_ref = props.selectType) != null ? _ref.toLowerCase() : void 0;
    checkOnly = props.checkOnly;
    buffered = props.buffered;
    switch (selectType) {
      case 'multiple':
        this.selType = 'corecheckboxmodel';
        if (checkOnly) {
          this.selModel = {
            selType: 'corecheckboxmodel',
            checkOnly: true
          };
        }
        if (buffered) {
          if (this.selModel == null) {
            this.selModel = {
              selType: 'corecheckboxmodel'
            };
          }
          this.selModel.buffered = true;
        }
        break;
      case 'single':
        this.selType = 'radiomodel';
        break;
      default:
        this.selModel = {
          mode: 'MULTI'
        };
    }
  },
  reconfigMenuItems: function(menu) {
    var activeHeader, customDropdownMenuItems, dropdownMenuCache, menuColumn, menuColumnArray, menuItem, props, su, _i, _len, _ref, _ref1, _ref2;
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      menu.showSeparator = false;
      menuColumnArray = menu.items.items;
      for (_i = 0, _len = menuColumnArray.length; _i < _len; _i++) {
        menuColumn = menuColumnArray[_i];
        if (menuColumn.menu) {
          menuColumn.menu.showSeparator = false;
        }
      }
    }
    activeHeader = menu.activeHeader;
    props = (activeHeader != null ? (_ref = activeHeader.cache) != null ? _ref._myProperties : void 0 : void 0) || {};
    if (props.showColumnsMenu === false) {
      menuItem = menu.down('[text=' + activeHeader.columnsText + ']');
      menu.remove(menuItem);
    }
    customDropdownMenuItems = this.getCustomDropdownMenuItems(menu);
    this.clearCustomDropdownMenuItems(menu, customDropdownMenuItems);
    dropdownMenuCache = (activeHeader != null ? (_ref1 = activeHeader.cache) != null ? (_ref2 = _ref1._myProperties) != null ? _ref2.dropdownMenu : void 0 : void 0 : void 0) || {};
    if (dropdownMenuCache) {
      menu.uipath = dropdownMenuCache.uipath;
      this.addCustomDropdownMenuItemForActiveHeader(menu, dropdownMenuCache);
    }
  },
  getCustomDropdownMenuItems: function(menu) {
    var customDropdownMenuItems, item, menuitemArray, _i, _len;
    customDropdownMenuItems = [];
    menuitemArray = menu.items.items;
    for (_i = 0, _len = menuitemArray.length; _i < _len; _i++) {
      item = menuitemArray[_i];
      if (item.custom) {
        customDropdownMenuItems.push(item);
      }
    }
    return customDropdownMenuItems;
  },
  clearCustomDropdownMenuItems: function(menu, customDropdownMenuItems) {
    var menuItem, _i, _len;
    for (_i = 0, _len = customDropdownMenuItems.length; _i < _len; _i++) {
      menuItem = customDropdownMenuItems[_i];
      menu.remove(menuItem);
    }
  },
  addCustomDropdownMenuItemForActiveHeader: function(menu, dropdownMenuCache) {
    var items, menuArray, menuitem, _i, _j, _len, _len1, _ref, _ref1;
    menuArray = [];
    if (dropdownMenuCache.allContents) {
      _ref = dropdownMenuCache.allContents;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        menuitem = _ref[_i];
        menuArray.push(menuitem);
      }
    }
    if (dropdownMenuCache.allNavigations) {
      _ref1 = dropdownMenuCache.allNavigations;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        menuitem = _ref1[_j];
        menuArray.push(menuitem);
      }
    }
    items = [];
    if (menuArray && menuArray.length) {
      this.createMenuItemsWorker(menuArray, items);
    }
    menu.add(items);
  },
  createMenuItemsWorker: function(menuArray, menuParent) {
    var evt, menuItemCache, menuitem, newAr, nextMenuArray, nextmenuitem, props, rdr, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    rdr = Corefw.util.Render;
    evt = Corefw.util.Event;
    for (_i = 0, _len = menuArray.length; _i < _len; _i++) {
      menuItemCache = menuArray[_i];
      menuitem = {};
      props = menuItemCache._myProperties;
      if (!props) {
        props = menuItemCache;
      }
      menuitem.text = props.title;
      menuitem.name = props.name;
      menuitem.tooltip = props.toolTip;
      menuitem.hidden = !props.visible;
      menuitem.disabled = !props.enabled;
      menuitem.cache = menuItemCache;
      menuitem.coretype = 'gridheaderdropdownmenubutton';
      menuitem.grid = this;
      menuitem.custom = true;
      evt.addEvents(props, 'menu', menuitem);
      nextMenuArray = [];
      if (menuItemCache.allContents) {
        _ref = menuItemCache.allContents;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          nextmenuitem = _ref[_j];
          nextMenuArray.push(nextmenuitem);
        }
      }
      if (menuItemCache.allNavigations) {
        _ref1 = menuItemCache.allNavigations;
        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
          nextmenuitem = _ref1[_k];
          nextMenuArray.push(nextmenuitem);
        }
      }
      if (nextMenuArray && nextMenuArray.length) {
        newAr = [];
        menuitem.menu = newAr;
        menuParent.push(menuitem);
        this.createMenuItemsWorker(nextMenuArray, newAr);
      } else {
        menuParent.push(menuitem);
      }
    }
  },
  onShowColumnMenu: function(headerCt, column, e) {
    var menu, menuitem, menuitemArray, props, _i, _len;
    props = column.cache._myProperties;
    menu = headerCt.getMenu();
    menuitemArray = menu.items.items;
    for (_i = 0, _len = menuitemArray.length; _i < _len; _i++) {
      menuitem = menuitemArray[_i];
      if (menuitem.menuoperation === 'addsort') {
        if (props.supportSort) {
          menuitem.show();
        } else {
          menuitem.hide();
        }
      }
    }
  },
  setHeaderActive: function(activeHeader) {
    var header, _i, _len, _ref;
    _ref = this.columns;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      header = _ref[_i];
      header.active = false;
    }
    activeHeader.active = true;
  },
  addListeners: function() {
    var listeners, viewConfig;
    listeners = {
      beforeitemdblclick: this.onBeforeitemdblclickEvent,
      beforecelldblclick: this.onBeforecelldblclickEvent,
      columnmove: this.onGridColumnMove,
      viewready: this.onGridViewReady,
      boxready: this.onGridBoxready
    };
    this.listeners = this.listeners || {};
    Ext.merge(this.listeners, listeners);
    viewConfig = {
      listeners: {
        refresh: this.onGridViewRefresh,
        resize: this.onGridViewResize
      }
    };
    if (this.viewConfig) {
      return Ext.merge(this.viewConfig, viewConfig);
    } else {
      return this.viewConfig = viewConfig;
    }
  },
  onBeforeSelectEvent: function() {
    return this.selectHandlerForRowEditor();
  },
  onBeforeDeselectEvent: function() {
    return this.selectHandlerForRowEditor();
  },
  onBeforeitemclickEvent: function() {
    return this.disableFireEventForRowEditor();
  },
  onBeforeitemdblclickEvent: function() {
    return this.disableFireEventForRowEditor();
  },
  onBeforecellclickEvent: function() {
    return this.disableFireEventForRowEditor();
  },
  onBeforecelldblclickEvent: function() {
    return this.disableFireEventForRowEditor();
  },
  onGridColumnMove: function(ct, column, fromIdx, toIdx) {
    var events, fieldContainer, grid, gridEvent, postData, _ref, _ref1;
    fieldContainer = ct.up('fieldcontainer');
    grid = fieldContainer.grid || fieldContainer.tree;
    grid.updateLayout();
    grid.updateIndexesAfterColumnMove(column, fromIdx, toIdx);
    events = ((_ref = fieldContainer.cache) != null ? (_ref1 = _ref._myProperties) != null ? _ref1.events : void 0 : void 0) || {};
    gridEvent = events['COLUMNMOVE'] || events['ONCOLUMNSTATECHANGE'];
    if (gridEvent && gridEvent.type) {
      postData = fieldContainer.generatePostData();
      if (typeof grid.remoteLoadStoreData === "function") {
        grid.remoteLoadStoreData(postData, {
          event: gridEvent.type
        });
      }
    }
  },
  updateIndexesAfterColumnMove: function(column, fromIndex, toIndex) {
    var col, columns, firstColumn, index, me, movedColumnName, movedColumns, prevColumn, prevColumnName, rebuildRecordDataExtractor, startIndex, updateIndex, updateSubColumnIndexes, _i, _j, _len, _len1;
    me = this;
    columns = me.columns;
    if (me.xtype === 'coretreegrid') {
      me = me.tree;
      columns = me.columns;
    }
    if (!columns) {
      return;
    }
    updateIndex = function(col, newIndex) {
      col.origIndex = '' + col.cache._myProperties.index;
      col.cache._myProperties.index = newIndex;
      return col.dataIndex = '' + newIndex;
    };
    updateSubColumnIndexes = function(groupHeader, movedColumns, index) {
      var col, subColumns, _i, _len;
      subColumns = groupHeader.items.items;
      for (_i = 0, _len = subColumns.length; _i < _len; _i++) {
        col = subColumns[_i];
        updateIndex(col, index);
        index++;
      }
      return index;
    };
    rebuildRecordDataExtractor = function(newColumns) {
      var col, field, fields, items, map, store, _i, _j, _len, _len1;
      store = me.getStore();
      fields = store.model.prototype.fields;
      items = fields.items;
      map = fields.map;
      for (_i = 0, _len = newColumns.length; _i < _len; _i++) {
        col = newColumns[_i];
        field = map[col.origIndex];
        field.name = col.dataIndex;
        field.originalIndex = +col.dataIndex;
      }
      for (_j = 0, _len1 = items.length; _j < _len1; _j++) {
        field = items[_j];
        map[field.name] = field;
      }
      store.proxy.reader.convertRecordData = store.proxy.reader.buildRecordDataExtractor();
    };
    movedColumnName = column.name;
    firstColumn = columns[0].cache ? columns[0] : columns[1];
    startIndex = +firstColumn.cache._myProperties.index;
    prevColumn = me.columnManager.getHeaderAtIndex(me.columnManager.getHeaderIndex(column) - 1);
    if (!(prevColumn != null ? prevColumn.cache : void 0)) {
      prevColumn = null;
    }
    prevColumnName = prevColumn != null ? prevColumn.name : void 0;
    movedColumns = [];
    if (!prevColumn) {
      movedColumns.push(column);
      column.cache._myProperties.index = startIndex;
      startIndex++;
      index = startIndex;
      for (_i = 0, _len = columns.length; _i < _len; _i++) {
        col = columns[_i];
        if (!col.cache) {
          continue;
        }
        if (col.name !== movedColumnName) {
          movedColumns.push(col);
          updateIndex(col, index);
          ++index;
        }
      }
    } else {
      index = startIndex;
      for (_j = 0, _len1 = columns.length; _j < _len1; _j++) {
        col = columns[_j];
        if (!col.cache) {
          continue;
        }
        if (col.name !== movedColumnName) {
          movedColumns.push(col);
          updateIndex(col, index);
          index++;
        }
        if (col.name === prevColumnName) {
          if (!column.isGroupHeader) {
            movedColumns.push(column);
            updateIndex(column, index);
            ++index;
          } else {
            index = updateSubColumnIndexes(column, movedColumns, index);
          }
        }
      }
    }
    me.columns = movedColumns;
    rebuildRecordDataExtractor(movedColumns);
  },
  validateColumnOrdersFromCache: function(girdcache) {
    var index, newCol, newColumns, newColumnsCache, origCol, origColumns, origColumnsLength, res, _i, _ref;
    res = {
      isValid: true,
      columnsDef: []
    };
    origColumns = {};
    this.columns.forEach(function(col) {
      return col.pathString && (origColumns[col.dataIndex] = col);
    });
    newColumns = {};
    if (girdcache) {
      newColumnsCache = girdcache._myProperties.allContents;
    } else {
      newColumnsCache = this.cache._myProperties.allContents;
    }
    newColumnsCache.forEach(function(col) {
      return newColumns[col.index] = col;
    });
    origColumnsLength = this.columns.length;
    for (index = _i = 0, _ref = origColumnsLength - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; index = 0 <= _ref ? ++_i : --_i) {
      origCol = origColumns[index];
      newCol = newColumns[index];
      if (!origCol || !newCol) {
        continue;
      }
      if (origCol.pathString !== newCol.pathString) {
        res.isValid = false;
        break;
      }
    }
    if (res.isValid === false) {
      newColumns = [];
      this.createColumnsFromCache(newColumns);
      res.columnsDef = newColumns;
    }
    return res;
  },
  shouldReCreateGrid: function(gridcache) {
    var isReCreateGrid;
    isReCreateGrid = true;
    if (gridcache._myProperties.onlyRefreshGridData) {
      isReCreateGrid = false;
    }
    return isReCreateGrid;
  },
  isShowMultiSortingIcon: function(gridProps) {
    var sortHeaders;
    sortHeaders = gridProps.sortHeaders || [];
    return gridProps.multiColumnSortingEnabled === true && sortHeaders.length > 0;
  },
  insertMultiSortingIcon: function(column, sortHeaders) {
    var align, dataIndex, domHelper, h, imgSrc, index, isContinue, position, sortBy, sortIconDiv, sortIconImg, sortIconSpan, sortIndexSpan, su, _i, _len;
    if (!(column && sortHeaders && sortHeaders.length > 0)) {
      return false;
    }
    this.removeMultiSortingIcon(column);
    domHelper = Ext.DomHelper;
    align = column.align;
    position = align === 'left' ? '85%' : '5%';
    dataIndex = column.dataIndex;
    isContinue = false;
    for (index = _i = 0, _len = sortHeaders.length; _i < _len; index = ++_i) {
      h = sortHeaders[index];
      if (h.index + '' === dataIndex) {
        sortBy = h.sortBy.toLowerCase();
        isContinue = true;
        break;
      }
    }
    if (!isContinue) {
      return false;
    }
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      sortIconSpan = domHelper.createDom({
        tag: 'span',
        id: 'sortIcon',
        style: 'display: inline-block; line-height: 41px; color: #656262;',
        "class": 'imagediv ' + sortBy.toUpperCase()
      });
      sortIconSpan.innerText = index + 1;
      column.titleEl && column.titleEl.dom && column.titleEl.dom.appendChild(sortIconSpan);
    } else {
      imgSrc = "resources/images/datagrid-images/" + sortBy + ".png";
      sortIconDiv = domHelper.createDom({
        tag: 'div',
        id: 'sortIcon',
        style: "float:left;position: absolute;top: 6px;left: " + position + ";cursor: pointer;z-index:2;width:15px;height:17px;",
        "class": 'imagediv'
      });
      sortIndexSpan = domHelper.createDom({
        tag: 'span',
        style: 'float: left'
      });
      sortIndexSpan.innerText = index + 1;
      sortIconImg = domHelper.createDom({
        tag: 'img',
        style: 'float: left;',
        src: imgSrc
      });
      sortIconDiv.appendChild(sortIndexSpan);
      sortIconDiv.appendChild(sortIconImg);
      column.titleEl && column.titleEl.dom && column.titleEl.dom.appendChild(sortIconDiv);
    }
    return true;
  },
  removeMultiSortingIcon: function(column) {
    var rs, su;
    if (!column) {
      return false;
    }
    su = Corefw.util.Startup;
    if (su.getThemeVersion() === 2) {
      rs = column.titleEl.select('span#sortIcon');
    } else {
      rs = column.titleEl.select('div#sortIcon');
    }
    if (rs.elements.length === 0) {
      return false;
    }
    rs.remove();
  },
  onGridViewRefresh: function(dataView) {
    var bottomBar, bottomText, container, fn, footerText, grid, props;
    grid = dataView.ownerCt;
    container = grid.ownerCt;
    if (grid.getWidth() > 3000 || dataView.isLockingView || grid.isLockedView || grid.isLocked) {
      return;
    }
    Ext.suspendLayouts();
    if (!grid.cache) {
      grid = grid.up('coregridbase') || grid.up('coretreebase');
    }
    props = grid.cache._myProperties;
    grid.setSelection();
    if (grid.isShowMultiSortingIcon(props)) {
      grid.restoreSortingIcon(props);
    }
    Ext.each(grid.columns, function(column) {
      if (column.allowAutoWidth === true) {
        column.autoSize();
      }
    });
    if (grid.xtype === 'coretreebase') {
      fn = Ext.Function.createDelayed(function() {
        return grid.resetContainerHeightAndWidth();
      }, 1);
      fn();
    } else {
      grid.resetContainerHeightAndWidth();
    }
    Ext.resumeLayouts();
    if ((container != null ? container.shouldUpdateLayout : void 0) === true) {
      delete container.shouldUpdateLayout;
      container.updateLayout();
    }
    grid.adjustGroupHeadersWidth();
    if ((bottomBar = grid.down('toolbar[dock="bottom"]')) && (footerText = props.footerText)) {
      bottomText = {
        xtype: 'tbtext',
        text: footerText,
        margin: '0 4 0 4',
        style: {
          'color': '#53565A'
        }
      };
      bottomBar.removeAll();
      bottomBar.add(bottomText);
    }
    if (Ext.isString(props.title) && grid.xtype === 'coregridbase') {
      grid.updateTitle(props.title);
    }
    if (typeof grid.styleDecorate === "function") {
      grid.styleDecorate();
    }
  },
  onGridViewResize: function(view, width, height, oldWidth, oldHeigh) {
    var container, containerHeight, grid, lastRow, scrollbarHeight;
    if (0 === oldWidth || 0 === oldHeigh) {
      return;
    }
    grid = view.ownerCt;
    container = grid.ownerCt;
    containerHeight = container != null ? container.getHeight() : void 0;
    if (!containerHeight) {
      return;
    }
    scrollbarHeight = Ext.getScrollbarSize().height;
    if (typeof grid.hasHScrollbar === "function" ? grid.hasHScrollbar() : void 0) {
      lastRow = Ext.DomQuery.select('tr[role=row]:last', view.el.dom)[0];
      if (lastRow && (container.el.dom.getBoundingClientRect().bottom - lastRow.getBoundingClientRect().bottom) < scrollbarHeight) {
        container.suspendEvents();
        container.setHeight(scrollbarHeight + containerHeight);
        container.heightChanged = true;
        container.resumeEvents();
        grid.resetElementHeight(container);
      }
    } else {
      if (container.heightChanged && !view.xtype === 'treeview') {
        container.suspendEvents();
        delete container.heightChanged;
        container.setHeight(containerHeight - scrollbarHeight);
        container.resumeEvents();
      }
    }
    if (view.xtype === 'treeview') {
      delete container.height;
    }
  },
  resetContainerHeightAndWidth: function() {
    var comp, container, element, hScrollHeight, layoutType, view, viewHeight, _ref, _ref1;
    comp = this;
    view = comp.view;
    container = comp.ownerCt;
    element = container != null ? container.ownerCt : void 0;
    if (!(element && (element != null ? element.cache : void 0) && (element != null ? element.xtype : void 0) === 'coreelementform')) {
      return;
    }
    layoutType = (_ref = element.cache._myProperties) != null ? (_ref1 = _ref.layout) != null ? _ref1.type : void 0 : void 0;
    if (layoutType !== 'VBOX') {
      return;
    }
    if (this.stopReset) {
      delete this.stopReset;
      return;
    }
    if (this.shouldResetHeight()) {
      container.shouldUpdateLayout = true;
      hScrollHeight = Ext.getScrollbarSize().height;
      viewHeight = view.getHeight();
      if (view.minHeight && viewHeight < view.minHeight) {
        container.setHeight(container.getHeight() + view.minHeight - viewHeight + hScrollHeight);
      } else if (view.maxHeight && viewHeight > view.maxHeight) {
        container.setHeight(container.getHeight() + view.maxHeight - viewHeight + hScrollHeight);
      } else {
        container.setHeight(container.getHeight() + hScrollHeight);
      }
      this.resetElementHeight(container);
      if (comp.xtype === 'coretreebase') {
        comp.setHeight(comp.getHeight() + hScrollHeight);
      }
      this.stopReset = true;
    }
  },
  resetElementHeight: function(gc) {
    var fn;
    fn = Ext.Function.createDelayed(function() {
      var ce, ef, _ref, _ref1;
      ef = gc != null ? gc.up('coreelementform') : void 0;
      if (!ef) {
        return;
      }
      ce = ef.up('corecompositeelement');
      if ((ce != null ? (_ref = ce.body) != null ? _ref.getHeight() : void 0 : void 0) === 0) {
        return ce.setHeight(ce.getHeight());
      } else if ((ef != null ? (_ref1 = ef.body) != null ? _ref1.getHeight() : void 0 : void 0) === 0) {
        return ef.setHeight(ef.getHeight());
      }
    }, 1);
    fn();
  },
  shouldResetHeight: function() {
    var comp, container, containerBottom, data, diffHeight, scrollbarHeight, selfBottom, store, view;
    comp = this;
    view = comp.view || {};
    store = comp.store || {};
    data = store.tree ? store.tree.flatten() : store.data;
    if ((data != null ? data.length : void 0) === 0) {
      return false;
    }
    scrollbarHeight = Ext.getScrollbarSize().height;
    selfBottom = comp.getView().el.dom.getBoundingClientRect().bottom;
    container = comp.ownerCt;
    if (!container) {
      return false;
    }
    containerBottom = container.el.dom.getBoundingClientRect().bottom || 0;
    diffHeight = selfBottom - containerBottom;
    return !view.isLockingView && comp.hasHScrollbar() && (diffHeight > (scrollbarHeight / 5));
  },
  restoreSortingIcon: function(gridProps) {
    var columns, grid, sortHeaders;
    grid = this;
    columns = grid.columns;
    sortHeaders = gridProps.sortHeaders;
    Ext.each(columns, function(column) {
      grid.insertMultiSortingIcon(column, sortHeaders);
    });
  },
  restoreHeaderSortState: function() {
    var aClass, dClass, grid, h, headerCt, iv, length, pathString, props, sortBy, sortHeaders, _ref, _ref1, _ref2;
    iv = Corefw.util.InternalVar;
    grid = this;
    aClass = 'x-column-header-sort-ASC';
    dClass = 'x-column-header-sort-DESC';
    props = ((_ref = grid.cache) != null ? _ref._myProperties : void 0) || {};
    sortHeaders = props.sortHeaders || [];
    length = sortHeaders.length;
    if (length === 0 || length > 1 || props.multiColumnSortingEnabled === true) {
      return false;
    }
    _ref1 = sortHeaders[0], sortBy = _ref1.sortBy, pathString = _ref1.pathString;
    h = grid.columns.filter(function(c) {
      return c.pathString === pathString;
    })[0];
    if (!(h != null ? (_ref2 = h.el) != null ? _ref2.dom : void 0 : void 0)) {
      return;
    }
    headerCt = h.up();
    switch (sortBy) {
      case 'DESC':
        h.addCls(dClass);
        h.removeCls(aClass);
        break;
      case 'ASC':
        h.addCls(aClass);
        h.removeCls(dClass);
        break;
      default:
        h.removeCls([aClass, dClass]);
    }
    headerCt.clearOtherSortStates(h);
    h.sortState = sortBy;
    return true;
  },
  hasHScrollbar: function() {
    var gridViewEl, viewSize, viewSizeWithoutScollbar;
    gridViewEl = this.view.el;
    viewSize = gridViewEl.getSize(true);
    viewSizeWithoutScollbar = gridViewEl.getViewSize();
    if (viewSize.height > viewSizeWithoutScollbar.height) {
      return true;
    } else if (viewSize.height === viewSizeWithoutScollbar.height) {
      return false;
    }
    return false;
  },
  hasVScrollbar: function() {
    var gridViewEl, viewSize, viewSizeWithoutScollbar;
    gridViewEl = this.view.el;
    viewSize = gridViewEl.getSize(true);
    viewSizeWithoutScollbar = gridViewEl.getViewSize();
    if (viewSize.width > viewSizeWithoutScollbar.width) {
      return true;
    }
    return false;
  },
  setMinAndMaxHeightToView: function() {
    var dataView, grid, gridHeaderHeight, maxRow, minRow, props, _ref, _ref1;
    grid = this.ownerCt;
    dataView = grid != null ? grid.view : void 0;
    if (!dataView || (dataView != null ? dataView.isLockingView : void 0)) {
      return;
    }
    props = grid.cache._myProperties;
    minRow = +props.minRow;
    maxRow = +props.maxRow;
    gridHeaderHeight = (((_ref = grid.header) != null ? typeof _ref.getHeight === "function" ? _ref.getHeight() : void 0 : void 0) || 0) + ((_ref1 = grid.headerCt) != null ? typeof _ref1.getHeight === "function" ? _ref1.getHeight() : void 0 : void 0) || 0;
    if (minRow) {
      grid.minHeight = gridHeaderHeight + grid.defaultRowHeight * minRow;
    }
    if (maxRow) {
      grid.maxHeight = gridHeaderHeight + grid.defaultRowHeight * maxRow;
    }
  },
  selectHandlerForRowEditor: function() {
    if (!this.isEditable) {
      return true;
    }
    return this.isCheckClicked();
  },
  isCheckClicked: function() {
    var event, headerCheckBtnCls, selectBtnCls, target, _ref, _ref1;
    event = window.event;
    if (!event) {
      return false;
    }
    selectBtnCls = Ext.baseCSSPrefix + 'grid-row-checker';
    headerCheckBtnCls = Ext.baseCSSPrefix + 'column-header-text';
    target = event.target;
    if ((target != null ? (_ref = target.classList) != null ? _ref.contains(selectBtnCls) : void 0 : void 0) || (target != null ? (_ref1 = target.classList) != null ? _ref1.contains(headerCheckBtnCls) : void 0 : void 0)) {
      return true;
    }
    return false;
  },
  disableFireEventForRowEditor: function() {
    if (this.isEditable && !this.isCheckClicked()) {
      this.stopFireEvents = true;
    } else {
      this.stopFireEvents = false;
    }
    return true;
  },
  adjustGroupHeadersWidth: function() {
    var adjustWidth, column, columns, columnsMetaData, context, data, flex, grid, gridWidth, groupHeaders, headers, index, needAdjustColumnContext, props, remainingSpace, totalFlex, totalWidth, _i, _j, _len, _len1;
    grid = this;
    if (!(grid && grid.el && grid.el.dom)) {
      return;
    }
    gridWidth = grid.getWidth();
    if (!(gridWidth > 0 && grid.headerCt.el && grid.headerCt.getWidth() > 0 && !grid.isSetWidth)) {
      return;
    }
    headers = grid.headerCt.items.items;
    groupHeaders = (headers.filter(function(h) {
      return h.isGroupHeader && !h.hidden;
    })) || [];
    if (!(groupHeaders.length >= 1)) {
      return;
    }
    needAdjustColumnContext = [];
    totalWidth = 0;
    totalFlex = 0;
    columnsMetaData = grid.cache._myProperties.columnAr;
    columns = grid.columns;
    for (index = _i = 0, _len = columnsMetaData.length; _i < _len; index = ++_i) {
      data = columnsMetaData[index];
      props = data._myProperties;
      if (props.visible === false) {
        continue;
      }
      column = columns[index];
      if (flex = props.flexWidth > 0) {
        totalFlex += flex;
        column.ownerCt.isGroupHeader && needAdjustColumnContext.push({
          column: column,
          flex: flex
        });
      } else {
        totalWidth += props.width || column.getWidth();
      }
    }
    remainingSpace = gridWidth - totalWidth;
    grid.hasVScrollbar() && (remainingSpace -= Ext.getScrollbarSize().width);
    for (_j = 0, _len1 = needAdjustColumnContext.length; _j < _len1; _j++) {
      context = needAdjustColumnContext[_j];
      column = context.column;
      adjustWidth = Math.round(remainingSpace / totalFlex);
      column.width = adjustWidth;
      column.setWidth(adjustWidth);
      remainingSpace -= adjustWidth;
      totalFlex -= context.flex;
    }
    grid.isSetWidth = true;
  },
  generateHeadersPostData: function(gridCache) {
    var colProps, oneCache, postData, postProps, prop;
    postData = [];
    for (prop in gridCache) {
      oneCache = gridCache[prop];
      if (prop === '_myProperties') {
        continue;
      }
      colProps = oneCache._myProperties;
      postProps = {};
      postProps.filterOperator = colProps.filterOperator;
      postProps.filterValue = colProps.filterValue;
      postProps.visible = colProps.visible;
      postProps.name = colProps.name;
      postProps.index = +colProps.index;
      postProps.width = colProps.width;
      postData.push(postProps);
    }
    return postData;
  },
  generatePostDataForRetrieve: function() {
    var cache, postData, props;
    cache = Corefw.util.Common.objectClone(this.cache);
    delete cache._myProperties;
    props = this.cache._myProperties;
    postData = {
      name: props.name
    };
    postData.allContents = this.generateHeadersPostData(cache);
    return postData;
  },
  onGridViewReady: function() {
    this.hideColumnsByCache();
  },
  onGridBoxready: function() {},
  hideColumnsByCache: function() {
    var me;
    me = this;
    return this.columnManager.getColumns().forEach(function(col) {
      var cache;
      if (cache = col.cache) {
        if (cache._myProperties.visible === false) {
          me.suspendHidingEvent = true;
          col.hide();
          return delete me.suspendHidingEvent;
        }
      }
    });
  },
  prepareFieldObj: function() {
    var cache, colObj, fieldObj, iv, key, prop, _results;
    cache = this.cache;
    fieldObj = this.fieldObj = {};
    iv = Corefw.util.InternalVar;
    iv.setByNameProperty(cache._myProperties.uipath, 'fieldObj', fieldObj);
    _results = [];
    for (key in cache) {
      colObj = cache[key];
      if (key !== '_myProperties') {
        prop = colObj._myProperties;
        _results.push(fieldObj[prop.index + ''] = prop);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  },
  getFieldObj: function(uipath) {
    var fieldObj, iv;
    iv = Corefw.util.InternalVar;
    fieldObj = iv.getByNameProperty(uipath, 'fieldObj');
    if (!fieldObj) {
      fieldObj = this.prepareFieldObj();
    }
    return fieldObj;
  },
  prepareInfinityGridStore: function(gridbase, store, scrollStr, storeDataAr) {
    var gridProps, gridView;
    gridProps = gridbase.cache._myProperties;
    if (gridProps.infiniteFinish === 'FINISH') {
      return;
    }
    Ext.suspendLayouts();
    if (scrollStr === 'ONSCROLLDOWN') {
      if (store.data.length === gridProps.bufferedPages * gridProps.pageSize && gridProps.currentPage > gridProps.bufferedPages) {
        store.currentPage = store.currentPage - gridProps.bufferedPages + 1;
      } else {
        store.currentPage = 1;
      }
    } else if (scrollStr === 'ONSCROLLUP') {
      store.currentPage = gridProps.currentPage;
    } else {
      store.currentPage = 1;
    }
    if (store.totalCount > 0) {
      storeDataAr = {
        totalCount: store.totalCount,
        topics: storeDataAr
      };
    }
    if (gridbase.isLockedView) {
      gridView = gridbase.view.normalView;
    } else {
      gridView = gridbase.view;
    }
    gridView.preserveScrollOnRefresh = false;
    gridView.scrollRowIntoView(store.getAt(Math.ceil(store.data.length * 4 / 5)));
    gridbase.enableScrollDownEvent = true;
    gridbase.enableScrollUpEvent = true;
    Ext.resumeLayouts();
  },
  resetInfinityGridConfig: function(gridbase, props, scrollStr) {
    if (scrollStr === 'ONSCROLLDOWN' && props.infiniteFinish !== 'NONE') {
      gridbase.enableScrollDownEvent = false;
      gridbase.enableScrollUpEvent = true;
    }
    if (scrollStr === 'ONSCROLLUP') {
      if (props.currentPage === 1) {
        gridbase.enableScrollUpEvent = false;
      }
      if (gridbase.view.normalView != null) {
        gridbase.view.normalView.el.dom.scrollTop = 50;
      } else {
        gridbase.view.el.dom.scrollTop = 50;
      }
    }
  },
  getRequestUrl: function() {
    var eventStr, events, me, parent, parentProps, rq, shouldSendRqAfterRetrieveData, uipath, url, _ref;
    me = this;
    rq = Corefw.util.Request;
    parent = me;
    parentProps = parent != null ? parent.cache._myProperties : void 0;
    uipath = parentProps.uipath;
    events = (parentProps != null ? parentProps.events : void 0) || parent.events;
    eventStr = events['ONRETRIEVE'] ? 'ONRETRIEVE' : 'ONLOAD';
    shouldSendRqAfterRetrieveData = events['ONRETRIEVE'] && events['ONAFTERRETRIEVE'];
    url = rq.objsToUrl3((_ref = parentProps.events) != null ? _ref[eventStr] : void 0);
    return url;
  },
  remoteLoadStoreData: function(postData, options) {
    var eventStr, events, isTreeGrid, me, parent, parentProps, processor, refreshData, rq, shouldSendRqAfterRetrieveData, uipath, url;
    if (options == null) {
      options = {};
    }
    me = this;
    isTreeGrid = me.xtype === 'coretreebase';
    rq = Corefw.util.Request;
    parent = me.ownerCt;
    parentProps = parent != null ? parent.cache._myProperties : void 0;
    if (parentProps.infinity) {
      return;
    }
    uipath = parentProps.uipath;
    events = (parentProps != null ? parentProps.events : void 0) || {};
    if (options.event) {
      eventStr = options.event;
    } else {
      eventStr = events['ONRETRIEVE'] ? 'ONRETRIEVE' : 'ONLOAD';
      shouldSendRqAfterRetrieveData = events['ONRETRIEVE'] && events['ONAFTERRETRIEVE'];
    }
    url = rq.objsToUrl3(parentProps.events[eventStr]);
    if (isTreeGrid) {
      processor = function() {
        var fieldContainer;
        rq.processResponseObject.apply(rq, arguments);
        if (shouldSendRqAfterRetrieveData) {
          fieldContainer = Ext.ComponentQuery.query("[uipath=" + uipath + "]")[0];
          url = rq.objsToUrl3(parentProps.events['ONAFTERRETRIEVE']);
          return rq.sendRequest5(url, rq.processResponseObject, uipath, fieldContainer.generatePostData());
        }
      };
      rq.sendRequest5(url, processor, uipath, postData);
      return;
    }
    refreshData = function(jsonObj) {
      var cache, cacheObject, dataItems, fieldContainer, grid, name, props, res, store, storeDataAr, _ref, _ref1;
      fieldContainer = Ext.ComponentQuery.query("[uipath=" + jsonObj.uipath + "]")[0] || {};
      grid = fieldContainer.grid;
      if (!grid) {
        return;
      }
      cacheObject = Corefw.util.Cache.parseJsonToCache(jsonObj) || {};
      name = fieldContainer.cache._myProperties.name;
      cache = cacheObject[name];
      cache = grid.updateCache(cache);
      grid.prepareFieldObj();
      props = cache._myProperties;
      parentProps.items = cache._myProperties.items;
      dataItems = (props != null ? (_ref = props.data) != null ? _ref.items : void 0 : void 0) || [];
      storeDataAr = [];
      grid.parseData(dataItems, storeDataAr, grid.fieldObj);
      store = grid.store;
      store.currentPage = props.currentPage;
      grid.view.preserveScrollOnRefresh = false;
      store.loadRawData(storeDataAr);
      store.totalCount = props.totalRows;
      store.pageSize = props.pageSize;
      res = grid.validateColumnOrdersFromCache();
      if (!res.isValid) {
        grid.reconfigure(store, res.columnsDef);
        grid.hideColumnsByCache();
      }
      if ((_ref1 = grid.down('pagingtoolbar')) != null) {
        if (typeof _ref1.onLoad === "function") {
          _ref1.onLoad();
        }
      }
      if (shouldSendRqAfterRetrieveData) {
        url = rq.objsToUrl3(parentProps.events.ONAFTERRETRIEVE);
        rq.sendRequest5(url, rq.processResponseObject, uipath, fieldContainer.generatePostData());
      }
      grid.restoreHeaderSortState();
    };
    rq.sendRequest5(url, refreshData, uipath, postData);
  },
  updateCache: function(cache) {
    var evt, me;
    evt = Corefw.util.Event;
    if (!cache) {
      return;
    }
    this.cache = cache;
    this.ownerCt.cache = cache;
    me = this;
    this.columns.forEach(function(col) {
      var colCache, colProps, colType, columnType, groupColumn, newGroupColumnTitle, newTitle, _ref;
      if (colCache = cache[col.name]) {
        colProps = colCache._myProperties;
        evt.addEvents(colProps, 'column', colProps);
        colType = colProps.columnType ? colProps.columnType : colProps.type;
        columnType = colType != null ? colType.toLowerCase() : void 0;
        colProps.corecolumntype = colProps.columnType = columnType;
        colProps.index = colProps.index + '';
        col.cache = colCache;
        col.iconMap = colProps.iconMap;
        col.linkMap = colProps.linkMap;
        newTitle = colProps.title;
        if (col.isVisible() && col.text !== newTitle) {
          col.setText(newTitle);
        }
        groupColumn = col.up('gridcolumn');
        newGroupColumnTitle = (_ref = colProps.group) != null ? _ref.groupName : void 0;
        if (newGroupColumnTitle && groupColumn && groupColumn.isVisible() && groupColumn.text !== newGroupColumnTitle) {
          groupColumn.setText(newGroupColumnTitle);
        }
        if (!colProps.visible) {
          me.suspendHidingEvent = true;
          col.hide();
          delete me.suspendHidingEvent;
        }
      }
    });
    return cache;
  },
  parseItemData: function(valueObj, fieldObj) {
    var ExtDate, colValue, columnType, dt, lineBreakRe, path, type, _ref, _ref1, _ref2, _ref3, _results;
    lineBreakRe = /\n/g;
    ExtDate = Ext.Date;
    _results = [];
    for (path in valueObj) {
      colValue = valueObj[path];
      type = (_ref = fieldObj[path]) != null ? (_ref1 = _ref.type) != null ? _ref1.toLowerCase() : void 0 : void 0;
      columnType = (_ref2 = fieldObj[path]) != null ? (_ref3 = _ref2.columnType) != null ? _ref3.toLowerCase() : void 0 : void 0;
      if ((type === 'date' || columnType === 'date' || columnType === 'datetime' || columnType === 'month_picker') && colValue) {
        dt = new Date(colValue);
        valueObj[path] = dt;
      } else if (columnType === 'datestring' && colValue) {
        valueObj[path] = ExtDate.parse(colValue, 'Y-m-d H:i:s');
      }
      if (typeof colValue === 'string' && colValue.match(lineBreakRe)) {
        valueObj[path] = colValue.replace(lineBreakRe, '<br>');
        if (valueObj._myProperties == null) {
          valueObj._myProperties = {};
        }
        _results.push(valueObj._myProperties.lineBreakExists = true);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  },
  parseData: function(dataItems, storeDataAr, fieldObj) {
    var parseItemData, valueObj, _i, _len;
    parseItemData = this.parseItemData;
    for (_i = 0, _len = dataItems.length; _i < _len; _i++) {
      valueObj = dataItems[_i];
      storeDataAr.push(valueObj);
      parseItemData(valueObj, fieldObj);
    }
  },
  parseTreeGridData: function(dataNode, fieldObj) {
    var children, node, _i, _len, _results;
    this.parseItemData(dataNode.value, fieldObj);
    children = dataNode.children;
    if (children.length === 0) {
      return;
    }
    _results = [];
    for (_i = 0, _len = children.length; _i < _len; _i++) {
      node = children[_i];
      _results.push(this.parseTreeGridData(node, fieldObj));
    }
    return _results;
  }
});
