// Generated by CoffeeScript 1.8.0
Ext.define('Corefw.store.FilterCriteria', {
  extend: 'Ext.data.Store',
  model: 'Corefw.model.FilterCriteria',
  isGlobal: false,
  config: {
    timeMarkKeyItemName: ''
  },
  addToStore: function(criObj) {
    var rec, s;
    s = this;
    rec = s.find('pathString', criObj.pathString);
    if (rec > -1) {
      Corefw.Msg.alert('Alert', criObj.displayName + ' already exists.');
      return 0;
    } else {
      s.add(criObj);
      return 1;
    }
  },
  fetchTimeMarkDisplayString: function(timeMarkDDIs) {
    var d, ret, _i, _len;
    timeMarkDDIs = [].concat(timeMarkDDIs);
    ret = [];
    for (_i = 0, _len = timeMarkDDIs.length; _i < _len; _i++) {
      d = timeMarkDDIs[_i];
      ret.push(d.get('operandsString'));
    }
    return ret;
  },
  fetchTimeMarkItemName: function(timeMarkDDIs) {
    var i, itemName, len;
    timeMarkDDIs = [].concat(timeMarkDDIs);
    itemName = '';
    i = 0;
    len = timeMarkDDIs.length;
    while (i < len) {
      itemName = timeMarkDDIs[i].get('itemName');
      if (itemName) {
        return itemName;
      }
      i++;
    }
  },
  loadRecords: function(records, options) {
    var addRecords, newRecds, rawData, record, timeMarkRed, timeMarks, _i, _len;
    addRecords = false;
    timeMarkRed = null;
    newRecds = [];
    if (options) {
      addRecords = options.addRecords;
    }
    timeMarks = [];
    for (_i = 0, _len = records.length; _i < _len; _i++) {
      record = records[_i];
      if (this.isTimeMarkCriteriaPath(record.get('pathString'))) {
        timeMarks.push(record);
        if (record.get('pathString').indexOf('TimeMark Key' > -1)) {
          this.setTimeMarkKeyItemName(record.get('itemName'));
        }
      } else {
        newRecds.push(record);
      }
    }
    if (timeMarks.length) {
      rawData = {
        pathString: 'TIME MARK',
        itemName: '',
        operator: '',
        disabled: false,
        dataTypeString: ''
      };
      timeMarkRed = this.createModel(rawData);
      timeMarkRed.setChildren(timeMarks);
      newRecds.unshift(timeMarkRed);
    }
    this.callParent([newRecds, options]);
  },
  getCriObjByPath: function(path) {
    var ret;
    ret = null;
    this.each(function(record) {
      var _path;
      _path = record.get('pathString');
      ret = record;
      if (_path === path) {
        return false;
      }
    });
    if (ret) {
      return this.getCriteriaFromRecord(ret);
    }
  },
  isTimeMarkCriteriaPath: function(path) {
    if (path) {
      return path.indexOf('D:TimeMark-I:') > -1;
    }
    return false;
  },
  clearTimeMarkCriteria: function() {
    var me;
    me = this;
    this.filterBy(function(record) {
      return !me.isTimeMarkPath(record.get('pathString'));
    });
  },
  isTimeMarkPath: function(path) {
    return path === 'TIME MARK';
  },
  listeners: {
    remove: function(store, record, index, isMove, eOpts) {
      store.saveCriteriaIntoSession(store);
    },
    datachanged: function(store, eOpts) {
      store.saveCriteriaIntoSession(store);
    },
    load: function(store, records, successful, eOpts) {
      store.saveCriteriaIntoSession(store);
    }
  },
  saveCriteriaIntoSession: function(store) {},
  refreshCriteriaStore: function(criteria) {
    var getNegatedOp, persistCriterion, store, _i, _len;
    store = this;
    getNegatedOp = function(op) {
      var map;
      map = {};
      map["isNull"] = "isNotNull";
      map["in"] = "notIn";
      return map[op];
    };
    store.removeAll();
    if (criteria !== null) {
      for (_i = 0, _len = criteria.length; _i < _len; _i++) {
        persistCriterion = criteria[_i];
        if (persistCriterion.isNegated) {
          persistCriterion.operator = getNegatedOp(persistCriterion.operator);
          persistCriterion.isNegated = false;
        }
        this.addItemCriteriaStore(persistCriterion);
      }
      if (criteria.length === 0) {
        store.fireEvent('refresh', store);
      }
    }
  },
  addItemCriteriaStore: function(newOrUpdatedCriterion, triggerOwner) {
    var critClone, criterionList, store;
    store = this;
    criterionList = store.getCriteria();
    critClone = Ext.clone(criterionList);
    Corefw.model.FilterCriteria.setAggregationOrCompareInfo(newOrUpdatedCriterion, triggerOwner);
    criterionList = this.addCriterion(newOrUpdatedCriterion, criterionList);
    store.loadData(criterionList);
    return true;
  },
  compare: function(v1, v2) {
    if (!v1 || v1.length === 0) {
      v1 = null;
    }
    if (!v2 || v2.length === 0) {
      v2 = null;
    }
    if (v1 === 'null') {
      v1 = null;
    }
    if (v2 === 'null') {
      v2 = null;
    }
    if (v1 === v2) {
      return true;
    }
    return false;
  },
  getCriteriaFromRecord: function(record) {
    var fn, item, list, ret, _i, _len;
    list = record.getChildren();
    if (list) {
      ret = [];
      fn = arguments.callee;
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        item = list[_i];
        ret.push(fn(item));
      }
      return ret;
    }
    return record.data;
  },
  getCriteria: function() {
    var criteria, item, me, _i, _len, _ref;
    me = this;
    criteria = [];
    _ref = me.data.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      criteria = criteria.concat(this.getCriteriaFromRecord(item));
    }
    if (criteria.length < 1) {
      return null;
    } else {
      return criteria;
    }
  },
  replaceDateCriterion: function(store, criObj) {
    var criterion, criterionList, newData, replace, _i, _len;
    criterionList = store.getCriteria();
    replace = false;
    newData = [];
    if (criterionList) {
      for (_i = 0, _len = criterionList.length; _i < _len; _i++) {
        criterion = criterionList[_i];
        if (criterion.pathString.indexOf('Date') === -1) {
          newData.push(criterion);
        } else {
          newData.push(criObj);
          replace = true;
        }
      }
    }
    if (!replace) {
      store.add(criObj);
    } else {
      store.loadData(newData);
    }
  },
  getDateCriterionValue: function(store) {
    var criterion, criterionList, _i, _len;
    criterionList = store.getCriteria();
    if (criterionList) {
      for (_i = 0, _len = criterionList.length; _i < _len; _i++) {
        criterion = criterionList[_i];
        if (criterion.pathString.indexOf('/D:TimeMark-I:TimeMark Key') > -1) {
          return criterion.operandsString[0];
        }
      }
    }
    return null;
  },
  equals: function(store) {
    var item, _i, _len, _ref;
    if (this === store) {
      return true;
    }
    if (!(store instanceof Corefw.store.FilterCriteria)) {
      return false;
    }
    if (!store) {
      return false;
    }
    if (!this.data) {
      if (store.data) {
        return false;
      }
    } else {
      if (!store.data) {
        return false;
      }
    }
    if (this.data.length !== store.data.length) {
      return false;
    }
    _ref = this.data.items;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      if (!item.equals(store.data.items[i])) {
        return false;
      }
    }
    return true;
  },
  addCriteionList: function(addCriterionList) {
    var critClone, criterion, criterionList, store, _i, _len;
    store = this;
    criterionList = store.getCriteria();
    critClone = Ext.clone(criterionList);
    for (_i = 0, _len = addCriterionList.length; _i < _len; _i++) {
      criterion = addCriterionList[_i];
      critClone = this.addCriterion(criterion, critClone);
    }
    return critClone;
  },
  addCriterion: function(newOrUpdatedCriterion, criterionList) {
    var criterion, index, replace, _i, _len;
    replace = false;
    if (criterionList) {
      for (index = _i = 0, _len = criterionList.length; _i < _len; index = ++_i) {
        criterion = criterionList[index];
        if (this.compare(criterion.pathString, newOrUpdatedCriterion.pathString) && this.compare(criterion.compareMeasureName, newOrUpdatedCriterion.compareMeasureName) && this.compare(criterion.compareTimeoffset, newOrUpdatedCriterion.compareTimeoffset) && this.compare(criterion.aggregationMeasure, newOrUpdatedCriterion.aggregationMeasure)) {
          replace = true;
          if (!newOrUpdatedCriterion.measure && (newOrUpdatedCriterion.operator === 'eq' || newOrUpdatedCriterion.operator === 'in') && (newOrUpdatedCriterion.operator === 'eq' || criterion.operator === 'in')) {
            criterion.dataTypeString = newOrUpdatedCriterion.dataTypeString;
            if (newOrUpdatedCriterion.from !== void 0 || newOrUpdatedCriterion.from === 'focus') {
              criterion.operandsString = newOrUpdatedCriterion.operandsString;
              criterion.operator = newOrUpdatedCriterion.operator;
              continue;
            }
            if (newOrUpdatedCriterion.replaceOps) {
              criterion.operandsString = newOrUpdatedCriterion.operandsString;
            } else {
              criterion.operandsString = Ext.Array.merge(criterion.operandsString, newOrUpdatedCriterion.operandsString);
            }
            if (criterion.operandsString.length > 1) {
              criterion.operator = 'in';
            } else {
              criterion.operator = newOrUpdatedCriterion.operator;
            }
          } else {
            criterionList[index] = newOrUpdatedCriterion;
          }
        }
      }
    } else {
      criterionList = [];
    }
    if (!replace) {
      criterionList.push(newOrUpdatedCriterion);
    }
    return criterionList;
  }
});
